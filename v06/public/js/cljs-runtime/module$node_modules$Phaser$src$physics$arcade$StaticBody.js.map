{
"version":3,
"file":"module$node_modules$Phaser$src$physics$arcade$StaticBody.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/arcade/StaticBody.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$arcade$StaticBody\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar CircleContains = require('../../geom/circle/Contains');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('./const');\r\nvar RectangleContains = require('../../geom/rectangle/Contains');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Static Arcade Physics Body.\r\n *\r\n * A Static Body never moves, and isn't automatically synchronized with its parent Game Object.\r\n * That means if you make any change to the parent's origin, position, or scale after creating or adding the body, you'll need to update the Body manually.\r\n *\r\n * A Static Body can collide with other Bodies, but is never moved by collisions.\r\n *\r\n * Its dynamic counterpart is {@link Phaser.Physics.Arcade.Body}.\r\n *\r\n * @class StaticBody\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - [description]\r\n * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n */\r\nvar StaticBody = new Class({\r\n\r\n    initialize:\r\n\r\n    function StaticBody (world, gameObject)\r\n    {\r\n        var width = (gameObject.width) ? gameObject.width : 64;\r\n        var height = (gameObject.height) ? gameObject.height : 64;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameObject = gameObject;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#debugShowBody\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugShowBody = world.defaults.debugShowStaticBody;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#debugBodyColor\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugBodyColor = world.defaults.staticBodyDebugColor;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#enable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enable = true;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#isCircle\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isCircle = false;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#radius\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.radius = 0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#offset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.offset = new Vector2();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.position = new Vector2(gameObject.x - gameObject.displayOriginX, gameObject.y - gameObject.displayOriginY);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#halfWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfWidth = Math.abs(this.width / 2);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#halfHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfHeight = Math.abs(this.height / 2);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#center\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.center = new Vector2(gameObject.x + this.halfWidth, gameObject.y + this.halfHeight);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#velocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */\r\n        this.velocity = Vector2.ZERO;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#allowGravity\r\n         * @type {boolean}\r\n         * @readOnly\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.allowGravity = false;\r\n\r\n        /**\r\n         * Gravitational force applied specifically to this Body. Values are in pixels per second squared. Always zero for a Static Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */\r\n        this.gravity = Vector2.ZERO;\r\n\r\n        /**\r\n         * Rebound, or restitution, following a collision, relative to 1. Always zero for a Static Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#bounce\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */\r\n        this.bounce = Vector2.ZERO;\r\n\r\n        //  If true this Body will dispatch events\r\n\r\n        /**\r\n         * Whether the simulation emits a `worldbounds` event when this StaticBody collides with the world boundary (and `collideWorldBounds` is also true).\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#onWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.onWorldBounds = false;\r\n\r\n        /**\r\n         * Whether the simulation emits a `collide` event when this StaticBody collides with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#onCollide\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.onCollide = false;\r\n\r\n        /**\r\n         * Whether the simulation emits an `overlap` event when this StaticBody overlaps with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#onOverlap\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.onOverlap = false;\r\n\r\n        /**\r\n         * The StaticBody's inertia, relative to a default unit (1). With `bounce`, this affects the exchange of momentum (velocities) during collisions.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#mass\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.mass = 1;\r\n\r\n        /**\r\n         * Whether this object can be moved by collisions with another body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#immovable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.immovable = true;\r\n\r\n        /**\r\n         * A flag disabling the default horizontal separation of colliding bodies. Pass your own `processHandler` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#customSeparateX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateX = false;\r\n\r\n        /**\r\n         * A flag disabling the default vertical separation of colliding bodies. Pass your own `processHandler` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#customSeparateY\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateY = false;\r\n\r\n        /**\r\n         * The amount of horizontal overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#overlapX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapX = 0;\r\n\r\n        /**\r\n         * The amount of vertical overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#overlapY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapY = 0;\r\n\r\n        /**\r\n         * The amount of overlap (before separation), if this StaticBody is circular and colliding with another circular body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#overlapR\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapR = 0;\r\n\r\n        /**\r\n         * Whether this StaticBody is overlapped with another and both have zero velocity.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#embedded\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.embedded = false;\r\n\r\n        /**\r\n         * Whether this StaticBody interacts with the world boundary.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#collideWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.collideWorldBounds = false;\r\n\r\n        /**\r\n         * Whether this StaticBody is checked for collisions and for which directions. You can set `checkCollision.none = false` to disable collision checks.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#checkCollision\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.checkCollision = { none: false, up: true, down: true, left: true, right: true };\r\n\r\n        /**\r\n         * Whether this StaticBody is colliding with another and in which direction.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#touching\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.touching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * Whether this StaticBody was colliding with another during the last step, and in which direction.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#wasTouching\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.wasTouching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * Whether this StaticBody is colliding with a tile or the world boundary.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#blocked\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.blocked = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * The StaticBody's physics type (static by default).\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#physicsType\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.physicsType = CONST.STATIC_BODY;\r\n\r\n        /**\r\n         * The calculated change in the Body's horizontal position during the current step.\r\n         * For a static body this is always zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#_dx\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.10.0\r\n         */\r\n        this._dx = 0;\r\n\r\n        /**\r\n         * The calculated change in the Body's vertical position during the current step.\r\n         * For a static body this is always zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#_dy\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.10.0\r\n         */\r\n        this._dy = 0;\r\n    },\r\n\r\n    /**\r\n     * Changes the Game Object this Body is bound to.\r\n     * First it removes its reference from the old Game Object, then sets the new one.\r\n     * You can optionally update the position and dimensions of this Body to reflect that of the new Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setGameObject\r\n     * @since 3.1.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The new Game Object that will own this Body.\r\n     * @param {boolean} [update=true] - Reposition and resize this Body to match the new Game Object?\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     *\r\n     * @see Phaser.Physics.Arcade.StaticBody#updateFromGameObject\r\n     */\r\n    setGameObject: function (gameObject, update)\r\n    {\r\n        if (gameObject && gameObject !== this.gameObject)\r\n        {\r\n            //  Remove this body from the old game object\r\n            this.gameObject.body = null;\r\n\r\n            gameObject.body = this;\r\n\r\n            //  Update our reference\r\n            this.gameObject = gameObject;\r\n        }\r\n\r\n        if (update)\r\n        {\r\n            this.updateFromGameObject();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates this Static Body so that its position and dimensions are updated\r\n     * based on the current Game Object it is bound to.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#updateFromGameObject\r\n     * @since 3.1.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    updateFromGameObject: function ()\r\n    {\r\n        this.world.staticTree.remove(this);\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        gameObject.getTopLeft(this.position);\r\n\r\n        this.width = gameObject.displayWidth;\r\n        this.height = gameObject.displayHeight;\r\n\r\n        this.halfWidth = Math.abs(this.width / 2);\r\n        this.halfHeight = Math.abs(this.height / 2);\r\n\r\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\r\n\r\n        this.world.staticTree.insert(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the offset of the body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setOffset\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The horizontal offset of the Body from the Game Object's center.\r\n     * @param {number} y - The vertical offset of the Body from the Game Object's center.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    setOffset: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.world.staticTree.remove(this);\r\n\r\n        this.position.x -= this.offset.x;\r\n        this.position.y -= this.offset.y;\r\n\r\n        this.offset.set(x, y);\r\n\r\n        this.position.x += this.offset.x;\r\n        this.position.y += this.offset.y;\r\n\r\n        this.updateCenter();\r\n\r\n        this.world.staticTree.insert(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of the body.\r\n     * Resets the width and height to match current frame, if no width and height provided and a frame is found.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [width] - The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\r\n     * @param {integer} [height] - The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\r\n     * @param {number} [offsetX] - The horizontal offset of the Body from the Game Object's center.\r\n     * @param {number} [offsetY] - The vertical offset of the Body from the Game Object's center.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    setSize: function (width, height, offsetX, offsetY)\r\n    {\r\n        if (offsetX === undefined) { offsetX = this.offset.x; }\r\n        if (offsetY === undefined) { offsetY = this.offset.y; }\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        if (!width && gameObject.frame)\r\n        {\r\n            width = gameObject.frame.realWidth;\r\n        }\r\n\r\n        if (!height && gameObject.frame)\r\n        {\r\n            height = gameObject.frame.realHeight;\r\n        }\r\n\r\n        this.world.staticTree.remove(this);\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.halfWidth = Math.floor(width / 2);\r\n        this.halfHeight = Math.floor(height / 2);\r\n\r\n        this.offset.set(offsetX, offsetY);\r\n\r\n        this.updateCenter();\r\n\r\n        this.isCircle = false;\r\n        this.radius = 0;\r\n\r\n        this.world.staticTree.insert(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this Static Body to have a circular body and sets its sizes and position.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The radius of the StaticBody, in pixels.\r\n     * @param {number} [offsetX] - The horizontal offset of the StaticBody from its Game Object, in pixels.\r\n     * @param {number} [offsetY] - The vertical offset of the StaticBody from its Game Object, in pixels.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    setCircle: function (radius, offsetX, offsetY)\r\n    {\r\n        if (offsetX === undefined) { offsetX = this.offset.x; }\r\n        if (offsetY === undefined) { offsetY = this.offset.y; }\r\n\r\n        if (radius > 0)\r\n        {\r\n            this.world.staticTree.remove(this);\r\n\r\n            this.isCircle = true;\r\n\r\n            this.radius = radius;\r\n\r\n            this.width = radius * 2;\r\n            this.height = radius * 2;\r\n\r\n            this.halfWidth = Math.floor(this.width / 2);\r\n            this.halfHeight = Math.floor(this.height / 2);\r\n\r\n            this.offset.set(offsetX, offsetY);\r\n\r\n            this.updateCenter();\r\n\r\n            this.world.staticTree.insert(this);\r\n        }\r\n        else\r\n        {\r\n            this.isCircle = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the StaticBody's `center` from its `position` and dimensions.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#updateCenter\r\n     * @since 3.0.0\r\n     */\r\n    updateCenter: function ()\r\n    {\r\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\r\n    },\r\n\r\n    /**\r\n     * Updates this Static Body's position based on the current Game Object it is bound to.\r\n     * Similar to `updateFromGameObject`, but doesn't modify the Body's dimensions.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to reset the body to.\r\n     * @param {number} y - The y coordinate to reset the body to.\r\n     */\r\n    reset: function (x, y)\r\n    {\r\n        var gameObject = this.gameObject;\r\n\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        this.world.staticTree.remove(this);\r\n\r\n        gameObject.getTopLeft(this.position);\r\n\r\n        this.updateCenter();\r\n\r\n        this.world.staticTree.insert(this);\r\n    },\r\n\r\n    /**\r\n     * NOOP function. A Static Body cannot be stopped.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    stop: function ()\r\n    {\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the x and y coordinates of the top left and bottom right points of the StaticBody.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeBodyBounds} obj - The object which will hold the coordinates of the bounds.\r\n     *\r\n     * @return {ArcadeBodyBounds} The same object that was passed with `x`, `y`, `right` and `bottom` values matching the respective values of the StaticBody.\r\n     */\r\n    getBounds: function (obj)\r\n    {\r\n        obj.x = this.x;\r\n        obj.y = this.y;\r\n        obj.right = this.right;\r\n        obj.bottom = this.bottom;\r\n\r\n        return obj;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if a given x,y coordinate is colliding with this Static Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to check against this body.\r\n     * @param {number} y - The y coordinate to check against this body.\r\n     *\r\n     * @return {boolean} `true` if the given coordinate lies within this body, otherwise `false`.\r\n     */\r\n    hitTest: function (x, y)\r\n    {\r\n        return (this.isCircle) ? CircleContains(this, x, y) : RectangleContains(this, x, y);\r\n    },\r\n\r\n    /**\r\n     * NOOP\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#postUpdate\r\n     * @since 3.12.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this StaticBody's horizontal position from the previous step. Always zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} Always zero for a Static Body.\r\n     */\r\n    deltaAbsX: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this StaticBody's vertical position from the previous step. Always zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} Always zero for a Static Body.\r\n     */\r\n    deltaAbsY: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * The change in this StaticBody's horizontal position from the previous step. Always zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} Always zero for a Static Body.\r\n     */\r\n    deltaX: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * The change in this StaticBody's vertical position from the previous step. Always zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} 0\r\n     */\r\n    deltaY: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaZ\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} 0\r\n     */\r\n    deltaZ: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Disables this Body and marks it for destruction during the next step.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.enable = false;\r\n\r\n        this.world.pendingDestroy.set(this);\r\n    },\r\n\r\n    /**\r\n     * Draws a graphical representation of the StaticBody for visual debugging purposes.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#drawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to use for the debug drawing of the StaticBody.\r\n     */\r\n    drawDebug: function (graphic)\r\n    {\r\n        var pos = this.position;\r\n\r\n        if (this.debugShowBody)\r\n        {\r\n            graphic.lineStyle(1, this.debugBodyColor, 1);\r\n            graphic.strokeRect(pos.x, pos.y, this.width, this.height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Indicates whether the StaticBody is going to be showing a debug visualization during postUpdate.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#willDrawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether or not the StaticBody is going to show the debug visualization during postUpdate.\r\n     */\r\n    willDrawDebug: function ()\r\n    {\r\n        return this.debugShowBody;\r\n    },\r\n\r\n    /**\r\n     * Sets the Mass of the StaticBody. Will set the Mass to 0.1 if the value passed is less than or equal to zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value to set the Mass to. Values of zero or less are changed to 0.1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    setMass: function (value)\r\n    {\r\n        if (value <= 0)\r\n        {\r\n            //  Causes havoc otherwise\r\n            value = 0.1;\r\n        }\r\n\r\n        this.mass = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The x coordinate of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.world.staticTree.remove(this);\r\n\r\n            this.position.x = value;\r\n\r\n            this.world.staticTree.insert(this);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y coordinate of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.world.staticTree.remove(this);\r\n\r\n            this.position.y = value;\r\n\r\n            this.world.staticTree.insert(this);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the left-most x coordinate of the area of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#left\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The right-most x coordinate of the area of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#right\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x + this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The highest y coordinate of the area of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#top\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    top: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The lowest y coordinate of the area of the StaticBody. (y + height)\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#bottom\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    bottom: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y + this.height;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = StaticBody;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","CircleContains","Class","CONST","RectangleContains","Vector2","StaticBody","initialize","world","gameObject","width","height","debugShowBody","defaults","debugShowStaticBody","debugBodyColor","staticBodyDebugColor","enable","isCircle","radius","offset","position","x","displayOriginX","y","displayOriginY","halfWidth","Math","abs","halfHeight","center","velocity","ZERO","allowGravity","bounce","gravity","onOverlap","onCollide","onWorldBounds","mass","immovable","customSeparateY","customSeparateX","overlapR","overlapY","overlapX","collideWorldBounds","embedded","checkCollision","none","up","down","left","right","touching","wasTouching","blocked","physicsType","STATIC_BODY","_dy","_dx","setGameObject","update","body","updateFromGameObject","staticTree","remove","getTopLeft","displayWidth","displayHeight","set","insert","setOffset","undefined","updateCenter","setSize","offsetX","offsetY","frame","realWidth","realHeight","floor","setCircle","reset","stop","getBounds","obj","bottom","hitTest","postUpdate","deltaAbsX","deltaAbsY","deltaX","deltaY","deltaZ","destroy","pendingDestroy","drawDebug","graphic","pos","lineStyle","strokeRect","willDrawDebug","setMass","value","get","top"]
}
