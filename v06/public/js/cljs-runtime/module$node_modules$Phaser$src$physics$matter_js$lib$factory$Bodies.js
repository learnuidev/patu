shadow$provide.module$node_modules$Phaser$src$physics$matter_js$lib$factory$Bodies=function(global,require,module,exports){var Bodies={};module.exports=Bodies;var Vertices=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices"),Common=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Common"),Body=require("module$node_modules$Phaser$src$physics$matter_js$lib$body$Body"),Bounds=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Bounds"),
Vector=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vector"),decomp=require("module$node_modules$Phaser$src$physics$matter_js$poly_decomp$index");(function(){Bodies.rectangle=function(x,y,width,height,options){options=options||{};x={label:"Rectangle Body",position:{x:x,y:y},vertices:Vertices.fromPath("L 0 0 L "+width+" 0 L "+width+" "+height+" L 0 "+height)};options.chamfer&&(y=options.chamfer,x.vertices=Vertices.chamfer(x.vertices,y.radius,y.quality,y.qualityMin,y.qualityMax),
delete options.chamfer);return Body.create(Common.extend({},x,options))};Bodies.trapezoid=function(x,y,width,height,slope,options){options=options||{};slope*=.5;var x1=width*slope;width=x1+(1-2*slope)*width;var x3=width+x1;x={label:"Trapezoid Body",position:{x:x,y:y},vertices:Vertices.fromPath(.5>slope?"L 0 0 L "+x1+" "+-height+" L "+width+" "+-height+" L "+x3+" 0":"L 0 0 L "+width+" "+-height+" L "+x3+" 0")};options.chamfer&&(y=options.chamfer,x.vertices=Vertices.chamfer(x.vertices,y.radius,y.quality,
y.qualityMin,y.qualityMax),delete options.chamfer);return Body.create(Common.extend({},x,options))};Bodies.circle=function(x,y,radius,options,maxSides){options=options||{};var circle={label:"Circle Body",circleRadius:radius};maxSides=Math.ceil(Math.max(10,Math.min(maxSides||25,radius)));1===maxSides%2&&(maxSides+=1);return Bodies.polygon(x,y,maxSides,radius,Common.extend({},circle,options))};Bodies.polygon=function(x,y,sides,radius,options){options=options||{};if(3>sides)return Bodies.circle(x,y,
radius,options);for(var theta=2*Math.PI/sides,path="",offset=.5*theta,i=0;i<sides;i+=1){var angle=offset+i*theta,yy=Math.sin(angle)*radius;path+="L "+(Math.cos(angle)*radius).toFixed(3)+" "+yy.toFixed(3)+" "}x={label:"Polygon Body",position:{x:x,y:y},vertices:Vertices.fromPath(path)};options.chamfer&&(y=options.chamfer,x.vertices=Vertices.chamfer(x.vertices,y.radius,y.quality,y.qualityMin,y.qualityMax),delete options.chamfer);return Body.create(Common.extend({},x,options))};Bodies.fromVertices=function(x,
y,vertexSets,options,flagInternal,removeCollinear,minimumArea){var isConvex,v;options=options||{};var parts=[];flagInternal="undefined"!==typeof flagInternal?flagInternal:!1;removeCollinear="undefined"!==typeof removeCollinear?removeCollinear:.01;minimumArea="undefined"!==typeof minimumArea?minimumArea:10;decomp||Common.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.");Common.isArray(vertexSets[0])||(vertexSets=[vertexSets]);for(v=0;v<vertexSets.length;v+=
1){var vertices$jscomp$0=vertexSets[v];if((isConvex=Vertices.isConvex(vertices$jscomp$0))||!decomp)vertices$jscomp$0=isConvex?Vertices.clockwiseSort(vertices$jscomp$0):Vertices.hull(vertices$jscomp$0),parts.push({position:{x:x,y:y},vertices:vertices$jscomp$0});else for(isConvex=vertices$jscomp$0.map(function(vertex){return[vertex.x,vertex.y]}),decomp.makeCCW(isConvex),!1!==removeCollinear&&decomp.removeCollinearPoints(isConvex,removeCollinear),vertices$jscomp$0=decomp.quickDecomp(isConvex),isConvex=
0;isConvex<vertices$jscomp$0.length;isConvex++){var chunkVertices=vertices$jscomp$0[isConvex].map(function(vertices){return{x:vertices[0],y:vertices[1]}});0<minimumArea&&Vertices.area(chunkVertices)<minimumArea||parts.push({position:Vertices.centre(chunkVertices),vertices:chunkVertices})}}for(isConvex=0;isConvex<parts.length;isConvex++)parts[isConvex]=Body.create(Common.extend(parts[isConvex],options));if(flagInternal)for(isConvex=0;isConvex<parts.length;isConvex++)for(minimumArea=parts[isConvex],
vertexSets=isConvex+1;vertexSets<parts.length;vertexSets++)if(v=parts[vertexSets],Bounds.overlaps(minimumArea.bounds,v.bounds))for(vertices$jscomp$0=minimumArea.vertices,chunkVertices=v.vertices,flagInternal=0;flagInternal<minimumArea.vertices.length;flagInternal++)for(removeCollinear=0;removeCollinear<v.vertices.length;removeCollinear++){var da=Vector.magnitudeSquared(Vector.sub(vertices$jscomp$0[(flagInternal+1)%vertices$jscomp$0.length],chunkVertices[removeCollinear])),db=Vector.magnitudeSquared(Vector.sub(vertices$jscomp$0[flagInternal],
chunkVertices[(removeCollinear+1)%chunkVertices.length]));5>da&&5>db&&(vertices$jscomp$0[flagInternal].isInternal=!0,chunkVertices[removeCollinear].isInternal=!0)}return 1<parts.length?(options=Body.create(Common.extend({parts:parts.slice(0)},options)),Body.setPosition(options,{x:x,y:y}),options):parts[0]}})()}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$lib$factory$Bodies.js.map
