{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$lib$core$Sleeping.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/matter-js/lib/core/Sleeping.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$lib$core$Sleeping\"] = function(global,require,module,exports) {\n/**\r\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\r\n*\r\n* @class Sleeping\r\n*/\r\n\r\nvar Sleeping = {};\r\n\r\nmodule.exports = Sleeping;\r\n\r\nvar Events = require('./Events');\r\n\r\n(function() {\r\n\r\n    Sleeping._motionWakeThreshold = 0.18;\r\n    Sleeping._motionSleepThreshold = 0.08;\r\n    Sleeping._minBias = 0.9;\r\n\r\n    /**\r\n     * Puts bodies to sleep or wakes them up depending on their motion.\r\n     * @method update\r\n     * @param {body[]} bodies\r\n     * @param {number} timeScale\r\n     */\r\n    Sleeping.update = function(bodies, timeScale) {\r\n        var timeFactor = timeScale * timeScale * timeScale;\r\n\r\n        // update bodies sleeping status\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;\r\n\r\n            // wake up bodies if they have a force applied\r\n            if (body.force.x !== 0 || body.force.y !== 0) {\r\n                Sleeping.set(body, false);\r\n                continue;\r\n            }\r\n\r\n            var minMotion = Math.min(body.motion, motion),\r\n                maxMotion = Math.max(body.motion, motion);\r\n        \r\n            // biased average motion estimation between frames\r\n            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\r\n            \r\n            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {\r\n                body.sleepCounter += 1;\r\n                \r\n                if (body.sleepCounter >= body.sleepThreshold)\r\n                    Sleeping.set(body, true);\r\n            } else if (body.sleepCounter > 0) {\r\n                body.sleepCounter -= 1;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\r\n     * @method afterCollisions\r\n     * @param {pair[]} pairs\r\n     * @param {number} timeScale\r\n     */\r\n    Sleeping.afterCollisions = function(pairs, timeScale) {\r\n        var timeFactor = timeScale * timeScale * timeScale;\r\n\r\n        // wake up bodies involved in collisions\r\n        for (var i = 0; i < pairs.length; i++) {\r\n            var pair = pairs[i];\r\n            \r\n            // don't wake inactive pairs\r\n            if (!pair.isActive)\r\n                continue;\r\n\r\n            var collision = pair.collision,\r\n                bodyA = collision.bodyA.parent, \r\n                bodyB = collision.bodyB.parent;\r\n        \r\n            // don't wake if at least one body is static\r\n            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)\r\n                continue;\r\n        \r\n            if (bodyA.isSleeping || bodyB.isSleeping) {\r\n                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,\r\n                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;\r\n\r\n                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {\r\n                    Sleeping.set(sleepingBody, false);\r\n                }\r\n            }\r\n        }\r\n    };\r\n  \r\n    /**\r\n     * Set a body as sleeping or awake.\r\n     * @method set\r\n     * @param {body} body\r\n     * @param {boolean} isSleeping\r\n     */\r\n    Sleeping.set = function(body, isSleeping) {\r\n        var wasSleeping = body.isSleeping;\r\n\r\n        if (isSleeping) {\r\n            body.isSleeping = true;\r\n            body.sleepCounter = body.sleepThreshold;\r\n\r\n            body.positionImpulse.x = 0;\r\n            body.positionImpulse.y = 0;\r\n\r\n            body.positionPrev.x = body.position.x;\r\n            body.positionPrev.y = body.position.y;\r\n\r\n            body.anglePrev = body.angle;\r\n            body.speed = 0;\r\n            body.angularSpeed = 0;\r\n            body.motion = 0;\r\n\r\n            if (!wasSleeping) {\r\n                Events.trigger(body, 'sleepStart');\r\n            }\r\n        } else {\r\n            body.isSleeping = false;\r\n            body.sleepCounter = 0;\r\n\r\n            if (wasSleeping) {\r\n                Events.trigger(body, 'sleepEnd');\r\n            }\r\n        }\r\n    };\r\n\r\n})();\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Sleeping","Events","_motionWakeThreshold","_motionSleepThreshold","_minBias","update","Sleeping.update","bodies","timeScale","timeFactor","i","length","body","motion","speed","angularSpeed","force","x","y","set","Math","min","minMotion","max","maxMotion","sleepThreshold","sleepCounter","afterCollisions","Sleeping.afterCollisions","pairs","pair","isActive","collision","bodyA","parent","bodyB","isSleeping","isStatic","sleepingBody","movingBody","Sleeping.set","wasSleeping","positionImpulse","positionPrev","position","anglePrev","angle","trigger"]
}
