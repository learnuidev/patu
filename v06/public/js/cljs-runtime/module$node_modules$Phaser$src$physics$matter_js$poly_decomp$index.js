shadow$provide.module$node_modules$Phaser$src$physics$matter_js$poly_decomp$index=function(global,require,module,exports){function lineSegmentsIntersect(p1,p2,q1,q2){var dx=p2[0]-p1[0];p2=p2[1]-p1[1];var da=q2[0]-q1[0],db=q2[1]-q1[1];if(0===da*p2-db*dx)return!1;q2=(dx*(q1[1]-p1[1])+p2*(p1[0]-q1[0]))/(da*p2-db*dx);p1=(da*(p1[1]-q1[1])+db*(q1[0]-p1[0]))/(db*dx-da*p2);return 0<=q2&&1>=q2&&0<=p1&&1>=p1}function triangleArea(a,b,c){return(b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])}function isLeft(a,
b,c){return 0<triangleArea(a,b,c)}function isLeftOn(a,b,c){return 0<=triangleArea(a,b,c)}function isRightOn(a,b,c){return 0>=triangleArea(a,b,c)}function sqdist(a,b){var dx=b[0]-a[0];a=b[1]-a[1];return dx*dx+a*a}function polygonAt(polygon,i){var s=polygon.length;return polygon[0>i?i%s+s:i%s]}function polygonAppend(polygon,poly,from,to){for(;from<to;from++)polygon.push(poly[from])}function polygonIsReflex(polygon,i){var a=polygonAt(polygon,i-1),b=polygonAt(polygon,i);polygon=polygonAt(polygon,i+1);
return 0>triangleArea(a,b,polygon)}function polygonCopy(polygon,i,j,targetPoly){targetPoly=targetPoly||[];targetPoly.length=0;if(i<j)for(var k=i;k<=j;k++)targetPoly.push(polygon[k]);else{for(k=0;k<=j;k++)targetPoly.push(polygon[k]);for(k=i;k<polygon.length;k++)targetPoly.push(polygon[k])}return targetPoly}function polygonGetCutEdges(polygon){for(var min=[],tmp1,tmp2,tmpPoly=[],nDiags=Number.MAX_VALUE,i=0;i<polygon.length;++i)if(polygonIsReflex(polygon,i))for(var j=0;j<polygon.length;++j){a:{tmp2=
polygon;var a=i,b=j,l1=tmpLine1,l2=tmpLine2;if(isLeftOn(polygonAt(tmp2,a+1),polygonAt(tmp2,a),polygonAt(tmp2,b))&&isRightOn(polygonAt(tmp2,a-1),polygonAt(tmp2,a),polygonAt(tmp2,b)))tmp1=!1;else{tmp1=sqdist(polygonAt(tmp2,a),polygonAt(tmp2,b));for(var i$jscomp$0=0;i$jscomp$0!==tmp2.length;++i$jscomp$0)if((i$jscomp$0+1)%tmp2.length!==a&&i$jscomp$0!==a&&isLeftOn(polygonAt(tmp2,a),polygonAt(tmp2,b),polygonAt(tmp2,i$jscomp$0+1))&&isRightOn(polygonAt(tmp2,a),polygonAt(tmp2,b),polygonAt(tmp2,i$jscomp$0))){l1[0]=
polygonAt(tmp2,a);l1[1]=polygonAt(tmp2,b);l2[0]=polygonAt(tmp2,i$jscomp$0);l2[1]=polygonAt(tmp2,i$jscomp$0+1);var i$jscomp$1=[0,0];var a1=l1[1][1]-l1[0][1];var b1=l1[0][0]-l1[1][0];var c1=a1*l1[0][0]+b1*l1[0][1];var a2=l2[1][1]-l2[0][1];var b2=l2[0][0]-l2[1][0];var c2=a2*l2[0][0]+b2*l2[0][1];var p=a1*b2-a2*b1;0>=Math.abs(p-0)||(i$jscomp$1[0]=(b2*c1-b1*c2)/p,i$jscomp$1[1]=(a1*c2-a2*c1)/p);p=i$jscomp$1;if(sqdist(polygonAt(tmp2,a),p)<tmp1){tmp1=!1;break a}}tmp1=!0}}if(tmp1){tmp1=polygonGetCutEdges(polygonCopy(polygon,
i,j,tmpPoly));tmp2=polygonGetCutEdges(polygonCopy(polygon,j,i,tmpPoly));for(a=0;a<tmp2.length;a++)tmp1.push(tmp2[a]);tmp1.length<nDiags&&(min=tmp1,nDiags=tmp1.length,min.push([polygonAt(polygon,i),polygonAt(polygon,j)]))}}return min}function polygonSlice(polygon,cutEdges){if(0===cutEdges.length)return[polygon];if(cutEdges instanceof Array&&cutEdges.length&&cutEdges[0]instanceof Array&&2===cutEdges[0].length&&cutEdges[0][0]instanceof Array){polygon=[polygon];for(var i=0;i<cutEdges.length;i++)for(var cutEdge=
cutEdges[i],j=0;j<polygon.length;j++){var result=polygonSlice(polygon[j],cutEdge);if(result){polygon.splice(j,1);polygon.push(result[0],result[1]);break}}return polygon}cutEdge=cutEdges;i=polygon.indexOf(cutEdge[0]);j=polygon.indexOf(cutEdge[1]);return-1!==i&&-1!==j?[polygonCopy(polygon,i,j),polygonCopy(polygon,j,i)]:!1}function getIntersectionPoint(p1,p2,q1,q2,delta){var a1=p2[1]-p1[1];p2=p1[0]-p2[0];p1=a1*p1[0]+p2*p1[1];var a2=q2[1]-q1[1];q2=q1[0]-q2[0];q1=a2*q1[0]+q2*q1[1];var det=a1*q2-a2*p2;
return Math.abs(det-0)<=(delta||0)?[0,0]:[(q2*p1-p2*q1)/det,(a1*q1-a2*p1)/det]}function polygonQuickDecomp(polygon,result,reflexVertices,steinerPoints,delta,maxlevel,level){maxlevel=maxlevel||100;level=level||0;delta=delta||25;result="undefined"!==typeof result?result:[];reflexVertices=reflexVertices||[];steinerPoints=steinerPoints||[];var upperInt=[0,0],lowerInt=[0,0],p=[0,0],lowerDist,upperIndex=0,lowerIndex=0,closestIndex=0,lowerPoly=[],upperPoly=[];if(3>polygon.length)return result;level++;if(level>
maxlevel)return console.warn("quickDecomp: max level ("+maxlevel+") reached."),result;for(var i=0;i<polygon.length;++i)if(polygonIsReflex(polygon,i)){reflexVertices.push(polygon[i]);var upperDist=lowerDist=Number.MAX_VALUE;for(var j=0;j<polygon.length;++j){if(isLeft(polygonAt(polygon,i-1),polygonAt(polygon,i),polygonAt(polygon,j))&&isRightOn(polygonAt(polygon,i-1),polygonAt(polygon,i),polygonAt(polygon,j-1))){p=getIntersectionPoint(polygonAt(polygon,i-1),polygonAt(polygon,i),polygonAt(polygon,j),
polygonAt(polygon,j-1));var d=polygonAt(polygon,i+1);var b=polygonAt(polygon,i);0>triangleArea(d,b,p)&&(d=sqdist(polygon[i],p),d<lowerDist&&(lowerDist=d,lowerInt=p,lowerIndex=j))}isLeft(polygonAt(polygon,i+1),polygonAt(polygon,i),polygonAt(polygon,j+1))&&isRightOn(polygonAt(polygon,i+1),polygonAt(polygon,i),polygonAt(polygon,j))&&(p=getIntersectionPoint(polygonAt(polygon,i+1),polygonAt(polygon,i),polygonAt(polygon,j),polygonAt(polygon,j+1)),isLeft(polygonAt(polygon,i-1),polygonAt(polygon,i),p)&&(d=
sqdist(polygon[i],p),d<upperDist&&(upperDist=d,upperInt=p,upperIndex=j)))}if(lowerIndex===(upperIndex+1)%polygon.length)p[0]=(lowerInt[0]+upperInt[0])/2,p[1]=(lowerInt[1]+upperInt[1])/2,steinerPoints.push(p),i<upperIndex?(polygonAppend(lowerPoly,polygon,i,upperIndex+1),lowerPoly.push(p),upperPoly.push(p),0!==lowerIndex&&polygonAppend(upperPoly,polygon,lowerIndex,polygon.length),polygonAppend(upperPoly,polygon,0,i+1)):(0!==i&&polygonAppend(lowerPoly,polygon,i,polygon.length),polygonAppend(lowerPoly,
polygon,0,upperIndex+1),lowerPoly.push(p),upperPoly.push(p),polygonAppend(upperPoly,polygon,lowerIndex,i+1));else{lowerIndex>upperIndex&&(upperIndex+=polygon.length);upperInt=Number.MAX_VALUE;if(upperIndex<lowerIndex)return result;for(j=lowerIndex;j<=upperIndex;++j)if(isLeftOn(polygonAt(polygon,i-1),polygonAt(polygon,i),polygonAt(polygon,j))&&isRightOn(polygonAt(polygon,i+1),polygonAt(polygon,i),polygonAt(polygon,j))){d=sqdist(polygonAt(polygon,i),polygonAt(polygon,j));if(lowerIndex=d<upperInt)a:{lowerIndex=
polygon;lowerInt=i;p=j;for(upperDist=0;upperDist!==lowerIndex.length;++upperDist)if(upperDist!==lowerInt&&upperDist!==p&&(upperDist+1)%lowerIndex.length!==lowerInt&&(upperDist+1)%lowerIndex.length!==p&&lineSegmentsIntersect(polygonAt(lowerIndex,lowerInt),polygonAt(lowerIndex,p),polygonAt(lowerIndex,upperDist),polygonAt(lowerIndex,upperDist+1))){lowerIndex=!1;break a}lowerIndex=!0}lowerIndex&&(upperInt=d,closestIndex=j%polygon.length)}i<closestIndex?(polygonAppend(lowerPoly,polygon,i,closestIndex+
1),0!==closestIndex&&polygonAppend(upperPoly,polygon,closestIndex,polygon.length),polygonAppend(upperPoly,polygon,0,i+1)):(0!==i&&polygonAppend(lowerPoly,polygon,i,polygon.length),polygonAppend(lowerPoly,polygon,0,closestIndex+1),polygonAppend(upperPoly,polygon,closestIndex,i+1))}lowerPoly.length<upperPoly.length?(polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level),polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level)):(polygonQuickDecomp(upperPoly,
result,reflexVertices,steinerPoints,delta,maxlevel,level),polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level));return result}result.push(polygon);return result}module.exports={decomp:function(polygon){var edges=polygonGetCutEdges(polygon);return 0<edges.length?polygonSlice(polygon,edges):[polygon]},quickDecomp:polygonQuickDecomp,isSimple:function(polygon){var i;for(i=0;i<polygon.length-1;i++)for(var j=0;j<i-1;j++)if(lineSegmentsIntersect(polygon[i],polygon[i+1],
polygon[j],polygon[j+1]))return!1;for(i=1;i<polygon.length-2;i++)if(lineSegmentsIntersect(polygon[0],polygon[polygon.length-1],polygon[i],polygon[i+1]))return!1;return!0},removeCollinearPoints:function(polygon,precision){for(var num=0,i=polygon.length-1;3<polygon.length&&0<=i;--i){var JSCompiler_inline_result=polygonAt(polygon,i-1);var b=polygonAt(polygon,i),c=polygonAt(polygon,i+1),thresholdAngle=precision;if(thresholdAngle){var ab=tmpPoint1,bc=tmpPoint2;ab[0]=b[0]-JSCompiler_inline_result[0];ab[1]=
b[1]-JSCompiler_inline_result[1];bc[0]=c[0]-b[0];bc[1]=c[1]-b[1];JSCompiler_inline_result=Math.acos((ab[0]*bc[0]+ab[1]*bc[1])/(Math.sqrt(ab[0]*ab[0]+ab[1]*ab[1])*Math.sqrt(bc[0]*bc[0]+bc[1]*bc[1])))<thresholdAngle}else JSCompiler_inline_result=0===triangleArea(JSCompiler_inline_result,b,c);JSCompiler_inline_result&&(polygon.splice(i%polygon.length,1),num++)}return num},removeDuplicatePoints:function(polygon,precision$jscomp$0){for(var i=polygon.length-1;1<=i;--i)for(var pi=polygon[i],j=i-1;0<=j;--j){var a=
pi,b=polygon[j],precision=precision$jscomp$0;Math.abs(a[0]-b[0])<=(precision||0)&&Math.abs(a[1]-b[1])<=(precision||0)&&polygon.splice(i,1)}},makeCCW:function(polygon){for(var br=0,i=1;i<polygon.length;++i)if(polygon[i][1]<polygon[br][1]||polygon[i][1]===polygon[br][1]&&polygon[i][0]>polygon[br][0])br=i;if(isLeft(polygonAt(polygon,br-1),polygonAt(polygon,br),polygonAt(polygon,br+1)))return!1;br=[];i=polygon.length;for(var i$jscomp$0=0;i$jscomp$0!==i;i$jscomp$0++)br.push(polygon.pop());for(i$jscomp$0=
0;i$jscomp$0!==i;i$jscomp$0++)polygon[i$jscomp$0]=br[i$jscomp$0];return!0}};var tmpPoint1=[],tmpPoint2=[],tmpLine1=[],tmpLine2=[]}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$poly_decomp$index.js.map
