shadow$provide.module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Svg=function(global,require,module,exports){var Svg={};module.exports=Svg;require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Bounds");var Common=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Common");(function(){Svg.pathToVertices=function(path,sampleLength){"undefined"===typeof window||"SVGPathSeg"in window||Common.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
var i,segmentsQueue,lastPoint,points=[],lx,ly,length=0,x=0,y=0;sampleLength=sampleLength||15;var addPoint=function(px,py,pathSegType){pathSegType=1===pathSegType%2&&1<pathSegType;if(!lastPoint||px!=lastPoint.x||py!=lastPoint.y){lastPoint&&pathSegType?(lx=lastPoint.x,ly=lastPoint.y):ly=lx=0;var point={x:lx+px,y:ly+py};if(pathSegType||!lastPoint)lastPoint=point;points.push(point);x=lx+px;y=ly+py}},addSegmentPoint=function(segment){var segType=segment.pathSegTypeAsLetter.toUpperCase();if("Z"!==segType){switch(segType){case "M":case "L":case "T":case "C":case "S":case "Q":x=
segment.x;y=segment.y;break;case "H":x=segment.x;break;case "V":y=segment.y}addPoint(x,y,segment.pathSegType)}};Svg._svgPathToAbsolute(path);var total=path.getTotalLength();var segments=[];for(i=0;i<path.pathSegList.numberOfItems;i+=1)segments.push(path.pathSegList.getItem(i));for(segmentsQueue=segments.concat();length<total;){i=path.getPathSegAtLength(length);i=segments[i];if(i!=lastSegment){for(;segmentsQueue.length&&segmentsQueue[0]!=i;)addSegmentPoint(segmentsQueue.shift());var lastSegment=i}switch(i.pathSegTypeAsLetter.toUpperCase()){case "C":case "T":case "S":case "Q":case "A":i=
path.getPointAtLength(length),addPoint(i.x,i.y,0)}length+=sampleLength}i=0;for(path=segmentsQueue.length;i<path;++i)addSegmentPoint(segmentsQueue[i]);return points};Svg._svgPathToAbsolute=function(path){for(var x0,y0,x1,y1,x2,y2,segs=path.pathSegList,x=0,y=0,len=segs.numberOfItems,i=0;i<len;++i){var seg=segs.getItem(i),segType=seg.pathSegTypeAsLetter;if(/[MLHVCSQTA]/.test(segType))"x"in seg&&(x=seg.x),"y"in seg&&(y=seg.y);else switch("x1"in seg&&(x1=x+seg.x1),"x2"in seg&&(x2=x+seg.x2),"y1"in seg&&
(y1=y+seg.y1),"y2"in seg&&(y2=y+seg.y2),"x"in seg&&(x+=seg.x),"y"in seg&&(y+=seg.y),segType){case "m":segs.replaceItem(path.createSVGPathSegMovetoAbs(x,y),i);break;case "l":segs.replaceItem(path.createSVGPathSegLinetoAbs(x,y),i);break;case "h":segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x),i);break;case "v":segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y),i);break;case "c":segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x,y,x1,y1,x2,y2),i);break;case "s":segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x,
y,x2,y2),i);break;case "q":segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x,y,x1,y1),i);break;case "t":segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x,y),i);break;case "a":segs.replaceItem(path.createSVGPathSegArcAbs(x,y,seg.r1,seg.r2,seg.angle,seg.largeArcFlag,seg.sweepFlag),i);break;case "z":case "Z":x=x0,y=y0}if("M"==segType||"m"==segType)x0=x,y0=y}}})()}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Svg.js.map
