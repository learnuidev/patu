{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Bounds.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/matter-js/lib/geometry/Bounds.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Bounds\"] = function(global,require,module,exports) {\n/**\r\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\r\n*\r\n* @class Bounds\r\n*/\r\n\r\nvar Bounds = {};\r\n\r\nmodule.exports = Bounds;\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\r\n     * @method create\r\n     * @param {vertices} vertices\r\n     * @return {bounds} A new bounds object\r\n     */\r\n    Bounds.create = function(vertices) {\r\n        var bounds = { \r\n            min: { x: 0, y: 0 }, \r\n            max: { x: 0, y: 0 }\r\n        };\r\n\r\n        if (vertices)\r\n            Bounds.update(bounds, vertices);\r\n        \r\n        return bounds;\r\n    };\r\n\r\n    /**\r\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\r\n     * @method update\r\n     * @param {bounds} bounds\r\n     * @param {vertices} vertices\r\n     * @param {vector} velocity\r\n     */\r\n    Bounds.update = function(bounds, vertices, velocity) {\r\n        bounds.min.x = Infinity;\r\n        bounds.max.x = -Infinity;\r\n        bounds.min.y = Infinity;\r\n        bounds.max.y = -Infinity;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var vertex = vertices[i];\r\n            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\r\n            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\r\n            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\r\n            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\r\n        }\r\n        \r\n        if (velocity) {\r\n            if (velocity.x > 0) {\r\n                bounds.max.x += velocity.x;\r\n            } else {\r\n                bounds.min.x += velocity.x;\r\n            }\r\n            \r\n            if (velocity.y > 0) {\r\n                bounds.max.y += velocity.y;\r\n            } else {\r\n                bounds.min.y += velocity.y;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns true if the bounds contains the given point.\r\n     * @method contains\r\n     * @param {bounds} bounds\r\n     * @param {vector} point\r\n     * @return {boolean} True if the bounds contain the point, otherwise false\r\n     */\r\n    Bounds.contains = function(bounds, point) {\r\n        return point.x >= bounds.min.x && point.x <= bounds.max.x \r\n               && point.y >= bounds.min.y && point.y <= bounds.max.y;\r\n    };\r\n\r\n    /**\r\n     * Returns true if the two bounds intersect.\r\n     * @method overlaps\r\n     * @param {bounds} boundsA\r\n     * @param {bounds} boundsB\r\n     * @return {boolean} True if the bounds overlap, otherwise false\r\n     */\r\n    Bounds.overlaps = function(boundsA, boundsB) {\r\n        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x\r\n                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);\r\n    };\r\n\r\n    /**\r\n     * Translates the bounds by the given vector.\r\n     * @method translate\r\n     * @param {bounds} bounds\r\n     * @param {vector} vector\r\n     */\r\n    Bounds.translate = function(bounds, vector) {\r\n        bounds.min.x += vector.x;\r\n        bounds.max.x += vector.x;\r\n        bounds.min.y += vector.y;\r\n        bounds.max.y += vector.y;\r\n    };\r\n\r\n    /**\r\n     * Shifts the bounds to the given position.\r\n     * @method shift\r\n     * @param {bounds} bounds\r\n     * @param {vector} position\r\n     */\r\n    Bounds.shift = function(bounds, position) {\r\n        var deltaX = bounds.max.x - bounds.min.x,\r\n            deltaY = bounds.max.y - bounds.min.y;\r\n            \r\n        bounds.min.x = position.x;\r\n        bounds.max.x = position.x + deltaX;\r\n        bounds.min.y = position.y;\r\n        bounds.max.y = position.y + deltaY;\r\n    };\r\n    \r\n})();\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Bounds","create","Bounds.create","vertices","bounds","min","x","y","max","update","Bounds.update","velocity","Infinity","i","length","vertex","contains","Bounds.contains","point","overlaps","Bounds.overlaps","boundsA","boundsB","translate","Bounds.translate","vector","shift","Bounds.shift","position","deltaX","deltaY"]
}
