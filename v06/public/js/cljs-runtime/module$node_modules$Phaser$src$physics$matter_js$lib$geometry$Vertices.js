shadow$provide.module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices=function(global,require,module,exports){var Vertices={};module.exports=Vertices;var Vector=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vector"),Common=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Common");(function(){Vertices.create=function(points,body){for(var vertices=[],i=0;i<points.length;i++){var point=points[i];point={x:point.x,y:point.y,index:i,body:body,isInternal:!1,
contact:null};point.contact={vertex:point,normalImpulse:0,tangentImpulse:0};vertices.push(point)}return vertices};Vertices.fromPath=function(path,body){var points=[];path.replace(/L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/ig,function(match,x,y){points.push({x:parseFloat(x),y:parseFloat(y)})});return Vertices.create(points,body)};Vertices.centre=function(vertices){for(var area=Vertices.area(vertices,!0),centre={x:0,y:0},cross,j,i=0;i<vertices.length;i++)j=(i+1)%vertices.length,cross=Vector.cross(vertices[i],
vertices[j]),cross=Vector.mult(Vector.add(vertices[i],vertices[j]),cross),centre=Vector.add(centre,cross);return Vector.div(centre,6*area)};Vertices.mean=function(vertices){for(var average={x:0,y:0},i=0;i<vertices.length;i++)average.x+=vertices[i].x,average.y+=vertices[i].y;return Vector.div(average,vertices.length)};Vertices.area=function(vertices,signed){for(var area=0,j=vertices.length-1,i=0;i<vertices.length;i++)area+=(vertices[j].x-vertices[i].x)*(vertices[j].y+vertices[i].y),j=i;return signed?
area/2:Math.abs(area)/2};Vertices.inertia=function(vertices,mass){for(var numerator=0,denominator=0,cross,j,n=0;n<vertices.length;n++)j=(n+1)%vertices.length,cross=Math.abs(Vector.cross(vertices[j],vertices[n])),numerator+=cross*(Vector.dot(vertices[j],vertices[j])+Vector.dot(vertices[j],vertices[n])+Vector.dot(vertices[n],vertices[n])),denominator+=cross;return mass/6*(numerator/denominator)};Vertices.translate=function(vertices,vector,scalar){var i;if(scalar)for(i=0;i<vertices.length;i++)vertices[i].x+=
vector.x*scalar,vertices[i].y+=vector.y*scalar;else for(i=0;i<vertices.length;i++)vertices[i].x+=vector.x,vertices[i].y+=vector.y;return vertices};Vertices.rotate=function(vertices,angle,point){if(0!==angle){var cos=Math.cos(angle);angle=Math.sin(angle);for(var i=0;i<vertices.length;i++){var vertice=vertices[i],dx=vertice.x-point.x,dy=vertice.y-point.y;vertice.x=point.x+(dx*cos-dy*angle);vertice.y=point.y+(dx*angle+dy*cos)}return vertices}};Vertices.contains=function(vertices,point){for(var i=0;i<
vertices.length;i++){var vertice=vertices[i],nextVertice=vertices[(i+1)%vertices.length];if(0<(point.x-vertice.x)*(nextVertice.y-vertice.y)+(point.y-vertice.y)*(vertice.x-nextVertice.x))return!1}return!0};Vertices.scale=function(vertices,scaleX,scaleY,point){if(1===scaleX&&1===scaleY)return vertices;point=point||Vertices.centre(vertices);for(var vertex,i=0;i<vertices.length;i++)vertex=vertices[i],vertex=Vector.sub(vertex,point),vertices[i].x=point.x+vertex.x*scaleX,vertices[i].y=point.y+vertex.y*
scaleY;return vertices};Vertices.chamfer=function(vertices,radius,quality,qualityMin,qualityMax){radius="number"===typeof radius?[radius]:radius||[8];quality="undefined"!==typeof quality?quality:-1;qualityMin=qualityMin||2;qualityMax=qualityMax||14;for(var newVertices=[],i=0;i<vertices.length;i++){var prevVertex=vertices[0<=i-1?i-1:vertices.length-1],vertex=vertices[i],nextVertex=vertices[(i+1)%vertices.length],currentRadius=radius[i<radius.length?i:radius.length-1];if(0===currentRadius)newVertices.push(vertex);
else{prevVertex=Vector.normalise({x:vertex.y-prevVertex.y,y:prevVertex.x-vertex.x});var nextNormal=Vector.normalise({x:nextVertex.y-vertex.y,y:vertex.x-nextVertex.x}),diagonalRadius=Math.sqrt(2*Math.pow(currentRadius,2));nextVertex=Vector.mult(Common.clone(prevVertex),currentRadius);var midNormal=Vector.normalise(Vector.mult(Vector.add(prevVertex,nextNormal),.5));vertex=Vector.sub(vertex,Vector.mult(midNormal,diagonalRadius));diagonalRadius=quality;-1===quality&&(diagonalRadius=1.75*Math.pow(currentRadius,
.32));diagonalRadius=Common.clamp(diagonalRadius,qualityMin,qualityMax);1===diagonalRadius%2&&(diagonalRadius+=1);currentRadius=Math.acos(Vector.dot(prevVertex,nextNormal))/diagonalRadius;for(prevVertex=0;prevVertex<diagonalRadius;prevVertex++)newVertices.push(Vector.add(Vector.rotate(nextVertex,currentRadius*prevVertex),vertex))}}return newVertices};Vertices.clockwiseSort=function(vertices){var centre=Vertices.mean(vertices);vertices.sort(function(vertexA,vertexB){return Vector.angle(centre,vertexA)-
Vector.angle(centre,vertexB)});return vertices};Vertices.isConvex=function(vertices){var flag=0,n=vertices.length,i;if(3>n)return null;for(i=0;i<n;i++){var j=(i+1)%n;var k=(i+2)%n;var z=(vertices[j].x-vertices[i].x)*(vertices[k].y-vertices[j].y);z-=(vertices[j].y-vertices[i].y)*(vertices[k].x-vertices[j].x);0>z?flag|=1:0<z&&(flag|=2);if(3===flag)return!1}return 0!==flag?!0:null};Vertices.hull=function(vertices){var upper=[],lower=[],vertex,i;vertices=vertices.slice(0);vertices.sort(function(vertexA,
vertexB){var dx=vertexA.x-vertexB.x;return 0!==dx?dx:vertexA.y-vertexB.y});for(i=0;i<vertices.length;i+=1){for(vertex=vertices[i];2<=lower.length&&0>=Vector.cross3(lower[lower.length-2],lower[lower.length-1],vertex);)lower.pop();lower.push(vertex)}for(i=vertices.length-1;0<=i;--i){for(vertex=vertices[i];2<=upper.length&&0>=Vector.cross3(upper[upper.length-2],upper[upper.length-1],vertex);)upper.pop();upper.push(vertex)}upper.pop();lower.pop();return upper.concat(lower)}})()}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices.js.map
