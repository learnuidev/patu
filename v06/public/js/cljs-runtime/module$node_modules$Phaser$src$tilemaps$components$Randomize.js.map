{
"version":3,
"file":"module$node_modules$Phaser$src$tilemaps$components$Randomize.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,6DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAOzH,IAAIC,eAAiBH,OAAA,CAAQ,mEAAR,CAArB,CACII,UAAYJ,OAAA,CAAQ,sDAAR,CA4ChBC,OAAAC,QAAA,CAxBgBG,QAAS,CAACC,KAAD,CAAQC,KAAR,CAAeC,KAAf,CAAsBC,MAAtB,CAA8BC,OAA9B,CAAuCC,KAAvC,CACzB,CAEQC,KAAAA,CAAQT,cAAA,CAAeG,KAAf,CAAsBC,KAAtB,CAA6BC,KAA7B,CAAoCC,MAApC,CAA4C,IAA5C,CAAkDE,KAAlD,CAGZ,IAAgBE,IAAAA,EAAhB,GAAIH,OAAJ,CAGI,IADAA,OACK,CADK,EACL,CAAAI,KAAA,CAAI,CAAT,CAAYA,KAAZ,CAAgBF,KAAAG,OAAhB,CAA8BD,KAAA,EAA9B,CAE4C,EAAxC,GAAIJ,OAAAM,QAAA,CAAgBJ,KAAA,CAAME,KAAN,CAAAG,MAAhB,CAAJ;AAEIP,OAAAQ,KAAA,CAAaN,KAAA,CAAME,KAAN,CAAAG,MAAb,CAKZ,KAAKH,KAAL,CAAS,CAAT,CAAYA,KAAZ,CAAgBF,KAAAG,OAAhB,CAA8BD,KAAA,EAA9B,CAEIF,KAAA,CAAME,KAAN,CAAAG,MAAA,CAAiBb,SAAA,CAAUM,OAAV,CAnBzB,CA7ByH;",
"sources":["node_modules/Phaser/src/tilemaps/components/Randomize.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$tilemaps$components$Randomize\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar GetRandom = require('../../utils/array/GetRandom');\r\n\r\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n * indexes. This method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Randomize\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Randomize = function (tileX, tileY, width, height, indexes, layer)\r\n{\r\n    var i;\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    // If no indicies are given, then find all the unique indexes within the specified region\r\n    if (indexes === undefined)\r\n    {\r\n        indexes = [];\r\n        for (i = 0; i < tiles.length; i++)\r\n        {\r\n            if (indexes.indexOf(tiles[i].index) === -1)\r\n            {\r\n                indexes.push(tiles[i].index);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = GetRandom(indexes);\r\n    }\r\n};\r\n\r\nmodule.exports = Randomize;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","GetTilesWithin","GetRandom","Randomize","tileX","tileY","width","height","indexes","layer","tiles","undefined","i","length","indexOf","index","push"]
}
