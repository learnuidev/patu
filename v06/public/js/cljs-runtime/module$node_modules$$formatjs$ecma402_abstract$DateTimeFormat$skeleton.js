shadow$provide.module$node_modules$$formatjs$ecma402_abstract$DateTimeFormat$skeleton=function(global,require,module,exports){function matchSkeletonPattern(match,result){var len=match.length;switch(match[0]){case "G":return result.era=4===len?"long":5===len?"narrow":"short","{era}";case "y":case "Y":case "u":case "U":case "r":return result.year=2===len?"2-digit":"numeric","{year}";case "q":case "Q":throw new RangeError("`w/Q` (quarter) patterns are not supported");case "M":case "L":return result.month=
["numeric","2-digit","short","long","narrow"][len-1],"{month}";case "w":case "W":throw new RangeError("`w/W` (week of year) patterns are not supported");case "d":return result.day=["numeric","2-digit"][len-1],"{day}";case "D":case "F":case "g":return result.day="numeric","{day}";case "E":return result.weekday=4===len?"long":5===len?"narrow":"short","{weekday}";case "e":return result.weekday="numeric 2-digit short long narrow short".split(" ")[len-1],"{weekday}";case "c":return result.weekday=["numeric",
void 0,"short","long","narrow","short"][len-1],"{weekday}";case "a":case "b":case "B":return result.hour12=!0,"{ampm}";case "h":return result.hour=["numeric","2-digit"][len-1],result.hour12=!0,"{hour}";case "H":return result.hour=["numeric","2-digit"][len-1],"{hour}";case "K":return result.hour=["numeric","2-digit"][len-1],result.hour12=!0,"{hour}";case "k":return result.hour=["numeric","2-digit"][len-1],"{hour}";case "j":case "J":case "C":throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
case "m":return result.minute=["numeric","2-digit"][len-1],"{minute}";case "s":return result.second=["numeric","2-digit"][len-1],"{second}";case "S":case "A":return result.second="numeric","{second}";case "z":case "Z":case "O":case "v":case "V":case "X":case "x":return result.timeZoneName=4>len?"short":"long","{timeZoneName}"}return""}function skeletonTokenToTable2(c){switch(c){case "G":return"era";case "y":case "Y":case "u":case "U":case "r":return"year";case "M":case "L":return"month";case "d":case "D":case "F":case "g":return"day";
case "a":case "b":case "B":return"ampm";case "h":case "H":case "K":case "k":return"hour";case "m":return"minute";case "s":case "S":case "A":return"second";default:throw new RangeError("Invalid range pattern token");}}function processDateTimePattern(pattern,result){var literals=[];pattern=pattern.replace(/'{2}/g,"{apostrophe}").replace(/'(.*?)'/g,function(_,literal){literals.push(literal);return"$$"+(literals.length-1)+"$$"}).replace(DATE_TIME_REGEX,function(m){return matchSkeletonPattern(m,result||
{})});literals.length&&(pattern=pattern.replace(/\$\$(\d+)\$\$/g,function(_,i){return literals[+i]}).replace(/\{apostrophe\}/g,"'"));return[pattern.replace(/([\s\uFEFF\xA0])\{ampm\}([\s\uFEFF\xA0])/,"$1").replace("{ampm}","").replace(expPatternTrimmer,""),pattern]}function splitFallbackRangePattern(pattern$jscomp$0){return pattern$jscomp$0.split(/(\{[0|1]\})/g).filter(Boolean).map(function(pattern){switch(pattern){case "{0}":return{source:"startRange",pattern:pattern};case "{1}":return{source:"endRange",
pattern:pattern};default:return{source:"shared",pattern:pattern}}})}function splitRangePattern(pattern){for(var PART_REGEX=/\{(.*?)\}/g,parts={},match,splitIndex=0;match=PART_REGEX.exec(pattern);)if(match[0]in parts){splitIndex=match.index;break}else parts[match[0]]=match.index;return splitIndex?[{source:"startRange",pattern:pattern.slice(0,splitIndex)},{source:"endRange",pattern:pattern.slice(splitIndex)}]:[{source:"startRange",pattern:pattern}]}Object.defineProperty(exports,"__esModule",{value:!0});
exports.splitRangePattern=exports.splitFallbackRangePattern=exports.parseDateTimeSkeleton=exports.processDateTimePattern=void 0;var tslib_1=require("module$node_modules$tslib$tslib"),DATE_TIME_REGEX=/(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g,expPatternTrimmer=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;exports.processDateTimePattern=processDateTimePattern;exports.parseDateTimeSkeleton=
function(skeleton,rawPattern,rangePatterns,intervalFormatFallback){void 0===rawPattern&&(rawPattern=skeleton);var result={pattern:"",pattern12:"",skeleton:skeleton,rawPattern:rawPattern,rangePatterns:{},rangePatterns12:{}};if(rangePatterns)for(var k in rangePatterns){intervalFormatFallback=skeletonTokenToTable2(k);var intervalResult={patternParts:[]},_a=processDateTimePattern(rangePatterns[k],intervalResult),pattern_1=_a[0];_a=_a[1];result.rangePatterns[intervalFormatFallback]=tslib_1.__assign(tslib_1.__assign({},
intervalResult),{patternParts:splitRangePattern(pattern_1)});result.rangePatterns12[intervalFormatFallback]=tslib_1.__assign(tslib_1.__assign({},intervalResult),{patternParts:splitRangePattern(_a)})}else intervalFormatFallback&&(rangePatterns=splitFallbackRangePattern(intervalFormatFallback),result.rangePatterns.default={patternParts:rangePatterns},result.rangePatterns12.default={patternParts:rangePatterns});skeleton.replace(DATE_TIME_REGEX,function(m){return matchSkeletonPattern(m,result)});skeleton=
processDateTimePattern(rawPattern);rawPattern=skeleton[1];result.pattern=skeleton[0];result.pattern12=rawPattern;return result};exports.splitFallbackRangePattern=splitFallbackRangePattern;exports.splitRangePattern=splitRangePattern}
//# sourceMappingURL=module$node_modules$$formatjs$ecma402_abstract$DateTimeFormat$skeleton.js.map
