{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Axes.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,mEAAA,CAAuF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAO/H,IAAIC,KAAO,EAEXF,OAAAC,QAAA,CAAiBC,IAEjB,KAAIC,OAASJ,OAAA,CAAQ,sEAAR,CAAb,CACIK,OAASL,OAAA,CAAQ,kEAAR,CAEZ,UAAQ,EAAG,CAQRG,IAAAG,aAAA,CAAoBC,QAAQ,CAACC,QAAD,CAAW,CAInC,IAHA,IAAIC,KAAO,EAAX,CAGSC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBF,QAAAG,OAApB,CAAqCD,CAAA,EAArC,CAA0C,CAAA,IAClCE,GAAKF,CAALE,CAAS,CAATA,EAAcJ,QAAAG,OACdE,EAAAA,CAAST,MAAAU,UAAA,CAAiB,CACtBC,EAAGP,QAAA,CAASI,CAAT,CAAAI,EAAHD,CAAmBP,QAAA,CAASE,CAAT,CAAAM,EADG,CAEtBA,EAAGR,QAAA,CAASE,CAAT,CAAAK,EAAHC;AAAmBR,QAAA,CAASI,CAAT,CAAAG,EAFG,CAAjB,CADb,KAKIE,SAAyB,CAAd,GAACJ,CAAAG,EAAD,CAAmBE,QAAnB,CAA+BL,CAAAE,EAA/B,CAA0CF,CAAAG,EAGzDC,SAAA,CAAWA,QAAAE,QAAA,CAAiB,CAAjB,CAAAC,SAAA,EACXX,KAAA,CAAKQ,QAAL,CAAA,CAAiBJ,CAVqB,CAa1C,MAAOR,OAAAgB,OAAA,CAAcZ,IAAd,CAjB4B,CA0BvCN,KAAAmB,OAAA,CAAcC,QAAQ,CAACd,IAAD,CAAOe,KAAP,CAAc,CAChC,GAAc,CAAd,GAAIA,KAAJ,CAAA,CADgC,IAI5BC,IAAMC,IAAAD,IAAA,CAASD,KAAT,CACNG,MAAAA,CAAMD,IAAAC,IAAA,CAASH,KAAT,CAEV,KAAK,IAAId,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,IAAAE,OAApB,CAAiCD,CAAA,EAAjC,CAAsC,CAAA,IAC9BkB,KAAOnB,IAAA,CAAKC,CAAL,CAEX,KAAAmB,GAAKD,IAAAb,EAALc,CAAcJ,GAAdI,CAAoBD,IAAAZ,EAApBa,CAA6BF,KAC7BC,KAAAZ,EAAA,CAASY,IAAAb,EAAT,CAAkBY,KAAlB,CAAwBC,IAAAZ,EAAxB,CAAiCS,GACjCG,KAAAb,EAAA,CAASc,EALyB,CANtC,CADgC,CAlC5B,CAAX,CAAD,EAd+H;",
"sources":["node_modules/Phaser/src/physics/matter-js/lib/geometry/Axes.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Axes\"] = function(global,require,module,exports) {\n/**\r\n* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\r\n*\r\n* @class Axes\r\n*/\r\n\r\nvar Axes = {};\r\n\r\nmodule.exports = Axes;\r\n\r\nvar Vector = require('../geometry/Vector');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new set of axes from the given vertices.\r\n     * @method fromVertices\r\n     * @param {vertices} vertices\r\n     * @return {axes} A new axes from the given vertices\r\n     */\r\n    Axes.fromVertices = function(vertices) {\r\n        var axes = {};\r\n\r\n        // find the unique axes, using edge normal gradients\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var j = (i + 1) % vertices.length, \r\n                normal = Vector.normalise({ \r\n                    x: vertices[j].y - vertices[i].y, \r\n                    y: vertices[i].x - vertices[j].x\r\n                }),\r\n                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);\r\n            \r\n            // limit precision\r\n            gradient = gradient.toFixed(3).toString();\r\n            axes[gradient] = normal;\r\n        }\r\n\r\n        return Common.values(axes);\r\n    };\r\n\r\n    /**\r\n     * Rotates a set of axes by the given angle.\r\n     * @method rotate\r\n     * @param {axes} axes\r\n     * @param {number} angle\r\n     */\r\n    Axes.rotate = function(axes, angle) {\r\n        if (angle === 0)\r\n            return;\r\n        \r\n        var cos = Math.cos(angle),\r\n            sin = Math.sin(angle);\r\n\r\n        for (var i = 0; i < axes.length; i++) {\r\n            var axis = axes[i],\r\n                xx;\r\n            xx = axis.x * cos - axis.y * sin;\r\n            axis.y = axis.x * sin + axis.y * cos;\r\n            axis.x = xx;\r\n        }\r\n    };\r\n\r\n})();\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Axes","Vector","Common","fromVertices","Axes.fromVertices","vertices","axes","i","length","j","normal","normalise","x","y","gradient","Infinity","toFixed","toString","values","rotate","Axes.rotate","angle","cos","Math","sin","axis","xx"]
}
