shadow$provide.module$node_modules$Phaser$src$geom$polygon$Earcut=function(global,require,module,exports){function earcut(data,holeIndices,dim){dim=dim||2;var hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length,outerNode=linkedList(data,0,outerLen,dim,!0),triangles=[];if(!outerNode)return triangles;var maxX;if(hasHoles){var dim$jscomp$0=dim;hasHoles=[];var len;var x=0;for(len=holeIndices.length;x<len;x++){var start=holeIndices[x]*dim$jscomp$0;var end=x<len-1?
holeIndices[x+1]*dim$jscomp$0:data.length;start=linkedList(data,start,end,dim$jscomp$0,!1);start===start.next&&(start.steiner=!0);hasHoles.push(getLeftmost(start))}hasHoles.sort(compareX);for(x=0;x<hasHoles.length;x++){holeIndices=hasHoles[x];dim$jscomp$0=outerNode;if(dim$jscomp$0=findHoleBridge(holeIndices,dim$jscomp$0))holeIndices=splitPolygon(dim$jscomp$0,holeIndices),filterPoints(holeIndices,holeIndices.next);outerNode=filterPoints(outerNode,outerNode.next)}}if(data.length>80*dim){var minX=maxX=
data[0];var minY=hasHoles=data[1];for(dim$jscomp$0=dim;dim$jscomp$0<outerLen;dim$jscomp$0+=dim)x=data[dim$jscomp$0],holeIndices=data[dim$jscomp$0+1],x<minX&&(minX=x),holeIndices<minY&&(minY=holeIndices),x>maxX&&(maxX=x),holeIndices>hasHoles&&(hasHoles=holeIndices);maxX=Math.max(maxX-minX,hasHoles-minY)}earcutLinked(outerNode,triangles,dim,minX,minY,maxX);return triangles}function linkedList(data,start,end,dim,clockwise){if(clockwise===0<signedArea(data,start,end,dim))for(clockwise=start;clockwise<
end;clockwise+=dim)var last=insertNode(clockwise,data[clockwise],data[clockwise+1],last);else for(clockwise=end-dim;clockwise>=start;clockwise-=dim)last=insertNode(clockwise,data[clockwise],data[clockwise+1],last);last&&equals(last,last.next)&&(removeNode(last),last=last.next);return last}function filterPoints(start,end){if(!start)return start;end||(end=start);do{var again=!1;if(start.steiner||!equals(start,start.next)&&0!==area(start.prev,start,start.next))start=start.next;else{removeNode(start);
start=end=start.prev;if(start===start.next)return null;again=!0}}while(again||start!==end);return end}function earcutLinked(ear,triangles,dim,minX,minY$jscomp$0,size$jscomp$0,pass){if(ear){if(!pass&&size$jscomp$0){var start=ear,p=start;do null===p.z&&(p.z=zOrder(p.x,p.y,minX,minY$jscomp$0,size$jscomp$0)),p.prevZ=p.prev,p=p.nextZ=p.next;while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;start=p;var i,numMerges,pSize,qSize,inSize=1;do{p=start;var tail=start=null;for(numMerges=0;p;){numMerges++;var q=
p;for(i=pSize=0;i<inSize&&(pSize++,q=q.nextZ,q);i++);for(qSize=inSize;0<pSize||0<qSize&&q;)0!==pSize&&(0===qSize||!q||p.z<=q.z)?(i=p,p=p.nextZ,pSize--):(i=q,q=q.nextZ,qSize--),tail?tail.nextZ=i:start=i,i.prevZ=tail,tail=i;p=q}tail.nextZ=null;inSize*=2}while(1<numMerges)}for(start=ear;ear.prev!==ear.next;){p=ear.prev;q=ear.next;if(size$jscomp$0)a:{tail=ear;qSize=minX;var minY=minY$jscomp$0,size=size$jscomp$0;numMerges=tail.prev;pSize=tail;inSize=tail.next;if(0<=area(numMerges,pSize,inSize))tail=!1;
else{var maxTX=numMerges.x>pSize.x?numMerges.x>inSize.x?numMerges.x:inSize.x:pSize.x>inSize.x?pSize.x:inSize.x,maxTY=numMerges.y>pSize.y?numMerges.y>inSize.y?numMerges.y:inSize.y:pSize.y>inSize.y?pSize.y:inSize.y;i=zOrder(numMerges.x<pSize.x?numMerges.x<inSize.x?numMerges.x:inSize.x:pSize.x<inSize.x?pSize.x:inSize.x,numMerges.y<pSize.y?numMerges.y<inSize.y?numMerges.y:inSize.y:pSize.y<inSize.y?pSize.y:inSize.y,qSize,minY,size);qSize=zOrder(maxTX,maxTY,qSize,minY,size);for(minY=tail.nextZ;minY&&minY.z<=
qSize;){if(minY!==tail.prev&&minY!==tail.next&&pointInTriangle(numMerges.x,numMerges.y,pSize.x,pSize.y,inSize.x,inSize.y,minY.x,minY.y)&&0<=area(minY.prev,minY,minY.next)){tail=!1;break a}minY=minY.nextZ}for(minY=tail.prevZ;minY&&minY.z>=i;){if(minY!==tail.prev&&minY!==tail.next&&pointInTriangle(numMerges.x,numMerges.y,pSize.x,pSize.y,inSize.x,inSize.y,minY.x,minY.y)&&0<=area(minY.prev,minY,minY.next)){tail=!1;break a}minY=minY.prevZ}tail=!0}}else a:if(tail=ear,numMerges=tail.prev,pSize=tail,inSize=
tail.next,0<=area(numMerges,pSize,inSize))tail=!1;else{for(i=tail.next.next;i!==tail.prev;){if(pointInTriangle(numMerges.x,numMerges.y,pSize.x,pSize.y,inSize.x,inSize.y,i.x,i.y)&&0<=area(i.prev,i,i.next)){tail=!1;break a}i=i.next}tail=!0}if(tail)triangles.push(p.i/dim),triangles.push(ear.i/dim),triangles.push(q.i/dim),removeNode(ear),start=ear=q.next;else if(ear=q,ear===start){if(!pass)earcutLinked(filterPoints(ear),triangles,dim,minX,minY$jscomp$0,size$jscomp$0,1);else if(1===pass){pass=triangles;
start=dim;p=ear;do q=p.prev,tail=p.next.next,!equals(q,tail)&&intersects(q,p,p.next,tail)&&locallyInside(q,tail)&&locallyInside(tail,q)&&(pass.push(q.i/start),pass.push(p.i/start),pass.push(tail.i/start),removeNode(p),removeNode(p.next),p=ear=tail),p=p.next;while(p!==ear);ear=p;earcutLinked(ear,triangles,dim,minX,minY$jscomp$0,size$jscomp$0,2)}else if(2===pass)a:{pass=ear;do{for(start=pass.next.next;start!==pass.prev;){if(p=pass.i!==start.i){p=pass;q=start;if(tail=p.next.i!==q.i&&p.prev.i!==q.i){b:{tail=
p;do{if(tail.i!==p.i&&tail.next.i!==p.i&&tail.i!==q.i&&tail.next.i!==q.i&&intersects(tail,tail.next,p,q)){tail=!0;break b}tail=tail.next}while(tail!==p);tail=!1}tail=!tail}if(tail=tail&&locallyInside(p,q)&&locallyInside(q,p)){tail=p;numMerges=!1;pSize=(p.x+q.x)/2;q=(p.y+q.y)/2;do tail.y>q!==tail.next.y>q&&tail.next.y!==tail.y&&pSize<(tail.next.x-tail.x)*(q-tail.y)/(tail.next.y-tail.y)+tail.x&&(numMerges=!numMerges),tail=tail.next;while(tail!==p);tail=numMerges}p=tail}if(p){ear=splitPolygon(pass,start);
pass=filterPoints(pass,pass.next);ear=filterPoints(ear,ear.next);earcutLinked(pass,triangles,dim,minX,minY$jscomp$0,size$jscomp$0);earcutLinked(ear,triangles,dim,minX,minY$jscomp$0,size$jscomp$0);break a}start=start.next}pass=pass.next}while(pass!==ear)}break}}}}function compareX(a,b){return a.x-b.x}function findHoleBridge(hole,outerNode){var p=outerNode,hx=hole.x,hy=hole.y,qx=-Infinity;do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=
x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next}var m=p.x<p.next.x?p:p.next}}p=p.next}while(p!==outerNode);if(!m)return null;if(hx===qx)return m.prev;outerNode=m;x=m.x;var my=m.y,tanMin=Infinity;for(p=m.next;p!==outerNode;){if(hx>=p.x&&p.x>=x&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,x,my,hy<my?qx:hx,hy,p.x,p.y)){var tan=Math.abs(hy-p.y)/(hx-p.x);(tan<tanMin||tan===tanMin&&p.x>m.x)&&locallyInside(p,hole)&&(m=p,tanMin=tan)}p=p.next}return m}function zOrder(x,y,minX,minY,size){x=32767*
(x-minX)/size;y=32767*(y-minY)/size;x=(x|x<<8)&16711935;x=(x|x<<4)&252645135;x=(x|x<<2)&858993459;y=(y|y<<8)&16711935;y=(y|y<<4)&252645135;y=(y|y<<2)&858993459;return(x|x<<1)&1431655765|((y|y<<1)&1431655765)<<1}function getLeftmost(start){var p=start,leftmost=start;do p.x<leftmost.x&&(leftmost=p),p=p.next;while(p!==start);return leftmost}function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return 0<=(cx-px)*(ay-py)-(ax-px)*(cy-py)&&0<=(ax-px)*(by-py)-(bx-px)*(ay-py)&&0<=(bx-px)*(cy-py)-(cx-px)*(by-py)}
function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y)}function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y}function intersects(p1,q1,p2,q2){return equals(p1,q1)&&equals(p2,q2)||equals(p1,q2)&&equals(p2,q1)?!0:0<area(p1,q1,p2)!==0<area(p1,q1,q2)&&0<area(p2,q2,p1)!==0<area(p2,q2,q1)}function locallyInside(a,b){return 0>area(a.prev,a,a.next)?0<=area(a,b,a.next)&&0<=area(a,a.prev,b):0>area(a,b,a.prev)||0>area(a,a.next,b)}function splitPolygon(a,b){var a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,
b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2}function insertNode(i,x,y,last){i=new Node(i,x,y);last?(i.next=last.next,i.prev=last,last.next.prev=i,last.next=i):(i.prev=i,i.next=i);return i}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;p.prevZ&&(p.prevZ.nextZ=p.nextZ);p.nextZ&&(p.nextZ.prevZ=p.prevZ)}function Node(i,x,y){this.i=i;this.x=x;this.y=y;this.nextZ=this.prevZ=this.z=this.next=this.prev=null;this.steiner=
!1}function signedArea(data,start,end,dim){for(var sum=0,j=end-dim;start<end;start+=dim)sum+=(data[j]-data[start])*(data[start+1]+data[j+1]),j=start;return sum}module.exports=earcut;earcut.deviation=function(data,holeIndices,dim,triangles){var hasHoles=holeIndices&&holeIndices.length,polygonArea=Math.abs(signedArea(data,0,hasHoles?holeIndices[0]*dim:data.length,dim));if(hasHoles){hasHoles=0;for(var len=holeIndices.length;hasHoles<len;hasHoles++)polygonArea-=Math.abs(signedArea(data,holeIndices[hasHoles]*
dim,hasHoles<len-1?holeIndices[hasHoles+1]*dim:data.length,dim))}for(hasHoles=holeIndices=0;hasHoles<triangles.length;hasHoles+=3){len=triangles[hasHoles]*dim;var b=triangles[hasHoles+1]*dim,c=triangles[hasHoles+2]*dim;holeIndices+=Math.abs((data[len]-data[c])*(data[b+1]-data[len+1])-(data[len]-data[b])*(data[c+1]-data[len+1]))}return 0===polygonArea&&0===holeIndices?0:Math.abs((holeIndices-polygonArea)/polygonArea)};earcut.flatten=function(data){for(var dim=data[0][0].length,result={vertices:[],
holes:[],dimensions:dim},holeIndex=0,i=0;i<data.length;i++){for(var j=0;j<data[i].length;j++)for(var d=0;d<dim;d++)result.vertices.push(data[i][j][d]);0<i&&(holeIndex+=data[i-1].length,result.holes.push(holeIndex))}return result}}
//# sourceMappingURL=module$node_modules$Phaser$src$geom$polygon$Earcut.js.map
