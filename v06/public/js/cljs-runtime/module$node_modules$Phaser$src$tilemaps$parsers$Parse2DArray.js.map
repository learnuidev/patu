{
"version":3,
"file":"module$node_modules$Phaser$src$tilemaps$parsers$Parse2DArray.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,6DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAOzH,IAAIC,QAAUH,OAAA,CAAQ,iDAAR,CAAd,CACII,UAAYJ,OAAA,CAAQ,2DAAR,CADhB,CAEIK,QAAUL,OAAA,CAAQ,yDAAR,CAFd,CAGIM,KAAON,OAAA,CAAQ,8CAAR,CA4EXC,OAAAC,QAAA,CAvDmBK,QAAS,CAACC,IAAD,CAAOC,IAAP,CAAaC,SAAb,CAAwBC,UAAxB,CAAoCC,UAApC,CAC5B,CACI,IAAIC,UAAY,IAAIT,SAAJ,CAAc,CAC1BM,UAAWA,SADe;AAE1BC,WAAYA,UAFc,CAAd,CAKZG,KAAAA,CAAU,IAAIT,OAAJ,CAAY,CACtBG,KAAMA,IADgB,CAEtBE,UAAWA,SAFW,CAGtBC,WAAYA,UAHU,CAItBI,OAAQZ,OAAAa,SAJc,CAKtBC,OAAQ,CAAEJ,SAAF,CALc,CAAZ,CAYd,KAJA,IAAIK,MAAQ,EAAZ,CACIC,OAASV,IAAAW,OADb,CAEIC,MAAQ,CAFZ,CAISC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBb,IAAAW,OAApB,CAAiCE,CAAA,EAAjC,CACA,CACIJ,KAAA,CAAMI,CAAN,CAAA,CAAW,EAGX,KAFA,IAAIC,IAAMd,IAAA,CAAKa,CAAL,CAAV,CAESE,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,GAAAH,OAApB,CAAgCI,CAAA,EAAhC,CACA,CACI,IAAIC,UAAYC,QAAA,CAASH,GAAA,CAAIC,CAAJ,CAAT,CAAiB,EAAjB,CAEZG,MAAA,CAAMF,SAAN,CAAJ,EAAsC,EAAtC,GAAwBA,SAAxB,CAEIP,KAAA,CAAMI,CAAN,CAAA,CAASE,CAAT,CAFJ,CAEkBZ,UAAA,CACR,IADQ,CAER,IAAIN,IAAJ,CAASO,SAAT,CAAoB,EAApB,CAAwBW,CAAxB,CAA2BF,CAA3B,CAA8BZ,SAA9B,CAAyCC,UAAzC,CAJV,CAQIO,KAAA,CAAMI,CAAN,CAAA,CAASE,CAAT,CARJ,CAQkB,IAAIlB,IAAJ,CAASO,SAAT,CAAoBY,SAApB,CAA+BD,CAA/B,CAAkCF,CAAlC,CAAqCZ,SAArC,CAAgDC,UAAhD,CAXtB,CAec,CAAd,GAAIU,KAAJ,GAEIA,KAFJ,CAEYE,GAAAH,OAFZ,CApBJ,CA0BAN,IAAAO,MAAA;AAAgBR,SAAAQ,MAAhB,CAAkCA,KAClCP,KAAAK,OAAA,CAAiBN,SAAAM,OAAjB,CAAoCA,MACpCL,KAAAc,cAAA,CAAwBf,SAAAe,cAAxB,CAAkDP,KAAlD,CAA0DX,SAC1DI,KAAAe,eAAA,CAAyBhB,SAAAgB,eAAzB,CAAoDV,MAApD,CAA6DR,UAC7DE,UAAAJ,KAAA,CAAiBS,KAEjB,OAAOJ,KAnDX,CAhCyH;",
"sources":["node_modules/Phaser/src/tilemaps/parsers/Parse2DArray.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$tilemaps$parsers$Parse2DArray\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar LayerData = require('../mapdata/LayerData');\r\nvar MapData = require('../mapdata/MapData');\r\nvar Tile = require('../Tile');\r\n\r\n/**\r\n * Parses a 2D array of tile indexes into a new MapData object with a single layer.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Parse2DArray\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {integer[][]} data - 2D array, CSV string or Tiled JSON object.\r\n * @param {integer} tileWidth - The width of a tile in pixels.\r\n * @param {integer} tileHeight - The height of a tile in pixels.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} [description]\r\n */\r\nvar Parse2DArray = function (name, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var layerData = new LayerData({\r\n        tileWidth: tileWidth,\r\n        tileHeight: tileHeight\r\n    });\r\n\r\n    var mapData = new MapData({\r\n        name: name,\r\n        tileWidth: tileWidth,\r\n        tileHeight: tileHeight,\r\n        format: Formats.ARRAY_2D,\r\n        layers: [ layerData ]\r\n    });\r\n\r\n    var tiles = [];\r\n    var height = data.length;\r\n    var width = 0;\r\n\r\n    for (var y = 0; y < data.length; y++)\r\n    {\r\n        tiles[y] = [];\r\n        var row = data[y];\r\n\r\n        for (var x = 0; x < row.length; x++)\r\n        {\r\n            var tileIndex = parseInt(row[x], 10);\r\n\r\n            if (isNaN(tileIndex) || tileIndex === -1)\r\n            {\r\n                tiles[y][x] = insertNull\r\n                    ? null\r\n                    : new Tile(layerData, -1, x, y, tileWidth, tileHeight);\r\n            }\r\n            else\r\n            {\r\n                tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);\r\n            }\r\n        }\r\n\r\n        if (width === 0)\r\n        {\r\n            width = row.length;\r\n        }\r\n    }\r\n\r\n    mapData.width = layerData.width = width;\r\n    mapData.height = layerData.height = height;\r\n    mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;\r\n    mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;\r\n    layerData.data = tiles;\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = Parse2DArray;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Formats","LayerData","MapData","Tile","Parse2DArray","name","data","tileWidth","tileHeight","insertNull","layerData","mapData","format","ARRAY_2D","layers","tiles","height","length","width","y","row","x","tileIndex","parseInt","isNaN","widthInPixels","heightInPixels"]
}
