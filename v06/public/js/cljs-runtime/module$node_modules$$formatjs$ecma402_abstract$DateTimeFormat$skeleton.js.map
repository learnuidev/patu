{
"version":3,
"file":"module$node_modules$$formatjs$ecma402_abstract$DateTimeFormat$skeleton.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/@formatjs/ecma402-abstract/DateTimeFormat/skeleton.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$formatjs$ecma402_abstract$DateTimeFormat$skeleton\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.splitRangePattern = exports.splitFallbackRangePattern = exports.parseDateTimeSkeleton = exports.processDateTimePattern = void 0;\nvar tslib_1 = require(\"tslib\");\n/**\n * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js\n * with some tweaks\n */\nvar DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n// trim patterns after transformations\nvar expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\nfunction matchSkeletonPattern(match, result) {\n    var len = match.length;\n    switch (match[0]) {\n        // Era\n        case 'G':\n            result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';\n            return '{era}';\n        // Year\n        case 'y':\n        case 'Y':\n        case 'u':\n        case 'U':\n        case 'r':\n            result.year = len === 2 ? '2-digit' : 'numeric';\n            return '{year}';\n        // Quarter\n        case 'q':\n        case 'Q':\n            throw new RangeError('`w/Q` (quarter) patterns are not supported');\n        // Month\n        case 'M':\n        case 'L':\n            result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];\n            return '{month}';\n        // Week\n        case 'w':\n        case 'W':\n            throw new RangeError('`w/W` (week of year) patterns are not supported');\n        case 'd':\n            result.day = ['numeric', '2-digit'][len - 1];\n            return '{day}';\n        case 'D':\n        case 'F':\n        case 'g':\n            result.day = 'numeric';\n            return '{day}';\n        // Weekday\n        case 'E':\n            result.weekday = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';\n            return '{weekday}';\n        case 'e':\n            result.weekday = [\n                'numeric',\n                '2-digit',\n                'short',\n                'long',\n                'narrow',\n                'short',\n            ][len - 1];\n            return '{weekday}';\n        case 'c':\n            result.weekday = [\n                'numeric',\n                undefined,\n                'short',\n                'long',\n                'narrow',\n                'short',\n            ][len - 1];\n            return '{weekday}';\n        // Period\n        case 'a': // AM, PM\n        case 'b': // am, pm, noon, midnight\n        case 'B': // flexible day periods\n            result.hour12 = true;\n            return '{ampm}';\n        // Hour\n        case 'h':\n            result.hour = ['numeric', '2-digit'][len - 1];\n            result.hour12 = true;\n            return '{hour}';\n        case 'H':\n            result.hour = ['numeric', '2-digit'][len - 1];\n            return '{hour}';\n        case 'K':\n            result.hour = ['numeric', '2-digit'][len - 1];\n            result.hour12 = true;\n            return '{hour}';\n        case 'k':\n            result.hour = ['numeric', '2-digit'][len - 1];\n            return '{hour}';\n        case 'j':\n        case 'J':\n        case 'C':\n            throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');\n        // Minute\n        case 'm':\n            result.minute = ['numeric', '2-digit'][len - 1];\n            return '{minute}';\n        // Second\n        case 's':\n            result.second = ['numeric', '2-digit'][len - 1];\n            return '{second}';\n        case 'S':\n        case 'A':\n            result.second = 'numeric';\n            return '{second}';\n        // Zone\n        case 'z': // 1..3, 4: specific non-location format\n        case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n        case 'O': // 1, 4: miliseconds in day short, long\n        case 'v': // 1, 4: generic non-location format\n        case 'V': // 1, 2, 3, 4: time zone ID or city\n        case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n        case 'x': // 1, 2, 3, 4: The ISO8601 varios formats\n            result.timeZoneName = len < 4 ? 'short' : 'long';\n            return '{timeZoneName}';\n    }\n    return '';\n}\nfunction skeletonTokenToTable2(c) {\n    switch (c) {\n        // Era\n        case 'G':\n            return 'era';\n        // Year\n        case 'y':\n        case 'Y':\n        case 'u':\n        case 'U':\n        case 'r':\n            return 'year';\n        // Month\n        case 'M':\n        case 'L':\n            return 'month';\n        // Day\n        case 'd':\n        case 'D':\n        case 'F':\n        case 'g':\n            return 'day';\n        // Period\n        case 'a': // AM, PM\n        case 'b': // am, pm, noon, midnight\n        case 'B': // flexible day periods\n            return 'ampm';\n        // Hour\n        case 'h':\n        case 'H':\n        case 'K':\n        case 'k':\n            return 'hour';\n        // Minute\n        case 'm':\n            return 'minute';\n        // Second\n        case 's':\n        case 'S':\n        case 'A':\n            return 'second';\n        default:\n            throw new RangeError('Invalid range pattern token');\n    }\n}\nfunction processDateTimePattern(pattern, result) {\n    var literals = [];\n    // Use skeleton to populate result, but use mapped pattern to populate pattern\n    var pattern12 = pattern\n        // Double apostrophe\n        .replace(/'{2}/g, '{apostrophe}')\n        // Apostrophe-escaped\n        .replace(/'(.*?)'/g, function (_, literal) {\n        literals.push(literal);\n        return \"$$\" + (literals.length - 1) + \"$$\";\n    })\n        .replace(DATE_TIME_REGEX, function (m) { return matchSkeletonPattern(m, result || {}); });\n    //Restore literals\n    if (literals.length) {\n        pattern12 = pattern12\n            .replace(/\\$\\$(\\d+)\\$\\$/g, function (_, i) {\n            return literals[+i];\n        })\n            .replace(/\\{apostrophe\\}/g, \"'\");\n    }\n    // Handle apostrophe-escaped things\n    return [\n        pattern12\n            .replace(/([\\s\\uFEFF\\xA0])\\{ampm\\}([\\s\\uFEFF\\xA0])/, '$1')\n            .replace('{ampm}', '')\n            .replace(expPatternTrimmer, ''),\n        pattern12,\n    ];\n}\nexports.processDateTimePattern = processDateTimePattern;\n/**\n * Parse Date time skeleton into Intl.DateTimeFormatOptions\n * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * @public\n * @param skeleton skeleton string\n */\nfunction parseDateTimeSkeleton(skeleton, rawPattern, rangePatterns, intervalFormatFallback) {\n    if (rawPattern === void 0) { rawPattern = skeleton; }\n    var result = {\n        pattern: '',\n        pattern12: '',\n        skeleton: skeleton,\n        rawPattern: rawPattern,\n        rangePatterns: {},\n        rangePatterns12: {},\n    };\n    if (rangePatterns) {\n        for (var k in rangePatterns) {\n            var key = skeletonTokenToTable2(k);\n            var rawPattern_1 = rangePatterns[k];\n            var intervalResult = {\n                patternParts: [],\n            };\n            var _a = processDateTimePattern(rawPattern_1, intervalResult), pattern_1 = _a[0], pattern12_1 = _a[1];\n            result.rangePatterns[key] = tslib_1.__assign(tslib_1.__assign({}, intervalResult), { patternParts: splitRangePattern(pattern_1) });\n            result.rangePatterns12[key] = tslib_1.__assign(tslib_1.__assign({}, intervalResult), { patternParts: splitRangePattern(pattern12_1) });\n        }\n    }\n    else if (intervalFormatFallback) {\n        var patternParts = splitFallbackRangePattern(intervalFormatFallback);\n        result.rangePatterns.default = {\n            patternParts: patternParts,\n        };\n        result.rangePatterns12.default = {\n            patternParts: patternParts,\n        };\n    }\n    // Process skeleton\n    skeleton.replace(DATE_TIME_REGEX, function (m) { return matchSkeletonPattern(m, result); });\n    var _b = processDateTimePattern(rawPattern), pattern = _b[0], pattern12 = _b[1];\n    result.pattern = pattern;\n    result.pattern12 = pattern12;\n    return result;\n}\nexports.parseDateTimeSkeleton = parseDateTimeSkeleton;\nfunction splitFallbackRangePattern(pattern) {\n    var parts = pattern.split(/(\\{[0|1]\\})/g).filter(Boolean);\n    return parts.map(function (pattern) {\n        switch (pattern) {\n            case '{0}':\n                return {\n                    source: \"startRange\" /* startRange */,\n                    pattern: pattern,\n                };\n            case '{1}':\n                return {\n                    source: \"endRange\" /* endRange */,\n                    pattern: pattern,\n                };\n            default:\n                return {\n                    source: \"shared\" /* shared */,\n                    pattern: pattern,\n                };\n        }\n    });\n}\nexports.splitFallbackRangePattern = splitFallbackRangePattern;\nfunction splitRangePattern(pattern) {\n    var PART_REGEX = /\\{(.*?)\\}/g;\n    // Map of part and index within the string\n    var parts = {};\n    var match;\n    var splitIndex = 0;\n    while ((match = PART_REGEX.exec(pattern))) {\n        if (!(match[0] in parts)) {\n            parts[match[0]] = match.index;\n        }\n        else {\n            splitIndex = match.index;\n            break;\n        }\n    }\n    if (!splitIndex) {\n        return [\n            {\n                source: \"startRange\" /* startRange */,\n                pattern: pattern,\n            },\n        ];\n    }\n    return [\n        {\n            source: \"startRange\" /* startRange */,\n            pattern: pattern.slice(0, splitIndex),\n        },\n        {\n            source: \"endRange\" /* endRange */,\n            pattern: pattern.slice(splitIndex),\n        },\n    ];\n}\nexports.splitRangePattern = splitRangePattern;\n\n};"],
"names":["shadow$provide","global","require","module","exports","matchSkeletonPattern","match","result","len","length","era","year","RangeError","month","day","weekday","undefined","hour12","hour","minute","second","timeZoneName","skeletonTokenToTable2","c","processDateTimePattern","pattern","literals","pattern12","replace","_","literal","push","DATE_TIME_REGEX","m","i","expPatternTrimmer","splitFallbackRangePattern","split","filter","parts","Boolean","map","source","splitRangePattern","PART_REGEX","splitIndex","exec","index","slice","Object","defineProperty","value","parseDateTimeSkeleton","tslib_1","skeleton","rawPattern","rangePatterns","intervalFormatFallback","rangePatterns12","k","key","intervalResult","patternParts","_a","rawPattern_1","pattern_1","pattern12_1","__assign","default","_b"]
}
