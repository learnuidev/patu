{
"version":3,
"file":"module$node_modules$Phaser$src$tilemaps$Tile.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/Phaser/src/tilemaps/Tile.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$tilemaps$Tile\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Components = require('../gameobjects/components');\r\nvar Rectangle = require('../geom/rectangle');\r\n\r\n/**\r\n * @classdesc\r\n * A Tile is a representation of a single tile within the Tilemap. This is a lightweight data\r\n * representation, so its position information is stored without factoring in scroll, layer\r\n * scale or layer position.\r\n *\r\n * @class Tile\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The LayerData object in the Tilemap that this tile belongs to.\r\n * @param {integer} index - The unique index of this tile within the map.\r\n * @param {integer} x - The x coordinate of this tile in tile coordinates.\r\n * @param {integer} y - The y coordinate of this tile in tile coordinates.\r\n * @param {integer} width - Width of the tile in pixels.\r\n * @param {integer} height - Height of the tile in pixels.\r\n * @param {integer} baseWidth - The base width a tile in the map (in pixels). Tiled maps support\r\n * multiple tileset sizes within one map, but they are still placed at intervals of the base\r\n * tile width.\r\n * @param {integer} baseHeight - The base height of the tile in pixels (in pixels). Tiled maps\r\n * support multiple tileset sizes within one map, but they are still placed at intervals of the\r\n * base tile height.\r\n */\r\nvar Tile = new Class({\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.Flip,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Tile (layer, index, x, y, width, height, baseWidth, baseHeight)\r\n    {\r\n        /**\r\n         * The LayerData in the Tilemap data that this tile belongs to.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.0.0\r\n         */\r\n        this.layer = layer;\r\n\r\n        /**\r\n         * The index of this tile within the map data corresponding to the tileset, or -1 if this\r\n         * represents a blank tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#index\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * The x map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#x\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#y\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The width of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The map's base width of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseWidth = (baseWidth !== undefined) ? baseWidth : width;\r\n\r\n        /**\r\n         * The map's base height of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseHeight = (baseHeight !== undefined) ? baseHeight : height;\r\n\r\n        /**\r\n         * The x coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelX\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelX = 0;\r\n\r\n        /**\r\n         * The y coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelY\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelY = 0;\r\n\r\n        this.updatePixelXY();\r\n\r\n        /**\r\n         * Tile specific properties. These usually come from Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = {};\r\n\r\n        /**\r\n         * The rotation angle of this tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = 0;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the left side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideLeft = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the right side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideRight = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the top side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideUp\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideUp = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the bottom side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideDown\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideDown = false;\r\n\r\n        /**\r\n         * Whether the tile's left edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceLeft = false;\r\n\r\n        /**\r\n         * Whether the tile's right edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceRight = false;\r\n\r\n        /**\r\n         * Whether the tile's top edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceTop\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceTop = false;\r\n\r\n        /**\r\n         * Whether the tile's bottom edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceBottom\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceBottom = false;\r\n\r\n        /**\r\n         * Tile collision callback.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallback\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallback = null;\r\n\r\n        /**\r\n         * The context in which the collision callback will be called.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallbackContext\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallbackContext = this;\r\n\r\n        /**\r\n         * The tint to apply to this tile. Note: tint is currently a single color value instead of\r\n         * the 4 corner tint component on other GameObjects.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#tint\r\n         * @type {number}\r\n         * @default\r\n         * @since 3.0.0\r\n         */\r\n        this.tint = 0xffffff;\r\n\r\n        /**\r\n         * An empty object where physics-engine specific information (e.g. bodies) may be stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#physics\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.physics = {};\r\n    },\r\n\r\n    /**\r\n     * Check if the given x and y world coordinates are within this Tile. This does not factor in\r\n     * camera scroll, layer scale or layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#containsPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to test.\r\n     * @param {number} y - The y coordinate to test.\r\n     *\r\n     * @return {boolean} True if the coordinates are within this Tile, otherwise false.\r\n     */\r\n    containsPoint: function (x, y)\r\n    {\r\n        return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);\r\n    },\r\n\r\n    /**\r\n     * Copies the tile data & properties from the given tile to this tile. This copies everything\r\n     * except for position and interesting faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile} tile - The tile to copy from.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    copy: function (tile)\r\n    {\r\n        this.index = tile.index;\r\n        this.alpha = tile.alpha;\r\n        this.properties = tile.properties;\r\n        this.visible = tile.visible;\r\n        this.setFlip(tile.flipX, tile.flipY);\r\n        this.tint = tile.tint;\r\n        this.rotation = tile.rotation;\r\n        this.collideUp = tile.collideUp;\r\n        this.collideDown = tile.collideDown;\r\n        this.collideLeft = tile.collideLeft;\r\n        this.collideRight = tile.collideRight;\r\n        this.collisionCallback = tile.collisionCallback;\r\n        this.collisionCallbackContext = tile.collisionCallbackContext;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The collision group for this Tile, defined within the Tileset. This returns a reference to\r\n     * the collision group stored within the Tileset, so any modification of the returned object\r\n     * will impact all tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} tileset\r\n     */\r\n    getCollisionGroup: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * The tile data for this Tile, defined within the Tileset. This typically contains Tiled\r\n     * collision data, tile animations and terrain information. This returns a reference to the tile\r\n     * data stored within the Tileset, so any modification of the returned object will impact all\r\n     * tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} tileset\r\n     */\r\n    getTileData: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileData(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the left side of the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getLeft: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return (tilemapLayer) ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the right side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getRight: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return (tilemapLayer) ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the top side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getTop: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        // Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile in grid\r\n        // units is the bottom left, so the y coordinate needs to be adjusted by the difference\r\n        // between the base size and this tile's size.\r\n        return tilemapLayer\r\n            ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY\r\n            : this.y * this.baseHeight - (this.height - this.baseHeight);\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n\r\n     * @method Phaser.Tilemaps.Tile#getBottom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getBottom: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n        return tilemapLayer\r\n            ? this.getTop(camera) + this.height * tilemapLayer.scaleY\r\n            : this.getTop(camera) + this.height;\r\n    },\r\n\r\n\r\n    /**\r\n     * Gets the world rectangle bounding box for the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     * @param {object} [output] - [description]\r\n     *\r\n     * @return {(Phaser.Geom.Rectangle|object)}\r\n     */\r\n    getBounds: function (camera, output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        output.x = this.getLeft();\r\n        output.y = this.getTop();\r\n        output.width = this.getRight() - output.x;\r\n        output.height = this.getBottom() - output.y;\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getCenterX: function (camera)\r\n    {\r\n        return this.getLeft(camera) + this.width / 2;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getCenterY: function (camera)\r\n    {\r\n        return this.getTop(camera) + this.height / 2;\r\n    },\r\n\r\n    /**\r\n     * Clean up memory.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.collisionCallback = undefined;\r\n        this.collisionCallbackContext = undefined;\r\n        this.properties = undefined;\r\n    },\r\n\r\n    /**\r\n     * Check for intersection with this tile. This does not factor in camera scroll, layer scale or\r\n     * layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x axis in pixels.\r\n     * @param {number} y - The y axis in pixels.\r\n     * @param {number} right - The right point.\r\n     * @param {number} bottom - The bottom point.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    intersects: function (x, y, right, bottom)\r\n    {\r\n        return !(\r\n            right <= this.pixelX || bottom <= this.pixelY ||\r\n            x >= this.right || y >= this.bottom\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Checks if the tile is interesting.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#isInteresting\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} collides - If true, will consider the tile interesting if it collides on any side.\r\n     * @param {boolean} faces - If true, will consider the tile interesting if it has an interesting face.\r\n     *\r\n     * @return {boolean} True if the Tile is interesting, otherwise false.\r\n     */\r\n    isInteresting: function (collides, faces)\r\n    {\r\n        if (collides && faces) { return (this.canCollide || this.hasInterestingFace); }\r\n        else if (collides) { return this.collides; }\r\n        else if (faces) { return this.hasInterestingFace; }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Reset collision status flags.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    resetCollision: function (recalculateFaces)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = false;\r\n        this.collideRight = false;\r\n        this.collideUp = false;\r\n        this.collideDown = false;\r\n\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetFaces\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    resetFaces: function ()\r\n    {\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision flags for each side of this tile and updates the interesting faces list.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} left - Indicating collide with any object on the left.\r\n     * @param {boolean} [right] - Indicating collide with any object on the right.\r\n     * @param {boolean} [up] - Indicating collide with any object on the top.\r\n     * @param {boolean} [down] - Indicating collide with any object on the bottom.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces\r\n     * for this tile and its neighbors.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    setCollision: function (left, right, up, down, recalculateFaces)\r\n    {\r\n        if (right === undefined) { right = left; }\r\n        if (up === undefined) { up = left; }\r\n        if (down === undefined) { down = left; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = left;\r\n        this.collideRight = right;\r\n        this.collideUp = up;\r\n        this.collideDown = down;\r\n\r\n        this.faceLeft = left;\r\n        this.faceRight = right;\r\n        this.faceTop = up;\r\n        this.faceBottom = down;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set a callback to be called when this tile is hit by an object. The callback must true for\r\n     * collision processing to take place.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollisionCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - Callback function.\r\n     * @param {object} context - Callback will be called within this context.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    setCollisionCallback: function (callback, context)\r\n    {\r\n        if (callback === null)\r\n        {\r\n            this.collisionCallback = undefined;\r\n            this.collisionCallbackContext = undefined;\r\n        }\r\n        else\r\n        {\r\n            this.collisionCallback = callback;\r\n            this.collisionCallbackContext = context;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of the tile and updates its pixelX and pixelY.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileWidth - The width of the tile in pixels.\r\n     * @param {integer} tileHeight - The height of the tile in pixels.\r\n     * @param {integer} baseWidth - The base width a tile in the map (in pixels).\r\n     * @param {integer} baseHeight - The base height of the tile in pixels (in pixels).\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    setSize: function (tileWidth, tileHeight, baseWidth, baseHeight)\r\n    {\r\n        if (tileWidth !== undefined) { this.width = tileWidth; }\r\n        if (tileHeight !== undefined) { this.height = tileHeight; }\r\n        if (baseWidth !== undefined) { this.baseWidth = baseWidth; }\r\n        if (baseHeight !== undefined) { this.baseHeight = baseHeight; }\r\n\r\n        this.updatePixelXY();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Used internally. Updates the tile's world XY position based on the current tile size.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#updatePixelXY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    updatePixelXY: function ()\r\n    {\r\n        // Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile is the\r\n        // bottom left, while the Phaser renderer assumes the origin is the top left. The y\r\n        // coordinate needs to be adjusted by the difference.\r\n        this.pixelX = this.x * this.baseWidth;\r\n        this.pixelY = this.y * this.baseHeight - (this.height - this.baseHeight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces or has a collision callback set.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#canCollide\r\n     * @type {boolean}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    canCollide: {\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collides\r\n     * @type {boolean}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    collides: {\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * True if this tile has any interesting faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#hasInterestingFace\r\n     * @type {boolean}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    hasInterestingFace: {\r\n        get: function ()\r\n        {\r\n            return (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The tileset that contains this Tile. This will only return null if accessed from a LayerData\r\n     * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tileset\r\n     * @type {?Phaser.Tilemaps.Tileset}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    tileset: {\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n            return tilemapLayer ? tilemapLayer.tileset : null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The tilemap layer that contains this Tile. This will only return null if accessed from a\r\n     * LayerData instance before the tile is placed within a StaticTilemapLayer or\r\n     * DynamicTilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemapLayer\r\n     * @type {?Phaser.Tilemaps.StaticTilemapLayer|Phaser.Tilemaps.DynamicTilemapLayer}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    tilemapLayer: {\r\n        get: function ()\r\n        {\r\n            return this.layer.tilemapLayer;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The tilemap that contains this Tile. This will only return null if accessed from a LayerData\r\n     * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemap\r\n     * @type {?Phaser.Tilemaps.Tilemap}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    tilemap: {\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n            return tilemapLayer ? tilemapLayer.tilemap : null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tile;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Class","Components","Rectangle","Tile","Mixins","Alpha","Flip","Visible","initialize","layer","index","x","y","width","height","baseWidth","baseHeight","undefined","pixelY","pixelX","updatePixelXY","properties","rotation","faceBottom","faceTop","faceRight","faceLeft","collideDown","collideUp","collideRight","collideLeft","collisionCallback","collisionCallbackContext","tint","physics","containsPoint","right","bottom","copy","tile","alpha","visible","setFlip","flipX","flipY","getCollisionGroup","tileset","getTileCollisionGroup","getTileData","getLeft","camera","tilemapLayer","tileToWorldX","getRight","scaleX","getTop","tileToWorldY","scaleY","getBottom","getBounds","output","getCenterX","getCenterY","destroy","intersects","isInteresting","collides","faces","canCollide","hasInterestingFace","resetCollision","recalculateFaces","calculateFacesAt","resetFaces","setCollision","left","up","down","setCollisionCallback","callback","context","setSize","tileWidth","tileHeight","get","tilemap"]
}
