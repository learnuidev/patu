shadow$provide.module$node_modules$Phaser$src$physics$arcade$World=function(global,require,module,exports){var Body=require("module$node_modules$Phaser$src$physics$arcade$Body"),Clamp=require("module$node_modules$Phaser$src$math$Clamp");global=require("module$node_modules$Phaser$src$utils$Class");var Collider=require("module$node_modules$Phaser$src$physics$arcade$Collider"),CONST=require("module$node_modules$Phaser$src$physics$arcade$const"),DistanceBetween=require("module$node_modules$Phaser$src$math$distance$DistanceBetween"),
EventEmitter=require("module$node_modules$eventemitter3$index"),FuzzyEqual=require("module$node_modules$Phaser$src$math$fuzzy$Equal"),FuzzyGreaterThan=require("module$node_modules$Phaser$src$math$fuzzy$GreaterThan"),FuzzyLessThan=require("module$node_modules$Phaser$src$math$fuzzy$LessThan"),GetOverlapX=require("module$node_modules$Phaser$src$physics$arcade$GetOverlapX"),GetOverlapY=require("module$node_modules$Phaser$src$physics$arcade$GetOverlapY"),GetValue=require("module$node_modules$Phaser$src$utils$object$GetValue"),
ProcessQueue=require("module$node_modules$Phaser$src$structs$ProcessQueue"),ProcessTileCallbacks=require("module$node_modules$Phaser$src$physics$arcade$tilemap$ProcessTileCallbacks"),Rectangle=require("module$node_modules$Phaser$src$geom$rectangle$Rectangle"),RTree=require("module$node_modules$Phaser$src$structs$RTree"),SeparateTile=require("module$node_modules$Phaser$src$physics$arcade$tilemap$SeparateTile"),SeparateX=require("module$node_modules$Phaser$src$physics$arcade$SeparateX"),SeparateY=require("module$node_modules$Phaser$src$physics$arcade$SeparateY"),
Set=require("module$node_modules$Phaser$src$structs$Set"),StaticBody=require("module$node_modules$Phaser$src$physics$arcade$StaticBody"),TileIntersectsBody=require("module$node_modules$Phaser$src$physics$arcade$tilemap$TileIntersectsBody"),TransformMatrix=require("module$node_modules$Phaser$src$gameobjects$components$TransformMatrix"),Vector2=require("module$node_modules$Phaser$src$math$Vector2"),Wrap=require("module$node_modules$Phaser$src$math$Wrap");require=new global({Extends:EventEmitter,initialize:function(scene,
config){EventEmitter.call(this);this.scene=scene;this.bodies=new Set;this.staticBodies=new Set;this.pendingDestroy=new Set;this.colliders=new ProcessQueue;this.gravity=new Vector2(GetValue(config,"gravity.x",0),GetValue(config,"gravity.y",0));this.bounds=new Rectangle(GetValue(config,"x",0),GetValue(config,"y",0),GetValue(config,"width",scene.sys.game.config.width),GetValue(config,"height",scene.sys.game.config.height));this.checkCollision={up:GetValue(config,"checkCollision.up",!0),down:GetValue(config,
"checkCollision.down",!0),left:GetValue(config,"checkCollision.left",!0),right:GetValue(config,"checkCollision.right",!0)};this.fps=GetValue(config,"fps",60);this._elapsed=0;this._frameTime=1/this.fps;this._frameTimeMS=1E3*this._frameTime;this.stepsLastFrame=0;this.timeScale=GetValue(config,"timeScale",1);this.OVERLAP_BIAS=GetValue(config,"overlapBias",4);this.TILE_BIAS=GetValue(config,"tileBias",16);this.forceX=GetValue(config,"forceX",!1);this.isPaused=GetValue(config,"isPaused",!1);this._total=
0;this.drawDebug=GetValue(config,"debug",!1);this.defaults={debugShowBody:GetValue(config,"debugShowBody",!0),debugShowStaticBody:GetValue(config,"debugShowStaticBody",!0),debugShowVelocity:GetValue(config,"debugShowVelocity",!0),bodyDebugColor:GetValue(config,"debugBodyColor",16711935),staticBodyDebugColor:GetValue(config,"debugStaticBodyColor",255),velocityDebugColor:GetValue(config,"debugVelocityColor",65280)};this.maxEntries=GetValue(config,"maxEntries",16);this.useTree=GetValue(config,"useTree",
!0);this.tree=new RTree(this.maxEntries);this.staticTree=new RTree(this.maxEntries);this.treeMinMax={minX:0,minY:0,maxX:0,maxY:0};this._tempMatrix=new TransformMatrix;this._tempMatrix2=new TransformMatrix;this.drawDebug&&this.createDebugGraphic()},enable:function(object,bodyType){void 0===bodyType&&(bodyType=CONST.DYNAMIC_BODY);Array.isArray(object)||(object=[object]);for(var i=0;i<object.length;i++){var entry=object[i];if(entry.isParent){entry=entry.getChildren();for(var c=0;c<entry.length;c++){var child=
entry[c];child.isParent?this.enable(child,bodyType):this.enableBody(child,bodyType)}}else this.enableBody(entry,bodyType)}},enableBody:function(object,bodyType){void 0===bodyType&&(bodyType=CONST.DYNAMIC_BODY);object.body||(bodyType===CONST.DYNAMIC_BODY?object.body=new Body(this,object):bodyType===CONST.STATIC_BODY&&(object.body=new StaticBody(this,object)));this.add(object.body);return object},add:function(body){body.physicsType===CONST.DYNAMIC_BODY?this.bodies.set(body):body.physicsType===CONST.STATIC_BODY&&
(this.staticBodies.set(body),this.staticTree.insert(body));body.enable=!0;return body},disable:function(object){Array.isArray(object)||(object=[object]);for(var i=0;i<object.length;i++){var entry=object[i];if(entry.isParent){entry=entry.getChildren();for(var c=0;c<entry.length;c++){var child=entry[c];child.isParent?this.disable(child):this.disableBody(child.body)}}else this.disableBody(entry.body)}},disableBody:function(body){this.remove(body);body.enable=!1},remove:function(body){body.physicsType===
CONST.DYNAMIC_BODY?(this.tree.remove(body),this.bodies.delete(body)):body.physicsType===CONST.STATIC_BODY&&(this.staticBodies.delete(body),this.staticTree.remove(body))},createDebugGraphic:function(){var graphic=this.scene.sys.add.graphics({x:0,y:0});graphic.setDepth(Number.MAX_VALUE);this.debugGraphic=graphic;this.drawDebug=!0;return graphic},setBounds:function(x,y,width,height,checkLeft,checkRight,checkUp,checkDown){this.bounds.setTo(x,y,width,height);void 0!==checkLeft&&this.setBoundsCollision(checkLeft,
checkRight,checkUp,checkDown);return this},setBoundsCollision:function(left,right,up,down){void 0===left&&(left=!0);void 0===right&&(right=!0);void 0===up&&(up=!0);void 0===down&&(down=!0);this.checkCollision.left=left;this.checkCollision.right=right;this.checkCollision.up=up;this.checkCollision.down=down;return this},pause:function(){this.isPaused=!0;this.emit("pause");return this},resume:function(){this.isPaused=!1;this.emit("resume");return this},addCollider:function(object1,object2,collideCallback,
processCallback,callbackContext){void 0===collideCallback&&(collideCallback=null);void 0===processCallback&&(processCallback=null);void 0===callbackContext&&(callbackContext=collideCallback);object1=new Collider(this,!1,object1,object2,collideCallback,processCallback,callbackContext);this.colliders.add(object1);return object1},addOverlap:function(object1,object2,collideCallback,processCallback,callbackContext){void 0===collideCallback&&(collideCallback=null);void 0===processCallback&&(processCallback=
null);void 0===callbackContext&&(callbackContext=collideCallback);object1=new Collider(this,!0,object1,object2,collideCallback,processCallback,callbackContext);this.colliders.add(object1);return object1},removeCollider:function(collider){this.colliders.remove(collider);return this},setFPS:function(framerate){this.fps=framerate;this._frameTime=1/this.fps;this._frameTimeMS=1E3*this._frameTime;return this},update:function(time,delta){if(!this.isPaused&&0!==this.bodies.size){time=0;var fixedDelta=this._frameTime,
msPerFrame=this._frameTimeMS*this.timeScale;for(this._elapsed+=delta;this._elapsed>=msPerFrame;)this._elapsed-=msPerFrame,time++,this.step(fixedDelta);this.stepsLastFrame=time}},step:function(delta){var i,bodies=this.bodies.entries,len=bodies.length;for(i=0;i<len;i++){var body=bodies[i];body.enable&&body.update(delta)}this.useTree&&(this.tree.clear(),this.tree.load(bodies));delta=this.colliders.update();for(i=0;i<delta.length;i++)body=delta[i],body.active&&body.update();len=bodies.length;for(i=0;i<
len;i++)body=bodies[i],body.enable&&body.postUpdate()},postUpdate:function(){var i,dynamic=this.bodies,staticBodies=this.staticBodies,pending=this.pendingDestroy,bodies=dynamic.entries,len=bodies.length;if(this.drawDebug){var graphics=this.debugGraphic;graphics.clear();for(i=0;i<len;i++){var body=bodies[i];body.willDrawDebug()&&body.drawDebug(graphics)}bodies=staticBodies.entries;len=bodies.length;for(i=0;i<len;i++)body=bodies[i],body.willDrawDebug()&&body.drawDebug(graphics)}if(0<pending.size){graphics=
this.tree;var staticTree=this.staticTree;bodies=pending.entries;len=bodies.length;for(i=0;i<len;i++)body=bodies[i],body.physicsType===CONST.DYNAMIC_BODY?(graphics.remove(body),dynamic.delete(body)):body.physicsType===CONST.STATIC_BODY&&(staticTree.remove(body),staticBodies.delete(body)),body.world=void 0,body.gameObject=void 0;pending.clear()}},updateMotion:function(body,delta){body.allowRotation&&this.computeAngularVelocity(body,delta);this.computeVelocity(body,delta)},computeAngularVelocity:function(body,
delta){var velocity=body.angularVelocity,acceleration=body.angularAcceleration,drag=body.angularDrag,max=body.maxAngular;acceleration?velocity+=acceleration*delta:body.allowDrag&&drag&&(drag*=delta,velocity=FuzzyGreaterThan(velocity-drag,0,.1)?velocity-drag:FuzzyLessThan(velocity+drag,0,.1)?velocity+drag:0);velocity=Clamp(velocity,-max,max);body.angularVelocity+=velocity-body.angularVelocity;body.rotation+=body.angularVelocity*delta},computeVelocity:function(body,delta){var velocityX=body.velocity.x,
accelerationX=body.acceleration.x,dragX=body.drag.x,maxX=body.maxVelocity.x,velocityY=body.velocity.y,accelerationY=body.acceleration.y,dragY=body.drag.y,maxY=body.maxVelocity.y,speed=body.speed,allowDrag=body.allowDrag,useDamping=body.useDamping;body.allowGravity&&(velocityX+=(this.gravity.x+body.gravity.x)*delta,velocityY+=(this.gravity.y+body.gravity.y)*delta);accelerationX?velocityX+=accelerationX*delta:allowDrag&&dragX&&(useDamping?(velocityX*=dragX,FuzzyEqual(speed,0,.001)&&(velocityX=0)):(dragX*=
delta,velocityX=FuzzyGreaterThan(velocityX-dragX,0,.01)?velocityX-dragX:FuzzyLessThan(velocityX+dragX,0,.01)?velocityX+dragX:0));accelerationY?velocityY+=accelerationY*delta:allowDrag&&dragY&&(useDamping?(velocityY*=dragY,FuzzyEqual(speed,0,.001)&&(velocityY=0)):(dragY*=delta,velocityY=FuzzyGreaterThan(velocityY-dragY,0,.01)?velocityY-dragY:FuzzyLessThan(velocityY+dragY,0,.01)?velocityY+dragY:0));velocityX=Clamp(velocityX,-maxX,maxX);velocityY=Clamp(velocityY,-maxY,maxY);body.velocity.set(velocityX,
velocityY)},separate:function(body1,body2,processCallback,callbackContext,overlapOnly){if(!body1.enable||!body2.enable||body1.checkCollision.none||body2.checkCollision.none||!this.intersects(body1,body2)||processCallback&&!1===processCallback.call(callbackContext,body1.gameObject,body2.gameObject))return!1;if(body1.isCircle&&body2.isCircle)return this.separateCircle(body1,body2,overlapOnly);if(body1.isCircle!==body2.isCircle){processCallback=body1.isCircle?body2:body1;callbackContext=processCallback.x;
var JSCompiler_object_inline_right_1361=processCallback.right,JSCompiler_object_inline_bottom_1362=processCallback.bottom,circle=(body1.isCircle?body1:body2).center;if(circle.y<processCallback.y||circle.y>JSCompiler_object_inline_bottom_1362)if(circle.x<callbackContext||circle.x>JSCompiler_object_inline_right_1361)return this.separateCircle(body1,body2,overlapOnly)}callbackContext=processCallback=!1;this.forceX||Math.abs(this.gravity.y+body1.gravity.y)<Math.abs(this.gravity.x+body1.gravity.x)?(processCallback=
SeparateX(body1,body2,overlapOnly,this.OVERLAP_BIAS),this.intersects(body1,body2)&&(callbackContext=SeparateY(body1,body2,overlapOnly,this.OVERLAP_BIAS))):(callbackContext=SeparateY(body1,body2,overlapOnly,this.OVERLAP_BIAS),this.intersects(body1,body2)&&(processCallback=SeparateX(body1,body2,overlapOnly,this.OVERLAP_BIAS)));if(processCallback=processCallback||callbackContext)overlapOnly&&(body1.onOverlap||body2.onOverlap)?this.emit("overlap",body1.gameObject,body2.gameObject,body1,body2):(body1.postUpdate(),
body2.postUpdate(),(body1.onCollide||body2.onCollide)&&this.emit("collide",body1.gameObject,body2.gameObject,body1,body2));return processCallback},separateCircle:function(body1,body2,overlapOnly,bias){GetOverlapX(body1,body2,!1,bias);GetOverlapY(body1,body2,!1,bias);bias=Math.atan2(body2.center.y-body1.center.y,body2.center.x-body1.center.x);var overlap=0;if(body1.isCircle!==body2.isCircle){var JSCompiler_object_inline_x_1363=body2.isCircle?body1.position.x:body2.position.x,JSCompiler_object_inline_y_1364=
body2.isCircle?body1.position.y:body2.position.y,JSCompiler_object_inline_right_1365=body2.isCircle?body1.right:body2.right,JSCompiler_object_inline_bottom_1366=body2.isCircle?body1.bottom:body2.bottom,JSCompiler_object_inline_x_1367=body1.isCircle?body1.center.x:body2.center.x,JSCompiler_object_inline_y_1368=body1.isCircle?body1.center.y:body2.center.y,JSCompiler_object_inline_radius_1369=body1.isCircle?body1.halfWidth:body2.halfWidth;JSCompiler_object_inline_y_1368<JSCompiler_object_inline_y_1364?
JSCompiler_object_inline_x_1367<JSCompiler_object_inline_x_1363?overlap=DistanceBetween(JSCompiler_object_inline_x_1367,JSCompiler_object_inline_y_1368,JSCompiler_object_inline_x_1363,JSCompiler_object_inline_y_1364)-JSCompiler_object_inline_radius_1369:JSCompiler_object_inline_x_1367>JSCompiler_object_inline_right_1365&&(overlap=DistanceBetween(JSCompiler_object_inline_x_1367,JSCompiler_object_inline_y_1368,JSCompiler_object_inline_right_1365,JSCompiler_object_inline_y_1364)-JSCompiler_object_inline_radius_1369):
JSCompiler_object_inline_y_1368>JSCompiler_object_inline_bottom_1366&&(JSCompiler_object_inline_x_1367<JSCompiler_object_inline_x_1363?overlap=DistanceBetween(JSCompiler_object_inline_x_1367,JSCompiler_object_inline_y_1368,JSCompiler_object_inline_x_1363,JSCompiler_object_inline_bottom_1366)-JSCompiler_object_inline_radius_1369:JSCompiler_object_inline_x_1367>JSCompiler_object_inline_right_1365&&(overlap=DistanceBetween(JSCompiler_object_inline_x_1367,JSCompiler_object_inline_y_1368,JSCompiler_object_inline_right_1365,
JSCompiler_object_inline_bottom_1366)-JSCompiler_object_inline_radius_1369));overlap*=-1}else overlap=body1.halfWidth+body2.halfWidth-DistanceBetween(body1.center.x,body1.center.y,body2.center.x,body2.center.y);if(overlapOnly||0===overlap||body1.immovable&&body2.immovable||body1.customSeparateX||body2.customSeparateX)return 0!==overlap&&(body1.onOverlap||body2.onOverlap)&&this.emit("overlap",body1.gameObject,body2.gameObject,body1,body2),0!==overlap;overlapOnly=body1.velocity.x;JSCompiler_object_inline_x_1363=
body1.velocity.y;JSCompiler_object_inline_radius_1369=body1.mass;JSCompiler_object_inline_y_1364=body2.velocity.x;JSCompiler_object_inline_right_1365=body2.velocity.y;var b2mass=body2.mass,JSCompiler_object_inline_x_1370=overlapOnly*Math.cos(bias)+JSCompiler_object_inline_x_1363*Math.sin(bias);JSCompiler_object_inline_bottom_1366=overlapOnly*Math.sin(bias)-JSCompiler_object_inline_x_1363*Math.cos(bias);var JSCompiler_object_inline_x_1372=JSCompiler_object_inline_y_1364*Math.cos(bias)+JSCompiler_object_inline_right_1365*
Math.sin(bias);JSCompiler_object_inline_x_1367=JSCompiler_object_inline_y_1364*Math.sin(bias)-JSCompiler_object_inline_right_1365*Math.cos(bias);JSCompiler_object_inline_y_1368=((JSCompiler_object_inline_radius_1369-b2mass)*JSCompiler_object_inline_x_1370+2*b2mass*JSCompiler_object_inline_x_1372)/(JSCompiler_object_inline_radius_1369+b2mass);JSCompiler_object_inline_radius_1369=(2*JSCompiler_object_inline_radius_1369*JSCompiler_object_inline_x_1370+(b2mass-JSCompiler_object_inline_radius_1369)*JSCompiler_object_inline_x_1372)/
(JSCompiler_object_inline_radius_1369+b2mass);body1.immovable||(body1.velocity.x=(JSCompiler_object_inline_y_1368*Math.cos(bias)-JSCompiler_object_inline_bottom_1366*Math.sin(bias))*body1.bounce.x,body1.velocity.y=(JSCompiler_object_inline_bottom_1366*Math.cos(bias)+JSCompiler_object_inline_y_1368*Math.sin(bias))*body1.bounce.y,overlapOnly=body1.velocity.x,JSCompiler_object_inline_x_1363=body1.velocity.y);body2.immovable||(body2.velocity.x=(JSCompiler_object_inline_radius_1369*Math.cos(bias)-JSCompiler_object_inline_x_1367*
Math.sin(bias))*body2.bounce.x,body2.velocity.y=(JSCompiler_object_inline_x_1367*Math.cos(bias)+JSCompiler_object_inline_radius_1369*Math.sin(bias))*body2.bounce.y,JSCompiler_object_inline_y_1364=body2.velocity.x,JSCompiler_object_inline_right_1365=body2.velocity.y);Math.abs(bias)<Math.PI/2?0<overlapOnly&&!body1.immovable&&JSCompiler_object_inline_y_1364>overlapOnly?body1.velocity.x*=-1:0>JSCompiler_object_inline_y_1364&&!body2.immovable&&overlapOnly<JSCompiler_object_inline_y_1364?body2.velocity.x*=
-1:0<JSCompiler_object_inline_x_1363&&!body1.immovable&&JSCompiler_object_inline_right_1365>JSCompiler_object_inline_x_1363?body1.velocity.y*=-1:0>JSCompiler_object_inline_right_1365&&!body2.immovable&&JSCompiler_object_inline_x_1363<JSCompiler_object_inline_right_1365&&(body2.velocity.y*=-1):Math.abs(bias)>Math.PI/2&&(0>overlapOnly&&!body1.immovable&&JSCompiler_object_inline_y_1364<overlapOnly?body1.velocity.x*=-1:0<JSCompiler_object_inline_y_1364&&!body2.immovable&&overlapOnly>JSCompiler_object_inline_y_1364?
body2.velocity.x*=-1:0>JSCompiler_object_inline_x_1363&&!body1.immovable&&JSCompiler_object_inline_right_1365<JSCompiler_object_inline_x_1363?body1.velocity.y*=-1:0<JSCompiler_object_inline_right_1365&&!body2.immovable&&overlapOnly>JSCompiler_object_inline_right_1365&&(body2.velocity.y*=-1));overlapOnly=this._frameTime;body1.immovable||(body1.x+=body1.velocity.x*overlapOnly-overlap*Math.cos(bias),body1.y+=body1.velocity.y*overlapOnly-overlap*Math.sin(bias));body2.immovable||(body2.x+=body2.velocity.x*
overlapOnly+overlap*Math.cos(bias),body2.y+=body2.velocity.y*overlapOnly+overlap*Math.sin(bias));(body1.onCollide||body2.onCollide)&&this.emit("collide",body1.gameObject,body2.gameObject,body1,body2);body1.postUpdate();body2.postUpdate();return!0},intersects:function(body1,body2){return body1===body2?!1:body1.isCircle||body2.isCircle?body1.isCircle?body2.isCircle?DistanceBetween(body1.center.x,body1.center.y,body2.center.x,body2.center.y)<=body1.halfWidth+body2.halfWidth:this.circleBodyIntersects(body1,
body2):this.circleBodyIntersects(body2,body1):!(body1.right<=body2.position.x||body1.bottom<=body2.position.y||body1.position.x>=body2.right||body1.position.y>=body2.bottom)},circleBodyIntersects:function(circle,body){var x=Clamp(circle.center.x,body.left,body.right);body=Clamp(circle.center.y,body.top,body.bottom);return(circle.center.x-x)*(circle.center.x-x)+(circle.center.y-body)*(circle.center.y-body)<=circle.halfWidth*circle.halfWidth},overlap:function(object1,object2,overlapCallback,processCallback,
callbackContext){void 0===overlapCallback&&(overlapCallback=null);void 0===processCallback&&(processCallback=null);void 0===callbackContext&&(callbackContext=overlapCallback);return this.collideObjects(object1,object2,overlapCallback,processCallback,callbackContext,!0)},collide:function(object1,object2,collideCallback,processCallback,callbackContext){void 0===collideCallback&&(collideCallback=null);void 0===processCallback&&(processCallback=null);void 0===callbackContext&&(callbackContext=collideCallback);
return this.collideObjects(object1,object2,collideCallback,processCallback,callbackContext,!1)},collideObjects:function(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly){object1.isParent&&void 0===object1.physicsType&&(object1=object1.children.entries);object2&&object2.isParent&&void 0===object2.physicsType&&(object2=object2.children.entries);var i=Array.isArray(object1);var object2isArray=Array.isArray(object2);this._total=0;if(i||object2isArray)if(!i&&object2isArray)for(i=
0;i<object2.length;i++)this.collideHandler(object1,object2[i],collideCallback,processCallback,callbackContext,overlapOnly);else if(i&&!object2isArray)for(i=0;i<object1.length;i++)this.collideHandler(object1[i],object2,collideCallback,processCallback,callbackContext,overlapOnly);else for(i=0;i<object1.length;i++)for(object2isArray=0;object2isArray<object2.length;object2isArray++)this.collideHandler(object1[i],object2[object2isArray],collideCallback,processCallback,callbackContext,overlapOnly);else this.collideHandler(object1,
object2,collideCallback,processCallback,callbackContext,overlapOnly);return 0<this._total},collideHandler:function(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly){if(void 0===object2&&object1.isParent)return this.collideGroupVsGroup(object1,object1,collideCallback,processCallback,callbackContext,overlapOnly);if(!object1||!object2)return!1;if(object1.body){if(object2.body)return this.collideSpriteVsSprite(object1,object2,collideCallback,processCallback,callbackContext,
overlapOnly);if(object2.isParent)return this.collideSpriteVsGroup(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly);if(object2.isTilemap)return this.collideSpriteVsTilemapLayer(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly)}else if(object1.isParent){if(object2.body)return this.collideSpriteVsGroup(object2,object1,collideCallback,processCallback,callbackContext,overlapOnly);if(object2.isParent)return this.collideGroupVsGroup(object1,object2,
collideCallback,processCallback,callbackContext,overlapOnly);if(object2.isTilemap)return this.collideGroupVsTilemapLayer(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly)}else if(object1.isTilemap){if(object2.body)return this.collideSpriteVsTilemapLayer(object2,object1,collideCallback,processCallback,callbackContext,overlapOnly);if(object2.isParent)return this.collideGroupVsTilemapLayer(object2,object1,collideCallback,processCallback,callbackContext,overlapOnly)}},collideSpriteVsSprite:function(sprite1,
sprite2,collideCallback,processCallback,callbackContext,overlapOnly){if(!sprite1.body||!sprite2.body)return!1;this.separate(sprite1.body,sprite2.body,processCallback,callbackContext,overlapOnly)&&(collideCallback&&collideCallback.call(callbackContext,sprite1,sprite2),this._total++);return!0},collideSpriteVsGroup:function(sprite,group,collideCallback,processCallback,callbackContext,overlapOnly){var bodyA=sprite.body;if(0!==group.length&&bodyA&&bodyA.enable)if(this.useTree){sprite=this.treeMinMax;sprite.minX=
bodyA.left;sprite.minY=bodyA.top;sprite.maxX=bodyA.right;sprite.maxY=bodyA.bottom;var results=group.physicsType===CONST.DYNAMIC_BODY?this.tree.search(sprite):this.staticTree.search(sprite);var len=results.length;for(sprite=0;sprite<len;sprite++){var bodyB=results[sprite];bodyA!==bodyB&&group.contains(bodyB.gameObject)&&this.separate(bodyA,bodyB,processCallback,callbackContext,overlapOnly)&&(collideCallback&&collideCallback.call(callbackContext,bodyA.gameObject,bodyB.gameObject),this._total++)}}else for(results=
group.getChildren(),group=group.children.entries.indexOf(sprite),len=results.length,sprite=0;sprite<len;sprite++)(bodyB=results[sprite].body)&&sprite!==group&&bodyB.enable&&this.separate(bodyA,bodyB,processCallback,callbackContext,overlapOnly)&&(collideCallback&&collideCallback.call(callbackContext,bodyA.gameObject,bodyB.gameObject),this._total++)},collideGroupVsTilemapLayer:function(group,tilemapLayer,collideCallback,processCallback,callbackContext,overlapOnly){group=group.getChildren();if(0===group.length)return!1;
for(var didCollide=!1,i=0;i<group.length;i++)group[i].body&&this.collideSpriteVsTilemapLayer(group[i],tilemapLayer,collideCallback,processCallback,callbackContext,overlapOnly)&&(didCollide=!0);return didCollide},collideSpriteVsTilemapLayer:function(sprite,tilemapLayer,collideCallback,processCallback,callbackContext,overlapOnly){var body=sprite.body;if(!body.enable)return!1;var x=body.position.x,y=body.position.y,w=body.width,h=body.height,layerData=tilemapLayer.layer;if(layerData.tileWidth>layerData.baseTileWidth){var xDiff=
(layerData.tileWidth-layerData.baseTileWidth)*tilemapLayer.scaleX;x-=xDiff;w+=xDiff}layerData.tileHeight>layerData.baseTileHeight&&(h+=(layerData.tileHeight-layerData.baseTileHeight)*tilemapLayer.scaleY);x=tilemapLayer.getTilesWithinWorldXY(x,y,w,h);if(0===x.length)return!1;w={left:0,right:0,top:0,bottom:0};for(h=0;h<x.length;h++)y=x[h],w.left=tilemapLayer.tileToWorldX(y.x),w.top=tilemapLayer.tileToWorldY(y.y),y.baseHeight!==y.height&&(w.top-=(y.height-y.baseHeight)*tilemapLayer.scaleY),w.right=w.left+
y.width*tilemapLayer.scaleX,w.bottom=w.top+y.height*tilemapLayer.scaleY,TileIntersectsBody(w,body)&&(!processCallback||processCallback.call(callbackContext,sprite,y))&&ProcessTileCallbacks(y,sprite)&&(overlapOnly||SeparateTile(h,body,y,w,tilemapLayer,this.TILE_BIAS))&&(this._total++,collideCallback&&collideCallback.call(callbackContext,sprite,y),overlapOnly&&body.onOverlap?sprite.emit("overlap",body.gameObject,y,body,null):body.onCollide&&sprite.emit("collide",body.gameObject,y,body,null),body.postUpdate())},
collideGroupVsGroup:function(group1,group2,collideCallback,processCallback,callbackContext,overlapOnly){if(0!==group1.length&&0!==group2.length){group1=group1.getChildren();for(var i=0;i<group1.length;i++)this.collideSpriteVsGroup(group1[i],group2,collideCallback,processCallback,callbackContext,overlapOnly)}},wrap:function(object,padding){object.body?this.wrapObject(object,padding):object.getChildren?this.wrapArray(object.getChildren(),padding):Array.isArray(object)?this.wrapArray(object,padding):
this.wrapObject(object,padding)},wrapArray:function(objects,padding){for(var i=0;i<objects.length;i++)this.wrapObject(objects[i],padding)},wrapObject:function(object,padding){void 0===padding&&(padding=0);object.x=Wrap(object.x,this.bounds.left-padding,this.bounds.right+padding);object.y=Wrap(object.y,this.bounds.top-padding,this.bounds.bottom+padding)},shutdown:function(){this.tree.clear();this.staticTree.clear();this.bodies.clear();this.staticBodies.clear();this.colliders.destroy();this.removeAllListeners()},
destroy:function(){this.shutdown();this.scene=null}});module.exports=require}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$arcade$World.js.map
