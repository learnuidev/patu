{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$lib$collision$SAT.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/matter-js/lib/collision/SAT.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$lib$collision$SAT\"] = function(global,require,module,exports) {\n/**\r\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\r\n*\r\n* @class SAT\r\n*/\r\n\r\n// TODO: true circles and curves\r\n\r\nvar SAT = {};\r\n\r\nmodule.exports = SAT;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Vector = require('../geometry/Vector');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Detect collision between two bodies using the Separating Axis Theorem.\r\n     * @method collides\r\n     * @param {body} bodyA\r\n     * @param {body} bodyB\r\n     * @param {collision} previousCollision\r\n     * @return {collision} collision\r\n     */\r\n    SAT.collides = function(bodyA, bodyB, previousCollision) {\r\n        var overlapAB,\r\n            overlapBA, \r\n            minOverlap,\r\n            collision,\r\n            canReusePrevCol = false;\r\n\r\n        if (previousCollision) {\r\n            // estimate total motion\r\n            var parentA = bodyA.parent,\r\n                parentB = bodyB.parent,\r\n                motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed\r\n                       + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;\r\n\r\n            // we may be able to (partially) reuse collision result \r\n            // but only safe if collision was resting\r\n            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;\r\n\r\n            // reuse collision object\r\n            collision = previousCollision;\r\n        } else {\r\n            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };\r\n        }\r\n\r\n        if (previousCollision && canReusePrevCol) {\r\n            // if we can reuse the collision result\r\n            // we only need to test the previously found axis\r\n            var axisBodyA = collision.axisBody,\r\n                axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,\r\n                axes = [axisBodyA.axes[previousCollision.axisNumber]];\r\n\r\n            minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);\r\n            collision.reused = true;\r\n\r\n            if (minOverlap.overlap <= 0) {\r\n                collision.collided = false;\r\n                return collision;\r\n            }\r\n        } else {\r\n            // if we can't reuse a result, perform a full SAT test\r\n\r\n            overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);\r\n\r\n            if (overlapAB.overlap <= 0) {\r\n                collision.collided = false;\r\n                return collision;\r\n            }\r\n\r\n            overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);\r\n\r\n            if (overlapBA.overlap <= 0) {\r\n                collision.collided = false;\r\n                return collision;\r\n            }\r\n\r\n            if (overlapAB.overlap < overlapBA.overlap) {\r\n                minOverlap = overlapAB;\r\n                collision.axisBody = bodyA;\r\n            } else {\r\n                minOverlap = overlapBA;\r\n                collision.axisBody = bodyB;\r\n            }\r\n\r\n            // important for reuse later\r\n            collision.axisNumber = minOverlap.axisNumber;\r\n        }\r\n\r\n        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\r\n        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\r\n        collision.collided = true;\r\n        collision.depth = minOverlap.overlap;\r\n        collision.parentA = collision.bodyA.parent;\r\n        collision.parentB = collision.bodyB.parent;\r\n        \r\n        bodyA = collision.bodyA;\r\n        bodyB = collision.bodyB;\r\n\r\n        // ensure normal is facing away from bodyA\r\n        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {\r\n            collision.normal = {\r\n                x: minOverlap.axis.x,\r\n                y: minOverlap.axis.y\r\n            };\r\n        } else {\r\n            collision.normal = {\r\n                x: -minOverlap.axis.x,\r\n                y: -minOverlap.axis.y\r\n            };\r\n        }\r\n\r\n        collision.tangent = Vector.perp(collision.normal);\r\n\r\n        collision.penetration = collision.penetration || {};\r\n        collision.penetration.x = collision.normal.x * collision.depth;\r\n        collision.penetration.y = collision.normal.y * collision.depth; \r\n\r\n        // find support points, there is always either exactly one or two\r\n        var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal),\r\n            supports = [];\r\n\r\n        // find the supports from bodyB that are inside bodyA\r\n        if (Vertices.contains(bodyA.vertices, verticesB[0]))\r\n            supports.push(verticesB[0]);\r\n\r\n        if (Vertices.contains(bodyA.vertices, verticesB[1]))\r\n            supports.push(verticesB[1]);\r\n\r\n        // find the supports from bodyA that are inside bodyB\r\n        if (supports.length < 2) {\r\n            var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));\r\n                \r\n            if (Vertices.contains(bodyB.vertices, verticesA[0]))\r\n                supports.push(verticesA[0]);\r\n\r\n            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))\r\n                supports.push(verticesA[1]);\r\n        }\r\n\r\n        // account for the edge case of overlapping but no vertex containment\r\n        if (supports.length < 1)\r\n            supports = [verticesB[0]];\r\n        \r\n        collision.supports = supports;\r\n\r\n        return collision;\r\n    };\r\n\r\n    /**\r\n     * Find the overlap between two sets of vertices.\r\n     * @method _overlapAxes\r\n     * @private\r\n     * @param {} verticesA\r\n     * @param {} verticesB\r\n     * @param {} axes\r\n     * @return result\r\n     */\r\n    SAT._overlapAxes = function(verticesA, verticesB, axes) {\r\n        var projectionA = Vector._temp[0], \r\n            projectionB = Vector._temp[1],\r\n            result = { overlap: Number.MAX_VALUE },\r\n            overlap,\r\n            axis;\r\n\r\n        for (var i = 0; i < axes.length; i++) {\r\n            axis = axes[i];\r\n\r\n            SAT._projectToAxis(projectionA, verticesA, axis);\r\n            SAT._projectToAxis(projectionB, verticesB, axis);\r\n\r\n            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\r\n\r\n            if (overlap <= 0) {\r\n                result.overlap = overlap;\r\n                return result;\r\n            }\r\n\r\n            if (overlap < result.overlap) {\r\n                result.overlap = overlap;\r\n                result.axis = axis;\r\n                result.axisNumber = i;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Projects vertices on an axis and returns an interval.\r\n     * @method _projectToAxis\r\n     * @private\r\n     * @param {} projection\r\n     * @param {} vertices\r\n     * @param {} axis\r\n     */\r\n    SAT._projectToAxis = function(projection, vertices, axis) {\r\n        var min = Vector.dot(vertices[0], axis),\r\n            max = min;\r\n\r\n        for (var i = 1; i < vertices.length; i += 1) {\r\n            var dot = Vector.dot(vertices[i], axis);\r\n\r\n            if (dot > max) { \r\n                max = dot; \r\n            } else if (dot < min) { \r\n                min = dot; \r\n            }\r\n        }\r\n\r\n        projection.min = min;\r\n        projection.max = max;\r\n    };\r\n    \r\n    /**\r\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\r\n     * @method _findSupports\r\n     * @private\r\n     * @param {} bodyA\r\n     * @param {} bodyB\r\n     * @param {} normal\r\n     * @return [vector]\r\n     */\r\n    SAT._findSupports = function(bodyA, bodyB, normal) {\r\n        var nearestDistance = Number.MAX_VALUE,\r\n            vertexToBody = Vector._temp[0],\r\n            vertices = bodyB.vertices,\r\n            bodyAPosition = bodyA.position,\r\n            distance,\r\n            vertex,\r\n            vertexA,\r\n            vertexB;\r\n\r\n        // find closest vertex on bodyB\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            vertex = vertices[i];\r\n            vertexToBody.x = vertex.x - bodyAPosition.x;\r\n            vertexToBody.y = vertex.y - bodyAPosition.y;\r\n            distance = -Vector.dot(normal, vertexToBody);\r\n\r\n            if (distance < nearestDistance) {\r\n                nearestDistance = distance;\r\n                vertexA = vertex;\r\n            }\r\n        }\r\n\r\n        // find next closest vertex using the two connected to it\r\n        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;\r\n        vertex = vertices[prevIndex];\r\n        vertexToBody.x = vertex.x - bodyAPosition.x;\r\n        vertexToBody.y = vertex.y - bodyAPosition.y;\r\n        nearestDistance = -Vector.dot(normal, vertexToBody);\r\n        vertexB = vertex;\r\n\r\n        var nextIndex = (vertexA.index + 1) % vertices.length;\r\n        vertex = vertices[nextIndex];\r\n        vertexToBody.x = vertex.x - bodyAPosition.x;\r\n        vertexToBody.y = vertex.y - bodyAPosition.y;\r\n        distance = -Vector.dot(normal, vertexToBody);\r\n        if (distance < nearestDistance) {\r\n            vertexB = vertex;\r\n        }\r\n\r\n        return [vertexA, vertexB];\r\n    };\r\n\r\n})();\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","SAT","Vertices","Vector","collides","SAT.collides","bodyA","bodyB","previousCollision","canReusePrevCol","parentA","parent","parentB","motion","speed","angularSpeed","collided","collision","axisBodyA","axisBody","minOverlap","_overlapAxes","vertices","axisBodyB","axes","axisNumber","reused","overlap","overlapAB","overlapBA","id","depth","dot","axis","sub","position","normal","x","y","tangent","perp","penetration","verticesB","_findSupports","supports","contains","push","length","verticesA","neg","SAT._overlapAxes","projectionA","_temp","projectionB","result","Number","MAX_VALUE","i","_projectToAxis","Math","min","max","SAT._projectToAxis","projection","SAT._findSupports","nearestDistance","vertexToBody","bodyAPosition","vertexB","vertex","distance","vertexA","prevIndex","index"]
}
