{
"version":3,
"file":"module$node_modules$Phaser$src$animations$Animation.js",
"lineCount":16,
"mappings":"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",
"sources":["node_modules/Phaser/src/animations/Animation.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$animations$Animation\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Clamp = require('../math/Clamp');\r\nvar Class = require('../utils/Class');\r\nvar FindClosestInSorted = require('../utils/array/FindClosestInSorted');\r\nvar Frame = require('./AnimationFrame');\r\nvar GetValue = require('../utils/object/GetValue');\r\n\r\n/**\r\n * @typedef {object} JSONAnimation\r\n *\r\n * @property {string} key - The key that the animation will be associated with. i.e. sprite.animations.play(key)\r\n * @property {string} type - A frame based animation (as opposed to a bone based animation)\r\n * @property {JSONAnimationFrame[]} frames - [description]\r\n * @property {integer} frameRate - The frame rate of playback in frames per second (default 24 if duration is null)\r\n * @property {integer} duration - How long the animation should play for in milliseconds. If not given its derived from frameRate.\r\n * @property {boolean} skipMissedFrames - Skip frames if the time lags, or always advanced anyway?\r\n * @property {integer} delay - Delay before starting playback. Value given in milliseconds.\r\n * @property {integer} repeat - Number of times to repeat the animation (-1 for infinity)\r\n * @property {integer} repeatDelay - Delay before the animation repeats. Value given in milliseconds.\r\n * @property {boolean} yoyo - Should the animation yoyo? (reverse back down to the start) before repeating?\r\n * @property {boolean} showOnStart - Should sprite.visible = true when the animation starts to play?\r\n * @property {boolean} hideOnComplete - Should sprite.visible = false when the animation finishes?\r\n */\r\n\r\n/**\r\n * @typedef {object} AnimationFrameConfig\r\n *\r\n * @property {string} key - The key that the animation will be associated with. i.e. sprite.animations.play(key)\r\n * @property {(string|number)} frame - [description]\r\n * @property {number} [duration=0] - [description]\r\n * @property {boolean} [visible] - [description]\r\n */\r\n\r\n/**\r\n * @typedef {object} AnimationConfig\r\n *\r\n * @property {string} [key] - The key that the animation will be associated with. i.e. sprite.animations.play(key)\r\n * @property {AnimationFrameConfig[]} [frames] - An object containing data used to generate the frames for the animation\r\n * @property {string} [defaultTextureKey=null] - The key of the texture all frames of the animation will use. Can be overridden on a per frame basis.\r\n * @property {integer} [frameRate] - The frame rate of playback in frames per second (default 24 if duration is null)\r\n * @property {integer} [duration] - How long the animation should play for in milliseconds. If not given its derived from frameRate.\r\n * @property {boolean} [skipMissedFrames=true] - Skip frames if the time lags, or always advanced anyway?\r\n * @property {integer} [delay=0] - Delay before starting playback. Value given in milliseconds.\r\n * @property {integer} [repeat=0] - Number of times to repeat the animation (-1 for infinity)\r\n * @property {integer} [repeatDelay=0] - Delay before the animation repeats. Value given in milliseconds.\r\n * @property {boolean} [yoyo=false] - Should the animation yoyo? (reverse back down to the start) before repeating?\r\n * @property {boolean} [showOnStart=false] - Should sprite.visible = true when the animation starts to play?\r\n * @property {boolean} [hideOnComplete=false] - Should sprite.visible = false when the animation finishes?\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Frame based Animation.\r\n *\r\n * This consists of a key, some default values (like the frame rate) and a bunch of Frame objects.\r\n *\r\n * The Animation Manager creates these. Game Objects don't own an instance of these directly.\r\n * Game Objects have the Animation Component, which are like playheads to global Animations (these objects)\r\n * So multiple Game Objects can have playheads all pointing to this one Animation instance.\r\n *\r\n * @class Animation\r\n * @memberOf Phaser.Animations\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Animations.AnimationManager} manager - [description]\r\n * @param {string} key - [description]\r\n * @param {AnimationConfig} config - [description]\r\n */\r\nvar Animation = new Class({\r\n\r\n    initialize:\r\n\r\n    function Animation (manager, key, config)\r\n    {\r\n        /**\r\n         * A reference to the global Animation Manager\r\n         *\r\n         * @name Phaser.Animations.Animation#manager\r\n         * @type {Phaser.Animations.AnimationManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = manager;\r\n\r\n        /**\r\n         * The unique identifying string for this animation\r\n         *\r\n         * @name Phaser.Animations.Animation#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = key;\r\n\r\n        /**\r\n         * A frame based animation (as opposed to a bone based animation)\r\n         *\r\n         * @name Phaser.Animations.Animation#type\r\n         * @type {string}\r\n         * @default frame\r\n         * @since 3.0.0\r\n         */\r\n        this.type = 'frame';\r\n\r\n        /**\r\n         * Extract all the frame data into the frames array\r\n         *\r\n         * @name Phaser.Animations.Animation#frames\r\n         * @type {Phaser.Animations.AnimationFrame[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.frames = this.getFrames(\r\n            manager.textureManager,\r\n            GetValue(config, 'frames', []),\r\n            GetValue(config, 'defaultTextureKey', null)\r\n        );\r\n\r\n        /**\r\n         * The frame rate of playback in frames per second (default 24 if duration is null)\r\n         *\r\n         * @name Phaser.Animations.Animation#frameRate\r\n         * @type {integer}\r\n         * @default 24\r\n         * @since 3.0.0\r\n         */\r\n        this.frameRate = GetValue(config, 'frameRate', null);\r\n\r\n        /**\r\n         * How long the animation should play for, in milliseconds.\r\n         * If the `frameRate` property has been set then it overrides this value,\r\n         * otherwise the `frameRate` is derived from `duration`.\r\n         *\r\n         * @name Phaser.Animations.Animation#duration\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.duration = GetValue(config, 'duration', null);\r\n\r\n        if (this.duration === null && this.frameRate === null)\r\n        {\r\n            //  No duration or frameRate given, use default frameRate of 24fps\r\n            this.frameRate = 24;\r\n            this.duration = (this.frameRate / this.frames.length) * 1000;\r\n        }\r\n        else if (this.duration && this.frameRate === null)\r\n        {\r\n            //  Duration given but no frameRate, so set the frameRate based on duration\r\n            //  I.e. 12 frames in the animation, duration = 4000 ms\r\n            //  So frameRate is 12 / (4000 / 1000) = 3 fps\r\n            this.frameRate = this.frames.length / (this.duration / 1000);\r\n        }\r\n        else\r\n        {\r\n            //  frameRate given, derive duration from it (even if duration also specified)\r\n            //  I.e. 15 frames in the animation, frameRate = 30 fps\r\n            //  So duration is 15 / 30 = 0.5 * 1000 (half a second, or 500ms)\r\n            this.duration = (this.frames.length / this.frameRate) * 1000;\r\n        }\r\n\r\n        /**\r\n         * How many ms per frame, not including frame specific modifiers.\r\n         *\r\n         * @name Phaser.Animations.Animation#msPerFrame\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.msPerFrame = 1000 / this.frameRate;\r\n\r\n        /**\r\n         * Skip frames if the time lags, or always advanced anyway?\r\n         *\r\n         * @name Phaser.Animations.Animation#skipMissedFrames\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.skipMissedFrames = GetValue(config, 'skipMissedFrames', true);\r\n\r\n        /**\r\n         * The delay in ms before the playback will begin.\r\n         *\r\n         * @name Phaser.Animations.Animation#delay\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.delay = GetValue(config, 'delay', 0);\r\n\r\n        /**\r\n         * Number of times to repeat the animation. Set to -1 to repeat forever.\r\n         *\r\n         * @name Phaser.Animations.Animation#repeat\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.repeat = GetValue(config, 'repeat', 0);\r\n\r\n        /**\r\n         * The delay in ms before the a repeat playthrough starts.\r\n         *\r\n         * @name Phaser.Animations.Animation#repeatDelay\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.repeatDelay = GetValue(config, 'repeatDelay', 0);\r\n\r\n        /**\r\n         * Should the animation yoyo? (reverse back down to the start) before repeating?\r\n         *\r\n         * @name Phaser.Animations.Animation#yoyo\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.yoyo = GetValue(config, 'yoyo', false);\r\n\r\n        /**\r\n         * Should sprite.visible = true when the animation starts to play?\r\n         *\r\n         * @name Phaser.Animations.Animation#showOnStart\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.showOnStart = GetValue(config, 'showOnStart', false);\r\n\r\n        /**\r\n         * Should sprite.visible = false when the animation finishes?\r\n         *\r\n         * @name Phaser.Animations.Animation#hideOnComplete\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.hideOnComplete = GetValue(config, 'hideOnComplete', false);\r\n\r\n        /**\r\n         * Global pause. All Game Objects using this Animation instance are impacted by this property.\r\n         *\r\n         * @name Phaser.Animations.Animation#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.paused = false;\r\n\r\n        this.manager.on('pauseall', this.pause, this);\r\n        this.manager.on('resumeall', this.resume, this);\r\n    },\r\n\r\n    /**\r\n     * Add frames to the end of the animation.\r\n     *\r\n     * @method Phaser.Animations.Animation#addFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|AnimationFrameConfig[])} config - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */\r\n    addFrame: function (config)\r\n    {\r\n        return this.addFrameAt(this.frames.length, config);\r\n    },\r\n\r\n    /**\r\n     * Add frame/s into the animation.\r\n     *\r\n     * @method Phaser.Animations.Animation#addFrameAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - [description]\r\n     * @param {(string|AnimationFrameConfig[])} config - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */\r\n    addFrameAt: function (index, config)\r\n    {\r\n        var newFrames = this.getFrames(this.manager.textureManager, config);\r\n\r\n        if (newFrames.length > 0)\r\n        {\r\n            if (index === 0)\r\n            {\r\n                this.frames = newFrames.concat(this.frames);\r\n            }\r\n            else if (index === this.frames.length)\r\n            {\r\n                this.frames = this.frames.concat(newFrames);\r\n            }\r\n            else\r\n            {\r\n                var pre = this.frames.slice(0, index);\r\n                var post = this.frames.slice(index);\r\n\r\n                this.frames = pre.concat(newFrames, post);\r\n            }\r\n\r\n            this.updateFrameSequence();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check if the given frame index is valid.\r\n     *\r\n     * @method Phaser.Animations.Animation#checkFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index to be checked.\r\n     *\r\n     * @return {boolean} `true` if the index is valid, otherwise `false`.\r\n     */\r\n    checkFrame: function (index)\r\n    {\r\n        return (index >= 0 && index < this.frames.length);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#completeAnimation\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */\r\n    completeAnimation: function (component)\r\n    {\r\n        if (this.hideOnComplete)\r\n        {\r\n            component.parent.visible = false;\r\n        }\r\n\r\n        component.stop();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#getFirstTick\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     * @param {boolean} [includeDelay=true] - [description]\r\n     */\r\n    getFirstTick: function (component, includeDelay)\r\n    {\r\n        if (includeDelay === undefined) { includeDelay = true; }\r\n\r\n        //  When is the first update due?\r\n        component.accumulator = 0;\r\n        component.nextTick = component.msPerFrame + component.currentFrame.duration;\r\n\r\n        if (includeDelay)\r\n        {\r\n            component.nextTick += component._delay;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns the AnimationFrame at the provided index\r\n     *\r\n     * @method Phaser.Animations.Animation#getFrameAt\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index in the AnimationFrame array\r\n     *\r\n     * @return {Phaser.Animations.AnimationFrame} The frame at the index provided from the animation sequence\r\n     */\r\n    getFrameAt: function (index)\r\n    {\r\n        return this.frames[index];\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#getFrames\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.TextureManager} textureManager - [description]\r\n     * @param {(string|AnimationFrameConfig[])} frames - [description]\r\n     * @param {string} [defaultTextureKey] - [description]\r\n     *\r\n     * @return {Phaser.Animations.AnimationFrame[]} [description]\r\n     */\r\n    getFrames: function (textureManager, frames, defaultTextureKey)\r\n    {\r\n        var out = [];\r\n        var prev;\r\n        var animationFrame;\r\n        var index = 1;\r\n        var i;\r\n        var textureKey;\r\n\r\n        //  if frames is a string, we'll get all the frames from the texture manager as if it's a sprite sheet\r\n        if (typeof frames === 'string')\r\n        {\r\n            textureKey = frames;\r\n\r\n            var texture = textureManager.get(textureKey);\r\n            var frameKeys = texture.getFrameNames();\r\n\r\n            frames = [];\r\n\r\n            frameKeys.forEach(function (idx, value)\r\n            {\r\n                frames.push({ key: textureKey, frame: value });\r\n            });\r\n        }\r\n\r\n        if (!Array.isArray(frames) || frames.length === 0)\r\n        {\r\n            return out;\r\n        }\r\n\r\n        for (i = 0; i < frames.length; i++)\r\n        {\r\n            var item = frames[i];\r\n\r\n            var key = GetValue(item, 'key', defaultTextureKey);\r\n\r\n            if (!key)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            //  Could be an integer or a string\r\n            var frame = GetValue(item, 'frame', 0);\r\n\r\n            //  The actual texture frame\r\n            var textureFrame = textureManager.getFrame(key, frame);\r\n\r\n            animationFrame = new Frame(key, frame, index, textureFrame);\r\n\r\n            animationFrame.duration = GetValue(item, 'duration', 0);\r\n\r\n            animationFrame.isFirst = (!prev);\r\n\r\n            //  The previously created animationFrame\r\n            if (prev)\r\n            {\r\n                prev.nextFrame = animationFrame;\r\n\r\n                animationFrame.prevFrame = prev;\r\n            }\r\n\r\n            out.push(animationFrame);\r\n\r\n            prev = animationFrame;\r\n\r\n            index++;\r\n        }\r\n\r\n        if (out.length > 0)\r\n        {\r\n            animationFrame.isLast = true;\r\n\r\n            //  Link them end-to-end, so they loop\r\n            animationFrame.nextFrame = out[0];\r\n\r\n            out[0].prevFrame = animationFrame;\r\n\r\n            //  Generate the progress data\r\n\r\n            var slice = 1 / (out.length - 1);\r\n\r\n            for (i = 0; i < out.length; i++)\r\n            {\r\n                out[i].progress = i * slice;\r\n            }\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#getNextTick\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */\r\n    getNextTick: function (component)\r\n    {\r\n        // accumulator += delta * _timeScale\r\n        // after a large delta surge (perf issue for example) we need to adjust for it here\r\n\r\n        //  When is the next update due?\r\n        component.accumulator -= component.nextTick;\r\n\r\n        component.nextTick = component.msPerFrame + component.currentFrame.duration;\r\n    },\r\n\r\n    /**\r\n     * Loads the Animation values into the Animation Component.\r\n     *\r\n     * @method Phaser.Animations.Animation#load\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component to load values into.\r\n     * @param {integer} startFrame - The start frame of the animation to load.\r\n     */\r\n    load: function (component, startFrame)\r\n    {\r\n        if (startFrame >= this.frames.length)\r\n        {\r\n            startFrame = 0;\r\n        }\r\n\r\n        if (component.currentAnim !== this)\r\n        {\r\n            component.currentAnim = this;\r\n\r\n            component.frameRate = this.frameRate;\r\n            component.duration = this.duration;\r\n            component.msPerFrame = this.msPerFrame;\r\n            component.skipMissedFrames = this.skipMissedFrames;\r\n\r\n            component._delay = this.delay;\r\n            component._repeat = this.repeat;\r\n            component._repeatDelay = this.repeatDelay;\r\n            component._yoyo = this.yoyo;\r\n        }\r\n\r\n        var frame = this.frames[startFrame];\r\n\r\n        if (startFrame === 0 && !component.forward)\r\n        {\r\n            frame = this.getLastFrame();\r\n        }\r\n\r\n        component.updateFrame(frame);\r\n    },\r\n\r\n    /**\r\n     * Returns the frame closest to the given progress value between 0 and 1.\r\n     *\r\n     * @method Phaser.Animations.Animation#getFrameByProgress\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} value - A value between 0 and 1.\r\n     *\r\n     * @return {Phaser.Animations.AnimationFrame} The frame closest to the given progress value.\r\n     */\r\n    getFrameByProgress: function (value)\r\n    {\r\n        value = Clamp(value, 0, 1);\r\n\r\n        return FindClosestInSorted(value, this.frames, 'progress');\r\n    },\r\n\r\n    /**\r\n     * Advance the animation frame.\r\n     *\r\n     * @method Phaser.Animations.Animation#nextFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component to advance.\r\n     */\r\n    nextFrame: function (component)\r\n    {\r\n        var frame = component.currentFrame;\r\n\r\n        //  TODO: Add frame skip support\r\n\r\n        if (frame.isLast)\r\n        {\r\n            //  We're at the end of the animation\r\n\r\n            //  Yoyo? (happens before repeat)\r\n            if (component._yoyo)\r\n            {\r\n                this.handleYoyoFrame(component, false);\r\n            }\r\n            else if (component.repeatCounter > 0)\r\n            {\r\n                //  Repeat (happens before complete)\r\n\r\n                if (component._reverse && component.forward)\r\n                {\r\n                    component.forward = false;\r\n                }\r\n                else\r\n                {\r\n                    this.repeatAnimation(component);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.completeAnimation(component);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.updateAndGetNextTick(component, frame.nextFrame);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handle the yoyo functionality in nextFrame and previousFrame methods.\r\n     *\r\n     * @method Phaser.Animations.Animation#handleYoyoFrame\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - The Animation Component to advance.\r\n     * @param {boolean} isReverse - Is animation in reverse mode? (Default: false)\r\n     */\r\n    handleYoyoFrame: function (component, isReverse)\r\n    {\r\n        if (!isReverse) { isReverse = false; }\r\n\r\n        if (component._reverse === !isReverse && component.repeatCounter > 0)\r\n        {\r\n            component.forward = isReverse;\r\n\r\n            this.repeatAnimation(component);\r\n\r\n            return;\r\n        }\r\n\r\n        if (component._reverse !== isReverse && component.repeatCounter === 0)\r\n        {\r\n            this.completeAnimation(component);\r\n\r\n            return;\r\n        }\r\n        \r\n        component.forward = isReverse;\r\n\r\n        var frame = (isReverse) ? component.currentFrame.nextFrame : component.currentFrame.prevFrame;\r\n\r\n        this.updateAndGetNextTick(component, frame);\r\n    },\r\n\r\n    /**\r\n     * Returns the animation last frame.\r\n     *\r\n     * @method Phaser.Animations.Animation#getLastFrame\r\n     * @since 3.12.0\r\n     *\r\n     * @return {Phaser.Animations.AnimationFrame} component - The Animation Last Frame.\r\n     */\r\n    getLastFrame: function ()\r\n    {\r\n        return this.frames[this.frames.length - 1];\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#previousFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */\r\n    previousFrame: function (component)\r\n    {\r\n        var frame = component.currentFrame;\r\n\r\n        //  TODO: Add frame skip support\r\n\r\n        if (frame.isFirst)\r\n        {\r\n            //  We're at the start of the animation\r\n\r\n            if (component._yoyo)\r\n            {\r\n                this.handleYoyoFrame(component, true);\r\n            }\r\n            else if (component.repeatCounter > 0)\r\n            {\r\n                if (component._reverse && !component.forward)\r\n                {\r\n                    component.currentFrame = this.getLastFrame();\r\n                    this.repeatAnimation(component);\r\n                }\r\n                else\r\n                {\r\n                    //  Repeat (happens before complete)\r\n                    component.forward = true;\r\n                    this.repeatAnimation(component);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.completeAnimation(component);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.updateAndGetNextTick(component, frame.prevFrame);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Update Frame and Wait next tick.\r\n     *\r\n     * @method Phaser.Animations.Animation#updateAndGetNextTick\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} frame - An Animation frame.\r\n     */\r\n    updateAndGetNextTick: function (component, frame)\r\n    {\r\n        component.updateFrame(frame);\r\n\r\n        this.getNextTick(component);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#removeFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} frame - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */\r\n    removeFrame: function (frame)\r\n    {\r\n        var index = this.frames.indexOf(frame);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.removeFrameAt(index);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a frame from the AnimationFrame array at the provided index\r\n     * and updates the animation accordingly.\r\n     *\r\n     * @method Phaser.Animations.Animation#removeFrameAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index in the AnimationFrame array\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */\r\n    removeFrameAt: function (index)\r\n    {\r\n        this.frames.splice(index, 1);\r\n\r\n        this.updateFrameSequence();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#repeatAnimation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */\r\n    repeatAnimation: function (component)\r\n    {\r\n        if (component._pendingStop === 2)\r\n        {\r\n            return this.completeAnimation(component);\r\n        }\r\n\r\n        if (component._repeatDelay > 0 && component.pendingRepeat === false)\r\n        {\r\n            component.pendingRepeat = true;\r\n            component.accumulator -= component.nextTick;\r\n            component.nextTick += component._repeatDelay;\r\n        }\r\n        else\r\n        {\r\n            component.repeatCounter--;\r\n\r\n            component.updateFrame(component.currentFrame[(component.forward) ? 'nextFrame' : 'prevFrame']);\r\n\r\n            if (component.isPlaying)\r\n            {\r\n                this.getNextTick(component);\r\n\r\n                component.pendingRepeat = false;\r\n\r\n                component.parent.emit('animationrepeat', this, component.currentFrame, component.repeatCounter, component.parent);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */\r\n    setFrame: function (component)\r\n    {\r\n        //  Work out which frame should be set next on the child, and set it\r\n        if (component.forward)\r\n        {\r\n            this.nextFrame(component);\r\n        }\r\n        else\r\n        {\r\n            this.previousFrame(component);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONAnimation} [description]\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var output = {\r\n            key: this.key,\r\n            type: this.type,\r\n            frames: [],\r\n            frameRate: this.frameRate,\r\n            duration: this.duration,\r\n            skipMissedFrames: this.skipMissedFrames,\r\n            delay: this.delay,\r\n            repeat: this.repeat,\r\n            repeatDelay: this.repeatDelay,\r\n            yoyo: this.yoyo,\r\n            showOnStart: this.showOnStart,\r\n            hideOnComplete: this.hideOnComplete\r\n        };\r\n\r\n        this.frames.forEach(function (frame)\r\n        {\r\n            output.frames.push(frame.toJSON());\r\n        });\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#updateFrameSequence\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */\r\n    updateFrameSequence: function ()\r\n    {\r\n        var len = this.frames.length;\r\n        var slice = 1 / (len - 1);\r\n\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var frame = this.frames[i];\r\n\r\n            frame.index = i + 1;\r\n            frame.isFirst = false;\r\n            frame.isLast = false;\r\n            frame.progress = i * slice;\r\n\r\n            if (i === 0)\r\n            {\r\n                frame.isFirst = true;\r\n                frame.isLast = (len === 1);\r\n                frame.prevFrame = this.frames[len - 1];\r\n                frame.nextFrame = this.frames[i + 1];\r\n            }\r\n            else if (i === len - 1)\r\n            {\r\n                frame.isLast = true;\r\n                frame.prevFrame = this.frames[len - 2];\r\n                frame.nextFrame = this.frames[0];\r\n            }\r\n            else if (len > 1)\r\n            {\r\n                frame.prevFrame = this.frames[i - 1];\r\n                frame.nextFrame = this.frames[i + 1];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.paused = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.paused = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.manager.off('pauseall', this.pause, this);\r\n        this.manager.off('resumeall', this.resume, this);\r\n\r\n        this.manager.remove(this.key);\r\n\r\n        for (var i = 0; i < this.frames.length; i++)\r\n        {\r\n            this.frames[i].destroy();\r\n        }\r\n\r\n        this.frames = [];\r\n\r\n        this.manager = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Animation;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Clamp","Class","FindClosestInSorted","Frame","GetValue","Animation","initialize","manager","key","config","type","frames","getFrames","textureManager","frameRate","duration","length","msPerFrame","skipMissedFrames","delay","repeat","repeatDelay","yoyo","showOnStart","hideOnComplete","paused","on","pause","resume","addFrame","addFrameAt","index","newFrames","concat","pre","slice","post","updateFrameSequence","checkFrame","completeAnimation","component","parent","visible","stop","getFirstTick","includeDelay","undefined","accumulator","nextTick","currentFrame","_delay","getFrameAt","defaultTextureKey","out","textureKey","frameKeys","get","texture","getFrameNames","forEach","idx","value","push","frame","Array","isArray","i","item","textureFrame","getFrame","animationFrame","isFirst","prev","nextFrame","prevFrame","isLast","progress","getNextTick","load","startFrame","currentAnim","_repeat","_repeatDelay","_yoyo","forward","getLastFrame","updateFrame","getFrameByProgress","handleYoyoFrame","repeatCounter","_reverse","repeatAnimation","updateAndGetNextTick","isReverse","previousFrame","removeFrame","indexOf","removeFrameAt","splice","_pendingStop","pendingRepeat","isPlaying","emit","setFrame","toJSON","output","len","destroy","off","remove"]
}
