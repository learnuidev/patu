{"version":3,"sources":["tongue/number.cljc"],"mappings":";;;;AAOA,AAMA;;;;;;;;;AAAA,AAAMA,AAQHC;AARH,AASE;AAEA,AAAAC,AAE6BD;AAF7BC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAA,AAAAI,AAAAJ,AAAA,AAAA,AAAcK;AAAd,AAAAD,AAAAJ,AAAA,AAAA,AAAsBM;AAAtB,AAGE,AACE,AAAK,AAAA,AAACE,AAAMH,AAAU,AAAA,AAACG,AAAKF;AAC5BG;;AAFF,AAIE,AAAA,AAACD,AAAKF;AAJR,AAAAC;AAAA,AAKG,AAAA,AAACG,AAAY,AAAAH,AAAYF;;;AAL5B,AAQE,AAAKM;AAAL,AACE,AAAAC,AAA0C,AAAA,AAACM,AAAgC,AAAKP;AAAhF,AAAAE,AAAAD,AAAA,AAAA,AAAOE;AAAP,AAAAD,AAAAD,AAAA,AAAA,AAASG;AAAT,AAAAF,AAAAD,AAAA,AAAA,AAAcI;AAAd,AAAAH,AAAAD,AAAA,AAAA,AAA2BK;AACrBE,AAAI,AAACC,AAAMJ;AADjB,AAEE,AAAKD,AACA,AAAOM,AAAI,AAAA,AAACC,AAAIH;AACTI,AAAI,AAAA,AAACC,AAAKR,AAAe,AAAA,AAACM,AAAIH;;AADrC,AAEE,AAAI,AAAGE,AAAIF;AACT,AAAO,AAAA,AAAGE;AAAO,AAAKE,AAAI,AAAA,AAAA,AAAM,AAAA,AAAMF,AAAKf,AAAO,AAACkB,AAAKR,AAAaK,AAAI,AAAA,AAAGA;;;;;AAC5EE;;;;AACJ,AAAA,AAAA,AAAM,AAAA,AAACE,AAAQR,AACb,AAAKZ,AAASY","names":["tongue.number/formatter","opts","map__28268","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","decimal","group","p1__28267#","cljs.core._EQ_","cljs.core/str","clojure.string/replace","x","vec__28271","cljs.core.nth","_","sign","integer-part","fraction-part","cljs.core/re-matches","len","cljs.core/count","idx","cljs.core/rem","res","cljs.core.subs","cljs.core.not_EQ_"],"sourcesContent":["(ns tongue.number\n  (:require\n    [clojure.string :as str]\n    [tongue.macro :as macro]\n    #?(:clj [clojure.spec.alpha :as spec])))\n\n\n(macro/with-spec\n  (spec/def ::decimal string?)\n  (spec/def ::group string?)\n  (spec/def ::options (spec/keys :opt-un [::decimal ::group])))\n\n\n(defn formatter\n  \"Helper to build number format functions\n   Accepts options map:\n\n       { :decimal \\\".\\\"  ;; integer/fractional mark\n         :group   \\\"\\\" } ;; thousands grouping mark\n\n   Returns function `(number => String)`\"\n  [opts]\n  (macro/with-spec\n    (spec/assert ::options opts))\n  (let [{:keys [decimal group]\n         :or   { decimal \".\"\n                 group   \"\" }} opts]\n    (cond\n      (and (= \".\" decimal ) (= \"\" group))\n      str\n      \n      (= \"\" group)\n      #(str/replace (str %) \".\" decimal )\n      \n      :else\n      (fn [x]\n        (let [[_ sign integer-part fraction-part] (re-matches #\"(-?)(\\d+)\\.?(\\d*)\" (str x))\n              len (count integer-part)]\n          (str sign\n               (loop [idx (rem len 3)\n                      res (subs integer-part 0 (rem len 3))]\n                 (if (< idx len)\n                   (recur (+ idx 3) (str res (when (pos? idx) group) (subs integer-part idx (+ idx 3))))\n                   res))\n               (when (not= \"\" fraction-part)\n                 (str decimal  fraction-part))))))))\n"]}