shadow$provide.module$node_modules$Phaser$src$structs$RTree=function(global,require,module,exports){function rbush(maxEntries){var format=[".left",".top",".right",".bottom"];if(!(this instanceof rbush))return new rbush(maxEntries,format);this._maxEntries=Math.max(4,maxEntries||9);this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries));this.clear()}function calcBBox(node,toBBox){distBBox(node,0,node.children.length,toBBox,node)}function distBBox(node,k,p,toBBox,destNode){destNode||(destNode=createNode(null));
destNode.minX=Infinity;destNode.minY=Infinity;destNode.maxX=-Infinity;destNode.maxY=-Infinity;for(var child;k<p;k++)child=node.children[k],extend(destNode,node.leaf?toBBox(child):child);return destNode}function extend(a,b){a.minX=Math.min(a.minX,b.minX);a.minY=Math.min(a.minY,b.minY);a.maxX=Math.max(a.maxX,b.maxX);a.maxY=Math.max(a.maxY,b.maxY);return a}function compareNodeMinX(a,b){return a.minX-b.minX}function compareNodeMinY(a,b){return a.minY-b.minY}function bboxArea(a){return(a.maxX-a.minX)*
(a.maxY-a.minY)}function bboxMargin(a){return a.maxX-a.minX+(a.maxY-a.minY)}function contains(a,b){return a.minX<=b.minX&&a.minY<=b.minY&&b.maxX<=a.maxX&&b.maxY<=a.maxY}function intersects(a,b){return b.minX<=a.maxX&&b.minY<=a.maxY&&b.maxX>=a.minX&&b.maxY>=a.minY}function createNode(children){return{children:children,height:1,leaf:!0,minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity}}function multiSelect(arr,left,right,n,compare){for(var stack=[left,right],mid;stack.length;)right=stack.pop(),
left=stack.pop(),right-left<=n||(mid=left+Math.ceil((right-left)/n/2)*n,quickselect(arr,mid,left,right,compare),stack.push(left,mid,mid,right))}var quickselect=require("module$node_modules$Phaser$src$utils$array$QuickSelect");rbush.prototype={all:function(){return this._all(this.data,[])},search:function(bbox){var node=this.data,result=[],toBBox=this.toBBox;if(!intersects(bbox,node))return result;for(var nodesToSearch=[],i,len,child,childBBox;node;){i=0;for(len=node.children.length;i<len;i++)child=
node.children[i],childBBox=node.leaf?toBBox(child):child,intersects(bbox,childBBox)&&(node.leaf?result.push(child):contains(bbox,childBBox)?this._all(child,result):nodesToSearch.push(child));node=nodesToSearch.pop()}return result},collides:function(bbox){var node=this.data,toBBox=this.toBBox;if(!intersects(bbox,node))return!1;for(var nodesToSearch=[],i,len,child,childBBox;node;){i=0;for(len=node.children.length;i<len;i++)if(child=node.children[i],childBBox=node.leaf?toBBox(child):child,intersects(bbox,
childBBox)){if(node.leaf||contains(bbox,childBBox))return!0;nodesToSearch.push(child)}node=nodesToSearch.pop()}return!1},load:function(data){if(!data||!data.length)return this;if(data.length<this._minEntries){for(var i=0,len=data.length;i<len;i++)this.insert(data[i]);return this}data=this._build(data.slice(),0,data.length-1,0);this.data.children.length?this.data.height===data.height?this._splitRoot(this.data,data):(this.data.height<data.height&&(i=this.data,this.data=data,data=i),this._insert(data,
this.data.height-data.height-1,!0)):this.data=data;return this},insert:function(item){item&&this._insert(item,this.data.height-1);return this},clear:function(){this.data=createNode([]);return this},remove:function(item,equalsFn){if(!item)return this;for(var node=this.data,bbox=this.toBBox(item),path=[],indexes=[],i,parent,index,goingUp;node||path.length;){node||(node=path.pop(),parent=path[path.length-1],i=indexes.pop(),goingUp=!0);if(node.leaf){a:{index=item;var items=node.children,equalsFn$jscomp$0=
equalsFn;if(equalsFn$jscomp$0){for(var i$jscomp$0=0;i$jscomp$0<items.length;i$jscomp$0++)if(equalsFn$jscomp$0(index,items[i$jscomp$0])){index=i$jscomp$0;break a}index=-1}else index=items.indexOf(index)}if(-1!==index){node.children.splice(index,1);path.push(node);this._condense(path);break}}goingUp||node.leaf||!contains(node,bbox)?parent?(i++,node=parent.children[i],goingUp=!1):node=null:(path.push(node),indexes.push(i),i=0,parent=node,node=node.children[0])}return this},toBBox:function(item){return item},
compareMinX:compareNodeMinX,compareMinY:compareNodeMinY,toJSON:function(){return this.data},fromJSON:function(data){this.data=data;return this},_all:function(node,result){for(var nodesToSearch=[];node;)node.leaf?result.push.apply(result,node.children):nodesToSearch.push.apply(nodesToSearch,node.children),node=nodesToSearch.pop();return result},_build:function(items,left,right,height){var N=right-left+1,M=this._maxEntries;if(N<=M){var node=createNode(items.slice(left,right+1));calcBBox(node,this.toBBox);
return node}height||(height=Math.ceil(Math.log(N)/Math.log(M)),M=Math.ceil(N/Math.pow(M,height-1)));node=createNode([]);node.leaf=!1;node.height=height;N=Math.ceil(N/M);M=N*Math.ceil(Math.sqrt(M));var j;for(multiSelect(items,left,right,M,this.compareMinX);left<=right;left+=M){var right2=Math.min(left+M-1,right);multiSelect(items,left,right2,N,this.compareMinY);for(j=left;j<=right2;j+=N){var right3=Math.min(j+N-1,right2);node.children.push(this._build(items,j,right3,height-1))}}calcBBox(node,this.toBBox);
return node},_chooseSubtree:function(bbox,node,level,path){for(var i,len,child,targetNode,area,enlargement,minArea,minEnlargement;;){path.push(node);if(node.leaf||path.length-1===level)break;minArea=minEnlargement=Infinity;i=0;for(len=node.children.length;i<len;i++)child=node.children[i],area=bboxArea(child),enlargement=(Math.max(child.maxX,bbox.maxX)-Math.min(child.minX,bbox.minX))*(Math.max(child.maxY,bbox.maxY)-Math.min(child.minY,bbox.minY))-area,enlargement<minEnlargement?(minEnlargement=enlargement,
minArea=area<minArea?area:minArea,targetNode=child):enlargement===minEnlargement&&area<minArea&&(minArea=area,targetNode=child);node=targetNode||node.children[0]}return node},_insert:function(item,level,isNode){var toBBox=this.toBBox;isNode=isNode?item:toBBox(item);toBBox=[];var node=this._chooseSubtree(isNode,this.data,level,toBBox);node.children.push(item);for(extend(node,isNode);0<=level;)if(toBBox[level].children.length>this._maxEntries)this._split(toBBox,level),level--;else break;this._adjustParentBBoxes(isNode,
toBBox,level)},_split:function(insertPath,level){var node=insertPath[level],M=node.children.length,m=this._minEntries;this._chooseSplitAxis(node,m,M);M=this._chooseSplitIndex(node,m,M);M=createNode(node.children.splice(M,node.children.length-M));M.height=node.height;M.leaf=node.leaf;calcBBox(node,this.toBBox);calcBBox(M,this.toBBox);level?insertPath[level-1].children.push(M):this._splitRoot(node,M)},_splitRoot:function(node,newNode){this.data=createNode([node,newNode]);this.data.height=node.height+
1;this.data.leaf=!1;calcBBox(this.data,this.toBBox)},_chooseSplitIndex:function(node,m,M){var i,minArea;var minOverlap=minArea=Infinity;for(i=m;i<=M-m;i++){var bbox1=distBBox(node,0,i,this.toBBox);var bbox2=distBBox(node,i,M,this.toBBox);var overlap=Math.max(0,Math.min(bbox1.maxX,bbox2.maxX)-Math.max(bbox1.minX,bbox2.minX))*Math.max(0,Math.min(bbox1.maxY,bbox2.maxY)-Math.max(bbox1.minY,bbox2.minY));bbox1=bboxArea(bbox1)+bboxArea(bbox2);if(overlap<minOverlap){minOverlap=overlap;var index=i;minArea=
bbox1<minArea?bbox1:minArea}else overlap===minOverlap&&bbox1<minArea&&(minArea=bbox1,index=i)}return index},_chooseSplitAxis:function(node,m,M){var compareMinX=node.leaf?this.compareMinX:compareNodeMinX,compareMinY=node.leaf?this.compareMinY:compareNodeMinY,xMargin=this._allDistMargin(node,m,M,compareMinX);m=this._allDistMargin(node,m,M,compareMinY);xMargin<m&&node.children.sort(compareMinX)},_allDistMargin:function(node,m,M,compare){node.children.sort(compare);compare=this.toBBox;var leftBBox=distBBox(node,
0,m,compare),rightBBox=distBBox(node,M-m,M,compare),margin=bboxMargin(leftBBox)+bboxMargin(rightBBox),i;for(i=m;i<M-m;i++){var child=node.children[i];extend(leftBBox,node.leaf?compare(child):child);margin+=bboxMargin(leftBBox)}for(i=M-m-1;i>=m;i--)child=node.children[i],extend(rightBBox,node.leaf?compare(child):child),margin+=bboxMargin(rightBBox);return margin},_adjustParentBBoxes:function(bbox,path,level){for(;0<=level;level--)extend(path[level],bbox)},_condense:function(path){for(var i=path.length-
1,siblings;0<=i;i--)0===path[i].children.length?0<i?(siblings=path[i-1].children,siblings.splice(siblings.indexOf(path[i]),1)):this.clear():calcBBox(path[i],this.toBBox)},compareMinX:function(a,b){return a.left-b.left},compareMinY:function(a,b){return a.top-b.top},toBBox:function(a){return{minX:a.left,minY:a.top,maxX:a.right,maxY:a.bottom}}};module.exports=rbush}
//# sourceMappingURL=module$node_modules$Phaser$src$structs$RTree.js.map
