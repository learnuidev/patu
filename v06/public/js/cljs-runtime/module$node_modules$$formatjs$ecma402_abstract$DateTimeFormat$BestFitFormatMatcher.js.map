{
"version":3,
"file":"module$node_modules$$formatjs$ecma402_abstract$DateTimeFormat$BestFitFormatMatcher.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/@formatjs/ecma402-abstract/DateTimeFormat/BestFitFormatMatcher.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$formatjs$ecma402_abstract$DateTimeFormat$BestFitFormatMatcher\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BestFitFormatMatcher = exports.bestFitFormatMatcherScore = void 0;\nvar tslib_1 = require(\"tslib\");\nvar utils_1 = require(\"../utils\");\nvar utils_2 = require(\"./utils\");\nvar skeleton_1 = require(\"./skeleton\");\nfunction isNumericType(t) {\n    return t === 'numeric' || t === '2-digit';\n}\n/**\n * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611\n * with some modifications\n * @param options\n * @param format\n */\nfunction bestFitFormatMatcherScore(options, format) {\n    var score = 0;\n    if (options.hour12 && !format.hour12) {\n        score -= utils_2.removalPenalty;\n    }\n    else if (!options.hour12 && format.hour12) {\n        score -= utils_2.additionPenalty;\n    }\n    for (var _i = 0, DATE_TIME_PROPS_1 = utils_2.DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {\n        var prop = DATE_TIME_PROPS_1[_i];\n        var optionsProp = options[prop];\n        var formatProp = format[prop];\n        if (optionsProp === undefined && formatProp !== undefined) {\n            score -= utils_2.additionPenalty;\n        }\n        else if (optionsProp !== undefined && formatProp === undefined) {\n            score -= utils_2.removalPenalty;\n        }\n        else if (optionsProp !== formatProp) {\n            // extra penalty for numeric vs non-numeric\n            if (isNumericType(optionsProp) !==\n                isNumericType(formatProp)) {\n                score -= utils_2.differentNumericTypePenalty;\n            }\n            else {\n                var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n                var optionsPropIndex = values.indexOf(optionsProp);\n                var formatPropIndex = values.indexOf(formatProp);\n                var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));\n                if (delta === 2) {\n                    score -= utils_2.longMorePenalty;\n                }\n                else if (delta === 1) {\n                    score -= utils_2.shortMorePenalty;\n                }\n                else if (delta === -1) {\n                    score -= utils_2.shortLessPenalty;\n                }\n                else if (delta === -2) {\n                    score -= utils_2.longLessPenalty;\n                }\n            }\n        }\n    }\n    return score;\n}\nexports.bestFitFormatMatcherScore = bestFitFormatMatcherScore;\n/**\n * https://tc39.es/ecma402/#sec-bestfitformatmatcher\n * Just alias to basic for now\n * @param options\n * @param formats\n * @param implDetails Implementation details\n */\nfunction BestFitFormatMatcher(options, formats) {\n    var bestScore = -Infinity;\n    var bestFormat = formats[0];\n    utils_1.invariant(Array.isArray(formats), 'formats should be a list of things');\n    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n        var format = formats_1[_i];\n        var score = bestFitFormatMatcherScore(options, format);\n        if (score > bestScore) {\n            bestScore = score;\n            bestFormat = format;\n        }\n    }\n    var skeletonFormat = tslib_1.__assign({}, bestFormat);\n    var patternFormat = { rawPattern: bestFormat.rawPattern };\n    skeleton_1.processDateTimePattern(bestFormat.rawPattern, patternFormat);\n    // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java\n    // Method adjustFieldTypes\n    for (var prop in skeletonFormat) {\n        var skeletonValue = skeletonFormat[prop];\n        var patternValue = patternFormat[prop];\n        var requestedValue = options[prop];\n        // Don't mess with minute/second or we can get in the situation of\n        // 7:0:0 which is weird\n        if (prop === 'minute' || prop === 'second') {\n            continue;\n        }\n        // Nothing to do here\n        if (!requestedValue) {\n            continue;\n        }\n        // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n        // Looks like we should not convert numeric to alphabetic but the other way\n        // around is ok\n        if (isNumericType(patternValue) &&\n            !isNumericType(requestedValue)) {\n            continue;\n        }\n        if (skeletonValue === requestedValue) {\n            continue;\n        }\n        patternFormat[prop] = requestedValue;\n    }\n    // Copy those over\n    patternFormat.pattern = skeletonFormat.pattern;\n    patternFormat.pattern12 = skeletonFormat.pattern12;\n    patternFormat.skeleton = skeletonFormat.skeleton;\n    patternFormat.rangePatterns = skeletonFormat.rangePatterns;\n    patternFormat.rangePatterns12 = skeletonFormat.rangePatterns12;\n    return patternFormat;\n}\nexports.BestFitFormatMatcher = BestFitFormatMatcher;\n\n};"],
"names":["shadow$provide","global","require","module","exports","isNumericType","t","bestFitFormatMatcherScore","options","format","score","hour12","utils_2","removalPenalty","additionPenalty","_i","DATE_TIME_PROPS_1","DATE_TIME_PROPS","length","prop","optionsProp","formatProp","undefined","differentNumericTypePenalty","values","optionsPropIndex","indexOf","formatPropIndex","delta","Math","max","min","longMorePenalty","shortMorePenalty","shortLessPenalty","longLessPenalty","Object","defineProperty","value","BestFitFormatMatcher","tslib_1","utils_1","skeleton_1","formats","bestScore","Infinity","bestFormat","invariant","Array","isArray","skeletonFormat","__assign","patternFormat","rawPattern","processDateTimePattern","skeletonValue","requestedValue","patternValue","pattern","pattern12","skeleton","rangePatterns","rangePatterns12"]
}
