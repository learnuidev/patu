shadow$provide.module$node_modules$Phaser$src$gameobjects$particles$EmitterOp=function(global,require,module,exports){global=require("module$node_modules$Phaser$src$utils$Class");var FloatBetween=require("module$node_modules$Phaser$src$math$FloatBetween"),GetEaseFunction=require("module$node_modules$Phaser$src$tweens$builders$GetEaseFunction"),GetFastValue=require("module$node_modules$Phaser$src$utils$object$GetFastValue"),Wrap=require("module$node_modules$Phaser$src$math$Wrap");require=new global({initialize:function(config,
key,defaultValue,emitOnly){void 0===emitOnly&&(emitOnly=!1);this.propertyKey=key;this.defaultValue=this.propertyValue=defaultValue;this.end=this.start=this.counter=this.steps=0;this.emitOnly=emitOnly;this.onEmit=this.defaultEmit;this.onUpdate=this.defaultUpdate;this.loadConfig(config)},loadConfig:function(config,newKey){void 0===config&&(config={});newKey&&(this.propertyKey=newKey);this.propertyValue=GetFastValue(config,this.propertyKey,this.defaultValue);this.setMethods();this.emitOnly&&(this.onUpdate=
this.defaultUpdate)},toJSON:function(){return this.propertyValue},onChange:function(value){this.propertyValue=value;return this.setMethods()},setMethods:function(){var value=this.propertyValue,t=typeof value;if("number"===t)this.onEmit=this.staticValueEmit,this.onUpdate=this.staticValueUpdate;else if(Array.isArray(value))this.onEmit=this.randomStaticValueEmit;else if("function"===t)this.emitOnly?this.onEmit=value:this.onUpdate=value;else if("object"===t&&(this.has(value,"random")||this.hasBoth(value,
"start","end")||this.hasBoth(value,"min","max"))){this.start=this.has(value,"start")?value.start:value.min;this.end=this.has(value,"end")?value.end:value.max;if(t=this.hasBoth(value,"min","max")||this.has(value,"random")){var rnd=value.random;Array.isArray(rnd)&&(this.start=rnd[0],this.end=rnd[1]);this.onEmit=this.randomRangedValueEmit}this.has(value,"steps")?(this.steps=value.steps,this.counter=this.start,this.onEmit=this.steppedEmit):(value=this.has(value,"ease")?value.ease:"Linear",this.ease=GetEaseFunction(value),
t||(this.onEmit=this.easedValueEmit),this.onUpdate=this.easeValueUpdate)}else"object"===t&&this.hasEither(value,"onEmit","onUpdate")&&(this.has(value,"onEmit")&&(this.onEmit=value.onEmit),this.has(value,"onUpdate")&&(this.onUpdate=value.onUpdate));return this},has:function(object,key){return object.hasOwnProperty(key)},hasBoth:function(object,key1,key2){return object.hasOwnProperty(key1)&&object.hasOwnProperty(key2)},hasEither:function(object,key1,key2){return object.hasOwnProperty(key1)||object.hasOwnProperty(key2)},
defaultEmit:function(particle,key,value){return value},defaultUpdate:function(particle,key,t,value){return value},staticValueEmit:function(){return this.propertyValue},staticValueUpdate:function(){return this.propertyValue},randomStaticValueEmit:function(){return this.propertyValue[Math.floor(Math.random()*this.propertyValue.length)]},randomRangedValueEmit:function(particle,key){var value=FloatBetween(this.start,this.end);particle&&particle.data[key]&&(particle.data[key].min=value);return value},
steppedEmit:function(){var current=this.counter;this.counter=Wrap(this.counter+(this.end-this.start)/this.steps,this.start,this.end);return current},easedValueEmit:function(particle,key){particle&&particle.data[key]&&(particle=particle.data[key],particle.min=this.start,particle.max=this.end);return this.start},easeValueUpdate:function(particle,key,t){particle=particle.data[key];return(particle.max-particle.min)*this.ease(t)+particle.min}});module.exports=require}
//# sourceMappingURL=module$node_modules$Phaser$src$gameobjects$particles$EmitterOp.js.map
