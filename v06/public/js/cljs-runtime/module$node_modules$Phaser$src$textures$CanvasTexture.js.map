{
"version":3,
"file":"module$node_modules$Phaser$src$textures$CanvasTexture.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/Phaser/src/textures/CanvasTexture.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$textures$CanvasTexture\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Color = require('../display/color/Color');\r\nvar IsSizePowerOfTwo = require('../math/pow2/IsSizePowerOfTwo');\r\nvar Texture = require('./Texture');\r\n\r\n/**\r\n * @classdesc\r\n * A Canvas Texture is a special kind of Texture that is backed by an HTML Canvas Element as its source.\r\n *\r\n * You can use the properties of this texture to draw to the canvas element directly, using all of the standard\r\n * canvas operations available in the browser. Any Game Object can be given this texture and will render with it.\r\n *\r\n * Note: When running under WebGL the Canvas Texture needs to re-generate its base WebGLTexture and reupload it to\r\n * the GPU every time you modify it, otherwise the changes you make to this texture will not be visible. To do this\r\n * you should call `CanvasTexture.refresh()` once you are finished with your changes to the canvas. Try and keep\r\n * this to a minimum, especially on large canvas sizes, or you may inadvertently thrash the GPU by constantly uploading\r\n * texture data to it. This restriction does not apply if using the Canvas Renderer.\r\n * \r\n * It starts with only one frame that covers the whole of the canvas. You can add further frames, that specify\r\n * sections of the canvas using the `add` method.\r\n * \r\n * Should you need to resize the canvas use the `setSize` method so that it accurately updates all of the underlying\r\n * texture data as well. Forgetting to do this (i.e. by changing the canvas size directly from your code) could cause\r\n * graphical errors.\r\n *\r\n * @class CanvasTexture\r\n * @extends Phaser.Textures.Texture\r\n * @memberOf Phaser.Textures\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Textures.CanvasTexture} manager - A reference to the Texture Manager this Texture belongs to.\r\n * @param {string} key - The unique string-based key of this Texture.\r\n * @param {HTMLCanvasElement} source - The canvas element that is used as the base of this texture.\r\n * @param {integer} width - The width of the canvas.\r\n * @param {integer} height - The height of the canvas.\r\n */\r\nvar CanvasTexture = new Class({\r\n\r\n    Extends: Texture,\r\n\r\n    initialize:\r\n\r\n    function CanvasTexture (manager, key, source, width, height)\r\n    {\r\n        Texture.call(this, manager, key, source, width, height);\r\n\r\n        this.add('__BASE', 0, 0, 0, width, height);\r\n\r\n        /**\r\n         * A reference to the Texture Source of this Canvas.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#_source\r\n         * @type {Phaser.Textures.TextureSource}\r\n         * @private\r\n         * @since 3.7.0\r\n         */\r\n        this._source = this.frames['__BASE'].source;\r\n\r\n        /**\r\n         * The source Canvas Element.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#canvas\r\n         * @readOnly\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.7.0\r\n         */\r\n        this.canvas = this._source.image;\r\n\r\n        /**\r\n         * The 2D Canvas Rendering Context.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#context\r\n         * @readOnly\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.7.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * The width of the Canvas.\r\n         * This property is read-only, if you wish to change it use the `setSize` method.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#width\r\n         * @readOnly\r\n         * @type {integer}\r\n         * @since 3.7.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the Canvas.\r\n         * This property is read-only, if you wish to change it use the `setSize` method.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#height\r\n         * @readOnly\r\n         * @type {integer}\r\n         * @since 3.7.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The context image data.\r\n         * Use the `update` method to populate this when the canvas changes.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#imageData\r\n         * @type {ImageData}\r\n         * @since 3.13.0\r\n         */\r\n        this.imageData = this.context.getImageData(0, 0, width, height);\r\n\r\n        /**\r\n         * A Uint8ClampedArray view into the `buffer`.\r\n         * Use the `update` method to populate this when the canvas changes.\r\n         * Note that this is unavailable in some browsers, such as Epic Browser, due to their security restrictions.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#data\r\n         * @type {Uint8ClampedArray}\r\n         * @since 3.13.0\r\n         */\r\n        this.data = null;\r\n\r\n        if (this.imageData)\r\n        {\r\n            this.data = this.imageData.data;\r\n        }\r\n\r\n        /**\r\n         * An Uint32Array view into the `buffer`.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#pixels\r\n         * @type {Uint32Array}\r\n         * @since 3.13.0\r\n         */\r\n        this.pixels = null;\r\n\r\n        /**\r\n         * An ArrayBuffer the same size as the context ImageData.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#buffer\r\n         * @type {ArrayBuffer}\r\n         * @since 3.13.0\r\n         */\r\n        this.buffer;\r\n\r\n        if (this.data)\r\n        {\r\n            if (this.imageData.data.buffer)\r\n            {\r\n                this.buffer = this.imageData.data.buffer;\r\n                this.pixels = new Uint32Array(this.buffer);\r\n            }\r\n            else if (window.ArrayBuffer)\r\n            {\r\n                this.buffer = new ArrayBuffer(this.imageData.data.length);\r\n                this.pixels = new Uint32Array(this.buffer);\r\n            }\r\n            else\r\n            {\r\n                this.pixels = this.imageData.data;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This re-creates the `imageData` from the current context.\r\n     * It then re-builds the ArrayBuffer, the `data` Uint8ClampedArray reference and the `pixels` Int32Array.\r\n     *\r\n     * Warning: This is a very expensive operation, so use it sparingly.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#update\r\n     * @since 3.13.0\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    update: function ()\r\n    {\r\n        this.imageData = this.context.getImageData(0, 0, this.width, this.height);\r\n\r\n        this.data = this.imageData.data;\r\n\r\n        if (this.imageData.data.buffer)\r\n        {\r\n            this.buffer = this.imageData.data.buffer;\r\n            this.pixels = new Uint32Array(this.buffer);\r\n        }\r\n        else if (window.ArrayBuffer)\r\n        {\r\n            this.buffer = new ArrayBuffer(this.imageData.data.length);\r\n            this.pixels = new Uint32Array(this.buffer);\r\n        }\r\n        else\r\n        {\r\n            this.pixels = this.imageData.data;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given Image or Canvas element to this CanvasTexture, then updates the internal\r\n     * ImageData buffer and arrays.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#draw\r\n     * @since 3.13.0\r\n     * \r\n     * @param {integer} x - The x coordinate to draw the source at.\r\n     * @param {integer} y - The y coordinate to draw the source at.\r\n     * @param {(HTMLImageElement|HTMLCanvasElement)} source - The element to draw to this canvas.\r\n     * \r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    draw: function (x, y, source)\r\n    {\r\n        this.context.drawImage(source, x, y);\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * Get the color of a specific pixel from this texture and store it in a Color object.\r\n     * \r\n     * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,\r\n     * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getPixel\r\n     * @since 3.13.0\r\n     * \r\n     * @param {integer} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {Phaser.Display.Color} [out] - An object into which 4 properties will be set: r, g, b and a. If not provided a Color object will be created.\r\n     * \r\n     * @return {Phaser.Display.Color} An object with the red, green, blue and alpha values set in the r, g, b and a properties.\r\n     */\r\n    getPixel: function (x, y, out)\r\n    {\r\n        if (!out)\r\n        {\r\n            out = new Color();\r\n        }\r\n\r\n        var index = ~~(x + (y * this.width));\r\n\r\n        index *= 4;\r\n\r\n        var r = this.data[index];\r\n        var g = this.data[++index];\r\n        var b = this.data[++index];\r\n        var a = this.data[++index];\r\n\r\n        return out.setTo(r, g, b, a);\r\n    },\r\n\r\n    /**\r\n     * This should be called manually if you are running under WebGL.\r\n     * It will refresh the WebGLTexture from the Canvas source. Only call this if you know that the\r\n     * canvas has changed, as there is a significant GPU texture allocation cost involved in doing so.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#refresh\r\n     * @since 3.7.0\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    refresh: function ()\r\n    {\r\n        this._source.update();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the Canvas Element.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getCanvas\r\n     * @since 3.7.0\r\n     *\r\n     * @return {HTMLCanvasElement} The Canvas DOM element this texture is using.\r\n     */\r\n    getCanvas: function ()\r\n    {\r\n        return this.canvas;\r\n    },\r\n\r\n    /**\r\n     * Gets the 2D Canvas Rendering Context.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getContext\r\n     * @since 3.7.0\r\n     *\r\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context this texture is using.\r\n     */\r\n    getContext: function ()\r\n    {\r\n        return this.context;\r\n    },\r\n\r\n    /**\r\n     * Clears this Canvas Texture, resetting it back to transparent.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#clear\r\n     * @since 3.7.0\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.context.clearRect(0, 0, this.width, this.height);\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * Changes the size of this Canvas Texture.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#setSize\r\n     * @since 3.7.0\r\n     *\r\n     * @param {integer} width - The new width of the Canvas.\r\n     * @param {integer} [height] - The new height of the Canvas. If not given it will use the width as the height.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        if (height === undefined) { height = width; }\r\n\r\n        if (width !== this.width || height !== this.height)\r\n        {\r\n            //  Update the Canvas\r\n            this.canvas.width = width;\r\n            this.canvas.height = height;\r\n\r\n            //  Update the Texture Source\r\n            this._source.width = width;\r\n            this._source.height = height;\r\n            this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);\r\n\r\n            //  Update the Frame\r\n            this.frames['__BASE'].setSize(width, height, 0, 0);\r\n\r\n            this.refresh();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = CanvasTexture;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Class","Color","IsSizePowerOfTwo","Texture","CanvasTexture","Extends","initialize","manager","key","source","width","height","call","add","_source","frames","canvas","image","context","getContext","imageData","getImageData","data","pixels","buffer","Uint32Array","window","ArrayBuffer","length","update","draw","x","y","drawImage","getPixel","out","index","r","g","b","a","setTo","refresh","getCanvas","clear","clearRect","setSize","undefined","isPowerOf2"]
}
