{"version":3,"sources":["clojure/test/check/random/longs.cljs"],"mappings":";;;;;AAkBA,AAAA,AAAMA,AACHC,AAAEC;AADL,AAEE,AAAqBD,AAAEC;;AAEzB,AAAA,AAAMC,AACHF,AAAEG;AADL,AAEE,AAAMH,AAAEG;;AAEV,AAAA,AAAMC,AACHJ,AAAEG;AADL,AAEE,AAAME,AAAI,AAAA,AAA2B,AAASL;AACxCM,AAAI,AAAA,AAAS,AAASN;AACtBO,AAAI,AAAA,AAA2B,AAAQP;AACvCQ,AAAI,AAAA,AAAS,AAAQR;AAErBS,AAAI,AAAA,AAA2B,AAASN;AACxCO,AAAI,AAAA,AAAS,AAASP;AACtBQ,AAAI,AAAA,AAA2B,AAAQR;AACvCS,AAAI,AAAA,AAAS,AAAQT;AAErBU,AAAI,AAAA,AAAA,AAAA,AAAA;AAVV,AAWE,AAAA,AAAMA,AAAM,AAAQL,AAAII;;AACxB,AAAA,AAAMC,AAAM,AAAA,AAA2B,AAAA,AAAMA;;AAC7C,AAAA,AAAMA,AAAM,AAAA,AAAS,AAAA,AAAMA;;AAC3B,AAAA,AAAMA,AAAM,AAAQ,AAAA,AAAMA,AAAO,AAAQN,AAAIK;;AAC7C,AAAA,AAAMC,AAAM,AAAA,AAA2B,AAAA,AAAMA;;AAC7C,AAAA,AAAMA,AAAM,AAAA,AAAS,AAAA,AAAMA;;AAC3B,AAAA,AAAMA,AAAM,AAAQ,AAAA,AAAMA,AAAO,AAAQL,AAAIG;;AAC7C,AAAA,AAAME,AAAM,AAAQ,AAAA,AAAMA,AAAO,AAAA,AAA2B,AAAA,AAAMA;;AAClE,AAAA,AAAMA,AAAM,AAAA,AAAS,AAAA,AAAMA;;AAC3B,AAAA,AAAMA,AAAM,AAAQ,AAAA,AAAMA,AAAO,AAAQP,AAAIM;;AAC7C,AAAA,AAAMC,AAAM,AAAA,AAA2B,AAAA,AAAMA;;AAC7C,AAAA,AAAMA,AAAM,AAAA,AAAS,AAAA,AAAMA;;AAC3B,AAAA,AAAMA,AAAM,AAAQ,AAAA,AAAMA,AAAO,AAAQN,AAAII;;AAC7C,AAAA,AAAME,AAAM,AAAQ,AAAA,AAAMA,AAAO,AAAA,AAA2B,AAAA,AAAMA;;AAClE,AAAA,AAAMA,AAAM,AAAA,AAAS,AAAA,AAAMA;;AAC3B,AAAA,AAAMA,AAAM,AAAQ,AAAA,AAAMA,AAAO,AAAQL,AAAIE;;AAC7C,AAAA,AAAMG,AAAM,AAAQ,AAAA,AAAMA,AAAO,AAAA,AAA2B,AAAA,AAAMA;;AAClE,AAAA,AAAMA,AAAM,AAAA,AAAS,AAAA,AAAMA;;AAE3B,AAAA,AAAMA,AAAM,AAAA,AAAA,AAAA,AAAQ,AAAA,AAAMA,AAAO,AAAQR,AAAIO,AAAK,AAAQN,AAAIK,AAAK,AAAQJ,AAAIG,AAAK,AAAQF,AAAIC;;AAEhG,AAAA,AAAMI,AAAM,AAAA,AAAS,AAAA,AAAMA;;AAG3B,AAACC,AAAc,AAAa,AAAA,AAAgB,AAAA,AAAMD,AAAW,AAAA,AAAMA,AACpD,AAAa,AAAA,AAAgB,AAAA,AAAMA,AAAW,AAAA,AAAMA;;AAEvE,AAAA,AAAME,AACHf,AAAEG;AADL,AAEE,AAAMH,AAAEG;;AAEV,AAAA,AAAMa,AACHhB,AAAEG;AADL,AAEE,AAAKH,AAAEG;;AAET,AAAA,AAAMc,AACHC,AAAEC;AADL,AAEE,AAACC,AAAgBF,AAAEC;;AAErB,AAAA,AAAME,AACHrB;AADH,AAEE,AAACsB,AAAgBtB;;AAEnB;;;AAAA,AAAMuB,AAEHvB;AAFH,AAGE,AAAM,AAASA;AACT,AAACsB,AAAgBtB;;AADvB,AAGM,AAAWwB,AAAexB;AAC1BA;;AAJN;;;;AAMF,AAAKyB,AAAI,AAACC;AAEV,AAAKC,AAAUC","names":["clojure.test.check.random.longs/unsigned-bit-shift-right","x","n","clojure.test.check.random.longs/+","y","clojure.test.check.random.longs/*","a48","a32","a16","a00","b48","b32","b16","b00","arr","goog.math.Long/fromBits","clojure.test.check.random.longs/bit-xor","clojure.test.check.random.longs/bit-or","clojure.test.check.random.longs/from-string","s","radix","goog.math.Long/fromString","clojure.test.check.random.longs/from-number","goog.math.Long/fromNumber","clojure.test.check.random.longs/->long","js/goog.math.Long","clojure.test.check.random.longs/ONE","goog.math.Long/getOne","clojure.test.check.random.longs/bit-count","clojure.test.check.random.longs.bit-count-impl/bit-count"],"sourcesContent":[";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:author \"Gary Fredericks\"\n      :doc \"Internal namespace, wrapping some goog.math.Long functionality.\"}\n clojure.test.check.random.longs\n  (:refer-clojure :exclude [+ * bit-xor bit-or bit-count\n                            unsigned-bit-shift-right])\n  (:require [clojure.test.check.random.longs.bit-count-impl :as bit-count]\n            [goog.math.Long :as long]\n            [clojure.core :as core]))\n\n(defn unsigned-bit-shift-right\n  [x n]\n  (.shiftRightUnsigned x n))\n\n(defn +\n  [x y]\n  (.add x y))\n\n(defn *\n  [x y]\n  (let [a48 (bit-shift-right-zero-fill (.-high_ x) 16)\n        a32 (bit-and (.-high_ x) 0xFFFF)\n        a16 (bit-shift-right-zero-fill (.-low_ x) 16)\n        a00 (bit-and (.-low_ x) 0xFFFF)\n\n        b48 (bit-shift-right-zero-fill (.-high_ y) 16)\n        b32 (bit-and (.-high_ y) 0xFFFF)\n        b16 (bit-shift-right-zero-fill (.-low_ y) 16)\n        b00 (bit-and (.-low_ y) 0xFFFF)\n\n        arr (array 0 0 0 0)]                              ;[c00 c16 c32 c48]\n    (aset arr 0 (core/* a00 b00))                                                  ;c00 += a00 * b00;\n    (aset arr 1 (bit-shift-right-zero-fill (aget arr 0) 16))                       ;c16 += c00 >>> 16\n    (aset arr 0 (bit-and (aget arr 0) 0xFFFF))                                     ;c00 &= 0xFFFF;\n    (aset arr 1 (core/+ (aget arr 1) (core/* a16 b00)))                            ;c16 += a16 * b00;\n    (aset arr 2 (bit-shift-right-zero-fill (aget arr 1) 16))                       ;c32 += c16 >>> 16;\n    (aset arr 1 (bit-and (aget arr 1) 0xFFFF))                                     ;c16 &= 0xFFFF;\n    (aset arr 1 (core/+ (aget arr 1) (core/* a00 b16)))                            ;c16 += a00 * b16;\n    (aset arr 2 (core/+ (aget arr 2) (bit-shift-right-zero-fill (aget arr 1) 16))) ;c32 += c16 >>> 16;\n    (aset arr 1 (bit-and (aget arr 1) 0xFFFF))                                     ;c16 &= 0xFFFF;\n    (aset arr 2 (core/+ (aget arr 2) (core/* a32 b00)))                            ;c32 += a32 * b00;\n    (aset arr 3 (bit-shift-right-zero-fill (aget arr 2) 16))                       ;c48 += c32 >>> 16;\n    (aset arr 2 (bit-and (aget arr 2) 0xFFFF))                                     ;c32 &= 0xFFFF;\n    (aset arr 2 (core/+ (aget arr 2) (core/* a16 b16)))                            ;c32 += a16 * b16;\n    (aset arr 3 (core/+ (aget arr 3) (bit-shift-right-zero-fill (aget arr 2) 16))) ;c48 += c32 >>> 16;\n    (aset arr 2 (bit-and (aget arr 2) 0xFFFF))                                     ;c32 &= 0xFFFF;\n    (aset arr 2 (core/+ (aget arr 2) (core/* a00 b32)))                            ;c32 += a00 * b32;\n    (aset arr 3 (core/+ (aget arr 3) (bit-shift-right-zero-fill (aget arr 2) 16))) ;c48 += c32 >>> 16;\n    (aset arr 2 (bit-and (aget arr 2) 0xFFFF))                                     ;c32 &= 0xFFFF;\n\n    (aset arr 3 (core/+ (aget arr 3) (core/* a48 b00) (core/* a32 b16) (core/* a16 b32) (core/* a00 b48)))\n    ;c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    (aset arr 3 (bit-and (aget arr 3) 0xFFFF))                                    ;c48 &= 0xFFFF;\n\n    ;(c16 << 16) | c00, (c48 << 16) | c32\n    (long/fromBits (core/bit-or (bit-shift-left (aget arr 1) 16) (aget arr 0))\n                   (core/bit-or (bit-shift-left (aget arr 3) 16) (aget arr 2)))))\n\n(defn bit-xor\n  [x y]\n  (.xor x y))\n\n(defn bit-or\n  [x y]\n  (.or x y))\n\n(defn from-string\n  [s radix]\n  (long/fromString s radix))\n\n(defn from-number\n  [x]\n  (long/fromNumber x))\n\n(defn ->long\n  \"Coerces to long, or returns nil if not possible.\"\n  [x]\n  (cond (number? x)\n        (long/fromNumber x)\n\n        (instance? goog.math.Long x)\n        x))\n\n(def ONE (long/getOne))\n\n(def bit-count bit-count/bit-count)\n"]}