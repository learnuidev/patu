{
"version":3,
"file":"module$node_modules$Phaser$src$tilemaps$components$PutTileAt.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,6DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAOzH,IAAIC,KAAOH,OAAA,CAAQ,8CAAR,CAAX,CACII,gBAAkBJ,OAAA,CAAQ,oEAAR,CADtB,CAEIK,iBAAmBL,OAAA,CAAQ,qEAAR,CAFvB,CAGIM,iBAAmBN,OAAA,CAAQ,qEAAR,CA+DvBC,OAAAC,QAAA,CA3CgBK,QAAS,CAACC,IAAD,CAAOC,KAAP;AAAcC,KAAd,CAAqBC,gBAArB,CAAuCC,KAAvC,CACzB,CACI,GAAI,CAACR,eAAA,CAAgBK,KAAhB,CAAuBC,KAAvB,CAA8BE,KAA9B,CAAL,CAA6C,MAAO,KAC3BC,KAAAA,EAAzB,GAAIF,gBAAJ,GAAsCA,gBAAtC,CAAyD,CAAA,CAAzD,CAEA,KAAIG,QAAUF,KAAAG,KAAA,CAAWL,KAAX,CAAA,CAAkBD,KAAlB,CACVO,QAAAA,CAAkBF,OAAlBE,EAA6BF,OAAAG,SAE7BT,KAAJ,WAAoBL,KAApB,EAEqC,IAIjC,GAJIS,KAAAG,KAAA,CAAWL,KAAX,CAAA,CAAkBD,KAAlB,CAIJ,GAFIG,KAAAG,KAAA,CAAWL,KAAX,CAAA,CAAkBD,KAAlB,CAEJ,CAF+B,IAAIN,IAAJ,CAASS,KAAT,CAAgBJ,IAAAU,MAAhB,CAA4BT,KAA5B,CAAmCC,KAAnC,CAA0CF,IAAAW,MAA1C,CAAsDX,IAAAY,OAAtD,CAE/B,EAAAR,KAAAG,KAAA,CAAWL,KAAX,CAAA,CAAkBD,KAAlB,CAAAY,KAAA,CAA8Bb,IAA9B,CANJ,EAWqC,IAAjC,GAAII,KAAAG,KAAA,CAAWL,KAAX,CAAA,CAAkBD,KAAlB,CAAJ,CAEIG,KAAAG,KAAA,CAAWL,KAAX,CAAA,CAAkBD,KAAlB,CAFJ,CAE+B,IAAIN,IAAJ,CAASS,KAAT,CAHnBJ,IAGmB,CAAuBC,KAAvB,CAA8BC,KAA9B,CAAqCE,KAAAU,UAArC,CAAsDV,KAAAW,WAAtD,CAF/B;AAMIX,KAAAG,KAAA,CAAWL,KAAX,CAAA,CAAkBD,KAAlB,CAAAS,MANJ,CADYV,IAYZgB,KAAAA,CAAUZ,KAAAG,KAAA,CAAWL,KAAX,CAAA,CAAkBD,KAAlB,CACd,KAAIQ,SAA2D,EAA3DA,GAAWL,KAAAa,eAAAC,QAAA,CAA6BF,IAAAN,MAA7B,CACfZ,iBAAA,CAAiBkB,IAAjB,CAA0BP,QAA1B,CAGIN,iBAAJ,EAAyBK,OAAzB,GAA6CQ,IAAAP,SAA7C,EAEIZ,gBAAA,CAAiBI,KAAjB,CAAwBC,KAAxB,CAA+BE,KAA/B,CAGJ,OAAOY,KAvCX,CA/ByH;",
"sources":["node_modules/Phaser/src/tilemaps/components/PutTileAt.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$tilemaps$components$PutTileAt\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Tile = require('../Tile');\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\nvar CalculateFacesAt = require('./CalculateFacesAt');\r\nvar SetTileCollision = require('./SetTileCollision');\r\n\r\n/**\r\n * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n * location. If you pass in an index, only the index at the specified location will be changed.\r\n * Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAt\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\r\nvar PutTileAt = function (tile, tileX, tileY, recalculateFaces, layer)\r\n{\r\n    if (!IsInLayerBounds(tileX, tileY, layer)) { return null; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    var oldTile = layer.data[tileY][tileX];\r\n    var oldTileCollides = oldTile && oldTile.collides;\r\n\r\n    if (tile instanceof Tile)\r\n    {\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, tile.width, tile.height);\r\n        }\r\n        layer.data[tileY][tileX].copy(tile);\r\n    }\r\n    else\r\n    {\r\n        var index = tile;\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n        }\r\n        else\r\n        {\r\n            layer.data[tileY][tileX].index = index;\r\n        }\r\n    }\r\n\r\n    // Updating colliding flag on the new tile\r\n    var newTile = layer.data[tileY][tileX];\r\n    var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;\r\n    SetTileCollision(newTile, collides);\r\n\r\n    // Recalculate faces only if the colliding flag at (tileX, tileY) has changed\r\n    if (recalculateFaces && (oldTileCollides !== newTile.collides))\r\n    {\r\n        CalculateFacesAt(tileX, tileY, layer);\r\n    }\r\n\r\n    return newTile;\r\n};\r\n\r\nmodule.exports = PutTileAt;\r\n\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Tile","IsInLayerBounds","CalculateFacesAt","SetTileCollision","PutTileAt","tile","tileX","tileY","recalculateFaces","layer","undefined","oldTile","data","oldTileCollides","collides","index","width","height","copy","tileWidth","tileHeight","newTile","collideIndexes","indexOf"]
}
