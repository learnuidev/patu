{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/matter-js/lib/geometry/Vertices.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices\"] = function(global,require,module,exports) {\n/**\r\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\r\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\r\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Vertices\r\n*/\r\n\r\nvar Vertices = {};\r\n\r\nmodule.exports = Vertices;\r\n\r\nvar Vector = require('../geometry/Vector');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new set of `Matter.Body` compatible vertices.\r\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\r\n     *\r\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n     *\r\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\r\n     * but with some additional references required for efficient collision detection routines.\r\n     *\r\n     * Vertices must be specified in clockwise order.\r\n     *\r\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\r\n     *\r\n     * @method create\r\n     * @param {vector[]} points\r\n     * @param {body} body\r\n     */\r\n    Vertices.create = function(points, body) {\r\n        var vertices = [];\r\n\r\n        for (var i = 0; i < points.length; i++) {\r\n            var point = points[i],\r\n                vertex = {\r\n                    x: point.x,\r\n                    y: point.y,\r\n                    index: i,\r\n                    body: body,\r\n                    isInternal: false,\r\n                    contact: null\r\n                };\r\n\r\n            vertex.contact = {\r\n                vertex: vertex,\r\n                normalImpulse: 0,\r\n                tangentImpulse: 0\r\n            };\r\n\r\n            vertices.push(vertex);\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \r\n     * into a `Matter.Vertices` object for the given `Matter.Body`.\r\n     * For parsing SVG paths, see `Svg.pathToVertices`.\r\n     * @method fromPath\r\n     * @param {string} path\r\n     * @param {body} body\r\n     * @return {vertices} vertices\r\n     */\r\n    Vertices.fromPath = function(path, body) {\r\n        var pathPattern = /L?\\s*([\\-\\d\\.e]+)[\\s,]*([\\-\\d\\.e]+)*/ig,\r\n            points = [];\r\n\r\n        path.replace(pathPattern, function(match, x, y) {\r\n            points.push({ x: parseFloat(x), y: parseFloat(y) });\r\n        });\r\n\r\n        return Vertices.create(points, body);\r\n    };\r\n\r\n    /**\r\n     * Returns the centre (centroid) of the set of vertices.\r\n     * @method centre\r\n     * @param {vertices} vertices\r\n     * @return {vector} The centre point\r\n     */\r\n    Vertices.centre = function(vertices) {\r\n        var area = Vertices.area(vertices, true),\r\n            centre = { x: 0, y: 0 },\r\n            cross,\r\n            temp,\r\n            j;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            j = (i + 1) % vertices.length;\r\n            cross = Vector.cross(vertices[i], vertices[j]);\r\n            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\r\n            centre = Vector.add(centre, temp);\r\n        }\r\n\r\n        return Vector.div(centre, 6 * area);\r\n    };\r\n\r\n    /**\r\n     * Returns the average (mean) of the set of vertices.\r\n     * @method mean\r\n     * @param {vertices} vertices\r\n     * @return {vector} The average point\r\n     */\r\n    Vertices.mean = function(vertices) {\r\n        var average = { x: 0, y: 0 };\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            average.x += vertices[i].x;\r\n            average.y += vertices[i].y;\r\n        }\r\n\r\n        return Vector.div(average, vertices.length);\r\n    };\r\n\r\n    /**\r\n     * Returns the area of the set of vertices.\r\n     * @method area\r\n     * @param {vertices} vertices\r\n     * @param {bool} signed\r\n     * @return {number} The area\r\n     */\r\n    Vertices.area = function(vertices, signed) {\r\n        var area = 0,\r\n            j = vertices.length - 1;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\r\n            j = i;\r\n        }\r\n\r\n        if (signed)\r\n            return area / 2;\r\n\r\n        return Math.abs(area) / 2;\r\n    };\r\n\r\n    /**\r\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\r\n     * @method inertia\r\n     * @param {vertices} vertices\r\n     * @param {number} mass\r\n     * @return {number} The polygon's moment of inertia\r\n     */\r\n    Vertices.inertia = function(vertices, mass) {\r\n        var numerator = 0,\r\n            denominator = 0,\r\n            v = vertices,\r\n            cross,\r\n            j;\r\n\r\n        // find the polygon's moment of inertia, using second moment of area\r\n        // from equations at http://www.physicsforums.com/showthread.php?t=25293\r\n        for (var n = 0; n < v.length; n++) {\r\n            j = (n + 1) % v.length;\r\n            cross = Math.abs(Vector.cross(v[j], v[n]));\r\n            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\r\n            denominator += cross;\r\n        }\r\n\r\n        return (mass / 6) * (numerator / denominator);\r\n    };\r\n\r\n    /**\r\n     * Translates the set of vertices in-place.\r\n     * @method translate\r\n     * @param {vertices} vertices\r\n     * @param {vector} vector\r\n     * @param {number} scalar\r\n     */\r\n    Vertices.translate = function(vertices, vector, scalar) {\r\n        var i;\r\n        if (scalar) {\r\n            for (i = 0; i < vertices.length; i++) {\r\n                vertices[i].x += vector.x * scalar;\r\n                vertices[i].y += vector.y * scalar;\r\n            }\r\n        } else {\r\n            for (i = 0; i < vertices.length; i++) {\r\n                vertices[i].x += vector.x;\r\n                vertices[i].y += vector.y;\r\n            }\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Rotates the set of vertices in-place.\r\n     * @method rotate\r\n     * @param {vertices} vertices\r\n     * @param {number} angle\r\n     * @param {vector} point\r\n     */\r\n    Vertices.rotate = function(vertices, angle, point) {\r\n        if (angle === 0)\r\n            return;\r\n\r\n        var cos = Math.cos(angle),\r\n            sin = Math.sin(angle);\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var vertice = vertices[i],\r\n                dx = vertice.x - point.x,\r\n                dy = vertice.y - point.y;\r\n                \r\n            vertice.x = point.x + (dx * cos - dy * sin);\r\n            vertice.y = point.y + (dx * sin + dy * cos);\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the `point` is inside the set of `vertices`.\r\n     * @method contains\r\n     * @param {vertices} vertices\r\n     * @param {vector} point\r\n     * @return {boolean} True if the vertices contains point, otherwise false\r\n     */\r\n    Vertices.contains = function(vertices, point) {\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var vertice = vertices[i],\r\n                nextVertice = vertices[(i + 1) % vertices.length];\r\n            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Scales the vertices from a point (default is centre) in-place.\r\n     * @method scale\r\n     * @param {vertices} vertices\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} point\r\n     */\r\n    Vertices.scale = function(vertices, scaleX, scaleY, point) {\r\n        if (scaleX === 1 && scaleY === 1)\r\n            return vertices;\r\n\r\n        point = point || Vertices.centre(vertices);\r\n\r\n        var vertex,\r\n            delta;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            vertex = vertices[i];\r\n            delta = Vector.sub(vertex, point);\r\n            vertices[i].x = point.x + delta.x * scaleX;\r\n            vertices[i].y = point.y + delta.y * scaleY;\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\r\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\r\n     * @method chamfer\r\n     * @param {vertices} vertices\r\n     * @param {number[]} radius\r\n     * @param {number} quality\r\n     * @param {number} qualityMin\r\n     * @param {number} qualityMax\r\n     */\r\n    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\r\n        if (typeof radius === 'number') {\r\n            radius = [radius];\r\n        } else {\r\n            radius = radius || [8];\r\n        }\r\n\r\n        // quality defaults to -1, which is auto\r\n        quality = (typeof quality !== 'undefined') ? quality : -1;\r\n        qualityMin = qualityMin || 2;\r\n        qualityMax = qualityMax || 14;\r\n\r\n        var newVertices = [];\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\r\n                vertex = vertices[i],\r\n                nextVertex = vertices[(i + 1) % vertices.length],\r\n                currentRadius = radius[i < radius.length ? i : radius.length - 1];\r\n\r\n            if (currentRadius === 0) {\r\n                newVertices.push(vertex);\r\n                continue;\r\n            }\r\n\r\n            var prevNormal = Vector.normalise({ \r\n                x: vertex.y - prevVertex.y, \r\n                y: prevVertex.x - vertex.x\r\n            });\r\n\r\n            var nextNormal = Vector.normalise({ \r\n                x: nextVertex.y - vertex.y, \r\n                y: vertex.x - nextVertex.x\r\n            });\r\n\r\n            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\r\n                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\r\n                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\r\n                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\r\n\r\n            var precision = quality;\r\n\r\n            if (quality === -1) {\r\n                // automatically decide precision\r\n                precision = Math.pow(currentRadius, 0.32) * 1.75;\r\n            }\r\n\r\n            precision = Common.clamp(precision, qualityMin, qualityMax);\r\n\r\n            // use an even value for precision, more likely to reduce axes by using symmetry\r\n            if (precision % 2 === 1)\r\n                precision += 1;\r\n\r\n            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\r\n                theta = alpha / precision;\r\n\r\n            for (var j = 0; j < precision; j++) {\r\n                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\r\n            }\r\n        }\r\n\r\n        return newVertices;\r\n    };\r\n\r\n    /**\r\n     * Sorts the input vertices into clockwise order in place.\r\n     * @method clockwiseSort\r\n     * @param {vertices} vertices\r\n     * @return {vertices} vertices\r\n     */\r\n    Vertices.clockwiseSort = function(vertices) {\r\n        var centre = Vertices.mean(vertices);\r\n\r\n        vertices.sort(function(vertexA, vertexB) {\r\n            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\r\n        });\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\r\n     * @method isConvex\r\n     * @param {vertices} vertices\r\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\r\n     */\r\n    Vertices.isConvex = function(vertices) {\r\n        // http://paulbourke.net/geometry/polygonmesh/\r\n        // Copyright (c) Paul Bourke (use permitted)\r\n\r\n        var flag = 0,\r\n            n = vertices.length,\r\n            i,\r\n            j,\r\n            k,\r\n            z;\r\n\r\n        if (n < 3)\r\n            return null;\r\n\r\n        for (i = 0; i < n; i++) {\r\n            j = (i + 1) % n;\r\n            k = (i + 2) % n;\r\n            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\r\n            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\r\n\r\n            if (z < 0) {\r\n                flag |= 1;\r\n            } else if (z > 0) {\r\n                flag |= 2;\r\n            }\r\n\r\n            if (flag === 3) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (flag !== 0){\r\n            return true;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the convex hull of the input vertices as a new array of points.\r\n     * @method hull\r\n     * @param {vertices} vertices\r\n     * @return [vertex] vertices\r\n     */\r\n    Vertices.hull = function(vertices) {\r\n        // http://geomalgorithms.com/a10-_hull-1.html\r\n\r\n        var upper = [],\r\n            lower = [], \r\n            vertex,\r\n            i;\r\n\r\n        // sort vertices on x-axis (y-axis for ties)\r\n        vertices = vertices.slice(0);\r\n        vertices.sort(function(vertexA, vertexB) {\r\n            var dx = vertexA.x - vertexB.x;\r\n            return dx !== 0 ? dx : vertexA.y - vertexB.y;\r\n        });\r\n\r\n        // build lower hull\r\n        for (i = 0; i < vertices.length; i += 1) {\r\n            vertex = vertices[i];\r\n\r\n            while (lower.length >= 2 \r\n                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\r\n                lower.pop();\r\n            }\r\n\r\n            lower.push(vertex);\r\n        }\r\n\r\n        // build upper hull\r\n        for (i = vertices.length - 1; i >= 0; i -= 1) {\r\n            vertex = vertices[i];\r\n\r\n            while (upper.length >= 2 \r\n                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\r\n                upper.pop();\r\n            }\r\n\r\n            upper.push(vertex);\r\n        }\r\n\r\n        // concatenation of the lower and upper hulls gives the convex hull\r\n        // omit last points because they are repeated at the beginning of the other list\r\n        upper.pop();\r\n        lower.pop();\r\n\r\n        return upper.concat(lower);\r\n    };\r\n\r\n})();\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Vertices","Vector","Common","create","Vertices.create","points","body","vertices","i","length","point","vertex","x","y","index","isInternal","contact","normalImpulse","tangentImpulse","push","fromPath","Vertices.fromPath","path","replace","pathPattern","match","parseFloat","centre","Vertices.centre","area","cross","j","temp","mult","add","div","mean","Vertices.mean","average","Vertices.area","signed","Math","abs","inertia","Vertices.inertia","mass","numerator","denominator","n","dot","translate","Vertices.translate","vector","scalar","rotate","Vertices.rotate","angle","cos","sin","vertice","dx","dy","contains","Vertices.contains","nextVertice","scale","Vertices.scale","scaleX","scaleY","delta","sub","chamfer","Vertices.chamfer","radius","quality","qualityMin","qualityMax","newVertices","prevVertex","nextVertex","currentRadius","prevNormal","normalise","nextNormal","diagonalRadius","sqrt","pow","radiusVector","clone","midNormal","scaledVertex","precision","clamp","theta","acos","alpha","clockwiseSort","Vertices.clockwiseSort","sort","vertexA","vertexB","isConvex","Vertices.isConvex","flag","k","z","hull","Vertices.hull","upper","lower","slice","cross3","pop","concat"]
}
