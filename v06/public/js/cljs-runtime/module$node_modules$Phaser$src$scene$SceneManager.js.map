{
"version":3,
"file":"module$node_modules$Phaser$src$scene$SceneManager.js",
"lineCount":23,
"mappings":"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",
"sources":["node_modules/Phaser/src/scene/SceneManager.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$scene$SceneManager\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar GetValue = require('../utils/object/GetValue');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Scene = require('./Scene');\r\nvar Systems = require('./Systems');\r\n\r\n/**\r\n * @classdesc\r\n * The Scene Manager.\r\n *\r\n * The Scene Manager is a Game level system, responsible for creating, processing and updating all of the\r\n * Scenes in a Game instance.\r\n *\r\n *\r\n * @class SceneManager\r\n * @memberOf Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Scene Manager belongs to.\r\n * @param {object} sceneConfig - Scene specific configuration settings.\r\n */\r\nvar SceneManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function SceneManager (game, sceneConfig)\r\n    {\r\n        /**\r\n         * The Game that this SceneManager belongs to.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#keys\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.keys = {};\r\n\r\n        /**\r\n         * The array in which all of the scenes are kept.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#scenes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.scenes = [];\r\n\r\n        /**\r\n         * Scenes pending to be added are stored in here until the manager has time to add it.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_pending\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._pending = [];\r\n\r\n        /**\r\n         * An array of scenes waiting to be started once the game has booted.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_start\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._start = [];\r\n\r\n        /**\r\n         * An operations queue, because we don't manipulate the scenes array during processing.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_queue\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._queue = [];\r\n\r\n        /**\r\n         * Boot time data to merge.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_data\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._data = {};\r\n\r\n        /**\r\n         * Is the Scene Manager actively processing the Scenes list?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isProcessing\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */\r\n        this.isProcessing = false;\r\n\r\n        /**\r\n         * Has the Scene Manager properly started?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isBooted\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readOnly\r\n         * @since 3.4.0\r\n         */\r\n        this.isBooted = false;\r\n\r\n        /**\r\n         * Do any of the Cameras in any of the Scenes require a custom viewport?\r\n         * If not we can skip scissor tests.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#customViewports\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.12.0\r\n         */\r\n        this.customViewports = 0;\r\n\r\n        if (sceneConfig)\r\n        {\r\n            if (!Array.isArray(sceneConfig))\r\n            {\r\n                sceneConfig = [ sceneConfig ];\r\n            }\r\n\r\n            for (var i = 0; i < sceneConfig.length; i++)\r\n            {\r\n                //  The i === 0 part just autostarts the first Scene given (unless it says otherwise in its config)\r\n                this._pending.push({\r\n                    key: 'default',\r\n                    scene: sceneConfig[i],\r\n                    autoStart: (i === 0),\r\n                    data: {}\r\n                });\r\n            }\r\n        }\r\n\r\n        game.events.once('ready', this.bootQueue, this);\r\n    },\r\n\r\n    /**\r\n     * Internal first-time Scene boot handler.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootQueue\r\n     * @private\r\n     * @since 3.2.0\r\n     */\r\n    bootQueue: function ()\r\n    {\r\n        if (this.isBooted)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var entry;\r\n        var key;\r\n        var sceneConfig;\r\n\r\n        for (i = 0; i < this._pending.length; i++)\r\n        {\r\n            entry = this._pending[i];\r\n\r\n            key = entry.key;\r\n            sceneConfig = entry.scene;\r\n\r\n            var newScene;\r\n\r\n            if (sceneConfig instanceof Scene)\r\n            {\r\n                newScene = this.createSceneFromInstance(key, sceneConfig);\r\n            }\r\n            else if (typeof sceneConfig === 'object')\r\n            {\r\n                newScene = this.createSceneFromObject(key, sceneConfig);\r\n            }\r\n            else if (typeof sceneConfig === 'function')\r\n            {\r\n                newScene = this.createSceneFromFunction(key, sceneConfig);\r\n            }\r\n\r\n            //  Replace key in case the scene changed it\r\n            key = newScene.sys.settings.key;\r\n\r\n            this.keys[key] = newScene;\r\n\r\n            this.scenes.push(newScene);\r\n\r\n            //  Any data to inject?\r\n            if (this._data[key])\r\n            {\r\n                newScene.sys.settings.data = this._data[key].data;\r\n\r\n                if (this._data[key].autoStart)\r\n                {\r\n                    entry.autoStart = true;\r\n                }\r\n            }\r\n\r\n            if (entry.autoStart || newScene.sys.settings.active)\r\n            {\r\n                this._start.push(key);\r\n            }\r\n        }\r\n\r\n        //  Clear the pending lists\r\n        this._pending.length = 0;\r\n\r\n        this._data = {};\r\n\r\n        this.isBooted = true;\r\n\r\n        //  _start might have been populated by the above\r\n        for (i = 0; i < this._start.length; i++)\r\n        {\r\n            entry = this._start[i];\r\n\r\n            this.start(entry);\r\n        }\r\n\r\n        this._start.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Process the Scene operations queue.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#processQueue\r\n     * @since 3.0.0\r\n     */\r\n    processQueue: function ()\r\n    {\r\n        var pendingLength = this._pending.length;\r\n        var queueLength = this._queue.length;\r\n\r\n        if (pendingLength === 0 && queueLength === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var entry;\r\n\r\n        if (pendingLength)\r\n        {\r\n            for (i = 0; i < pendingLength; i++)\r\n            {\r\n                entry = this._pending[i];\r\n\r\n                this.add(entry.key, entry.scene, entry.autoStart, entry.data);\r\n            }\r\n\r\n            //  _start might have been populated by this.add\r\n            for (i = 0; i < this._start.length; i++)\r\n            {\r\n                entry = this._start[i];\r\n\r\n                this.start(entry);\r\n            }\r\n\r\n            //  Clear the pending lists\r\n            this._start.length = 0;\r\n            this._pending.length = 0;\r\n\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < this._queue.length; i++)\r\n        {\r\n            entry = this._queue[i];\r\n\r\n            this[entry.op](entry.keyA, entry.keyB);\r\n        }\r\n\r\n        this._queue.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Scene into the SceneManager.\r\n     * You must give each Scene a unique key by which you'll identify it.\r\n     *\r\n     * The `sceneConfig` can be:\r\n     *\r\n     * * A `Phaser.Scene` object, or an object that extends it.\r\n     * * A plain JavaScript object\r\n     * * A JavaScript ES6 Class that extends `Phaser.Scene`\r\n     * * A JavaScript ES5 prototype based Class\r\n     * * A JavaScript function\r\n     *\r\n     * If a function is given then a new Scene will be created by calling it.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n     * @param {(Phaser.Scene|Phaser.Scenes.Settings.Config|function)} sceneConfig - The config for the Scene\r\n     * @param {boolean} [autoStart=false] - If `true` the Scene will be started immediately after being added.\r\n     * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.\r\n     *\r\n     * @return {?Phaser.Scene} The added Scene, if it was added immediately, otherwise `null`.\r\n     */\r\n    add: function (key, sceneConfig, autoStart, data)\r\n    {\r\n        if (autoStart === undefined) { autoStart = false; }\r\n        if (data === undefined) { data = {}; }\r\n\r\n        //  If processing or not booted then put scene into a holding pattern\r\n        if (this.isProcessing || !this.isBooted)\r\n        {\r\n            this._pending.push({\r\n                key: key,\r\n                scene: sceneConfig,\r\n                autoStart: autoStart,\r\n                data: data\r\n            });\r\n\r\n            if (!this.isBooted)\r\n            {\r\n                this._data[key] = { data: data };\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        key = this.getKey(key, sceneConfig);\r\n\r\n        var newScene;\r\n\r\n        if (sceneConfig instanceof Scene)\r\n        {\r\n            newScene = this.createSceneFromInstance(key, sceneConfig);\r\n        }\r\n        else if (typeof sceneConfig === 'object')\r\n        {\r\n            sceneConfig.key = key;\r\n\r\n            newScene = this.createSceneFromObject(key, sceneConfig);\r\n        }\r\n        else if (typeof sceneConfig === 'function')\r\n        {\r\n            newScene = this.createSceneFromFunction(key, sceneConfig);\r\n        }\r\n\r\n        //  Any data to inject?\r\n        newScene.sys.settings.data = data;\r\n\r\n        //  Replace key in case the scene changed it\r\n        key = newScene.sys.settings.key;\r\n\r\n        this.keys[key] = newScene;\r\n\r\n        this.scenes.push(newScene);\r\n\r\n        if (autoStart || newScene.sys.settings.active)\r\n        {\r\n            if (this._pending.length)\r\n            {\r\n                this._start.push(key);\r\n            }\r\n            else\r\n            {\r\n                this.start(key);\r\n            }\r\n        }\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Removes a Scene from the SceneManager.\r\n     *\r\n     * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n     * cache and Scene.Systems.destroy is then called on it.\r\n     *\r\n     * If the SceneManager is processing the Scenes when this method is called it will\r\n     * queue the operation for the next update sequence.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#remove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} scene - The Scene to be removed.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'remove', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var sceneToRemove = this.getScene(key);\r\n\r\n            if (!sceneToRemove || sceneToRemove.sys.isTransitioning())\r\n            {\r\n                return this;\r\n            }\r\n\r\n            var index = this.scenes.indexOf(sceneToRemove);\r\n            var sceneKey = sceneToRemove.sys.settings.key;\r\n\r\n            if (index > -1)\r\n            {\r\n                delete this.keys[sceneKey];\r\n                this.scenes.splice(index, 1);\r\n\r\n                if (this._start.indexOf(sceneKey) > -1)\r\n                {\r\n                    index = this._start.indexOf(sceneKey);\r\n                    this._start.splice(index, 1);\r\n                }\r\n\r\n                sceneToRemove.sys.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Boot the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootScene\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to boot.\r\n     */\r\n    bootScene: function (scene)\r\n    {\r\n        var sys = scene.sys;\r\n        var settings = sys.settings;\r\n\r\n        if (scene.init)\r\n        {\r\n            scene.init.call(scene, settings.data);\r\n\r\n            settings.status = CONST.INIT;\r\n\r\n            if (settings.isTransition)\r\n            {\r\n                sys.events.emit('transitioninit', settings.transitionFrom, settings.transitionDuration);\r\n            }\r\n        }\r\n\r\n        var loader;\r\n\r\n        if (sys.load)\r\n        {\r\n            loader = sys.load;\r\n\r\n            loader.reset();\r\n        }\r\n\r\n        if (loader && scene.preload)\r\n        {\r\n            scene.preload.call(scene);\r\n\r\n            //  Is the loader empty?\r\n            if (loader.list.size === 0)\r\n            {\r\n                this.create(scene);\r\n            }\r\n            else\r\n            {\r\n                settings.status = CONST.LOADING;\r\n\r\n                //  Start the loader going as we have something in the queue\r\n                loader.once('complete', this.loadComplete, this);\r\n\r\n                loader.start();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  No preload? Then there was nothing to load either\r\n            this.create(scene);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handles load completion for a Scene's Loader.\r\n     *\r\n     * Starts the Scene that the Loader belongs to.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#loadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading.\r\n     */\r\n    loadComplete: function (loader)\r\n    {\r\n        var scene = loader.scene;\r\n\r\n        // Try to unlock HTML5 sounds every time any loader completes\r\n        if (this.game.sound.onBlurPausedSounds)\r\n        {\r\n            this.game.sound.unlock();\r\n        }\r\n\r\n        this.create(scene);\r\n    },\r\n\r\n    /**\r\n     * Handle payload completion for a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#payloadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading its Scene's payload.\r\n     */\r\n    payloadComplete: function (loader)\r\n    {\r\n        this.bootScene(loader.scene);\r\n    },\r\n\r\n    /**\r\n     * Updates the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - Time elapsed.\r\n     * @param {number} delta - Delta time from the last update.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        this.processQueue();\r\n\r\n        this.isProcessing = true;\r\n\r\n        //  Loop through the active scenes in reverse order\r\n        for (var i = this.scenes.length - 1; i >= 0; i--)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING)\r\n            {\r\n                sys.step(time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Informs the Scenes of the Game being resized.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#resize\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        //  Loop through the scenes in forward order\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            sys.resize(width, height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer to use.\r\n     */\r\n    render: function (renderer)\r\n    {\r\n        //  Loop through the scenes in forward order\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING)\r\n            {\r\n                sys.render(renderer);\r\n            }\r\n        }\r\n\r\n        this.isProcessing = false;\r\n    },\r\n\r\n    /**\r\n     * Calls the given Scene's {@link Phaser.Scene#create} method and updates its status.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#create\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to create.\r\n     */\r\n    create: function (scene)\r\n    {\r\n        var sys = scene.sys;\r\n        var settings = sys.settings;\r\n\r\n        if (scene.create)\r\n        {\r\n            settings.status = CONST.CREATING;\r\n\r\n            scene.create.call(scene, settings.data);\r\n\r\n            if (settings.isTransition)\r\n            {\r\n                sys.events.emit('transitionstart', settings.transitionFrom, settings.transitionDuration);\r\n            }\r\n        }\r\n\r\n        //  If the Scene has an update function we'll set it now, otherwise it'll remain as NOOP\r\n        if (scene.update)\r\n        {\r\n            sys.sceneUpdate = scene.update;\r\n        }\r\n\r\n        settings.status = CONST.RUNNING;\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene from a function.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromFunction\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {function} scene - The function to create the Scene from.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromFunction: function (key, scene)\r\n    {\r\n        var newScene = new scene();\r\n\r\n        if (newScene instanceof Scene)\r\n        {\r\n            var configKey = newScene.sys.settings.key;\r\n\r\n            if (configKey !== '')\r\n            {\r\n                key = configKey;\r\n            }\r\n\r\n            if (this.keys.hasOwnProperty(key))\r\n            {\r\n                throw new Error('Cannot add a Scene with duplicate key: ' + key);\r\n            }\r\n\r\n            return this.createSceneFromInstance(key, newScene);\r\n        }\r\n        else\r\n        {\r\n            newScene.sys = new Systems(newScene);\r\n\r\n            newScene.sys.settings.key = key;\r\n\r\n            newScene.sys.init(this.game);\r\n\r\n            return newScene;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene instance.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromInstance\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {Phaser.Scene} newScene - The Scene instance.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromInstance: function (key, newScene)\r\n    {\r\n        var configKey = newScene.sys.settings.key;\r\n\r\n        if (configKey !== '')\r\n        {\r\n            key = configKey;\r\n        }\r\n        else\r\n        {\r\n            newScene.sys.settings.key = key;\r\n        }\r\n\r\n        newScene.sys.init(this.game);\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene from an Object definition.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromObject\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {(string|Phaser.Scenes.Settings.Config)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromObject: function (key, sceneConfig)\r\n    {\r\n        var newScene = new Scene(sceneConfig);\r\n\r\n        var configKey = newScene.sys.settings.key;\r\n\r\n        if (configKey !== '')\r\n        {\r\n            key = configKey;\r\n        }\r\n        else\r\n        {\r\n            newScene.sys.settings.key = key;\r\n        }\r\n\r\n        newScene.sys.init(this.game);\r\n\r\n        //  Extract callbacks\r\n\r\n        var defaults = [ 'init', 'preload', 'create', 'update', 'render' ];\r\n\r\n        for (var i = 0; i < defaults.length; i++)\r\n        {\r\n            var sceneCallback = GetValue(sceneConfig, defaults[i], null);\r\n\r\n            if (sceneCallback)\r\n            {\r\n                newScene[defaults[i]] = sceneCallback;\r\n            }\r\n        }\r\n\r\n        //  Now let's move across any other functions or properties that may exist in the extend object:\r\n\r\n        /*\r\n        scene: {\r\n            preload: preload,\r\n            create: create,\r\n            extend: {\r\n                hello: 1,\r\n                test: 'atari',\r\n                addImage: addImage\r\n            }\r\n        }\r\n        */\r\n\r\n        if (sceneConfig.hasOwnProperty('extend'))\r\n        {\r\n            for (var propertyKey in sceneConfig.extend)\r\n            {\r\n                var value = sceneConfig.extend[propertyKey];\r\n\r\n                if (propertyKey === 'data' && newScene.hasOwnProperty('data') && typeof value === 'object')\r\n                {\r\n                    //  Populate the DataManager\r\n                    newScene.data.merge(value);\r\n                }\r\n                else if (propertyKey !== 'sys')\r\n                {\r\n                    newScene[propertyKey] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the key of a Scene from a Scene config.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getKey\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to check in the Scene config.\r\n     * @param {(Phaser.Scene|Phaser.Scenes.Settings.Config|function)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {string} The Scene key.\r\n     */\r\n    getKey: function (key, sceneConfig)\r\n    {\r\n        if (!key) { key = 'default'; }\r\n\r\n        if (typeof sceneConfig === 'function')\r\n        {\r\n            return key;\r\n        }\r\n        else if (sceneConfig instanceof Scene)\r\n        {\r\n            key = sceneConfig.sys.settings.key;\r\n        }\r\n        else if (typeof sceneConfig === 'object' && sceneConfig.hasOwnProperty('key'))\r\n        {\r\n            key = sceneConfig.key;\r\n        }\r\n\r\n        //  By this point it's either 'default' or extracted from the Scene\r\n\r\n        if (this.keys.hasOwnProperty(key))\r\n        {\r\n            throw new Error('Cannot add a Scene with duplicate key: ' + key);\r\n        }\r\n        else\r\n        {\r\n            return key;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getScene\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string|Phaser.Scene} key - The Scene to retrieve.\r\n     *\r\n     * @return {?Phaser.Scene} The Scene.\r\n     */\r\n    getScene: function (key)\r\n    {\r\n        if (typeof key === 'string')\r\n        {\r\n            if (this.keys[key])\r\n            {\r\n                return this.keys[key];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (var i = 0; i < this.scenes.length; i++)\r\n            {\r\n                if (key === this.scenes[i])\r\n                {\r\n                    return key;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is active.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is active.\r\n     */\r\n    isActive: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isActive();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is visible.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is visible.\r\n     */\r\n    isVisible: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isVisible();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is sleeping.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is sleeping.\r\n     */\r\n    isSleeping: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isSleeping();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Pauses the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to pause.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its pause event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    pause: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.pause(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to resume.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its resume event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    resume: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.resume(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Puts the given Scene to sleep.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to put to sleep.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its sleep event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    sleep: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene && !scene.sys.isTransitioning())\r\n        {\r\n            scene.sys.sleep(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Awakens the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to wake up.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its wake event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    wake: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.wake(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Runs the given Scene, but does not change the state of this Scene.\r\n     *\r\n     * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n     * If not running at all, it will be started.\r\n     *\r\n     * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n     * Scene, then `run` on the modal Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#run\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The Scene to run.\r\n     * @param {object} [data] - A data object that will be passed to the Scene on start, wake, or resume.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This Scene Manager.\r\n     */\r\n    run: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (!scene)\r\n        {\r\n            for (var i = 0; i < this._pending.length; i++)\r\n            {\r\n                if (this._pending[i].key === key)\r\n                {\r\n                    this.queueOp('start', key, data);\r\n                    break;\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n\r\n        if (scene.sys.isSleeping())\r\n        {\r\n            //  Sleeping?\r\n            scene.sys.wake(data);\r\n        }\r\n        else if (scene.sys.isBooted && !scene.sys.isActive())\r\n        {\r\n            //  Paused?\r\n            scene.sys.resume(data);\r\n        }\r\n        else\r\n        {\r\n            //  Not actually running?\r\n            this.start(key, data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Starts the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to start.\r\n     * @param {object} [data] - Optional data object to pass to Scene.Settings and Scene.init.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    start: function (key, data)\r\n    {\r\n        //  If the Scene Manager is not running, then put the Scene into a holding pattern\r\n        if (!this.isBooted)\r\n        {\r\n            this._data[key] = {\r\n                autoStart: true,\r\n                data: data\r\n            };\r\n\r\n            return this;\r\n        }\r\n\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            //  If the Scene is already running (perhaps they called start from a launched sub-Scene?)\r\n            //  then we close it down before starting it again.\r\n            if (scene.sys.isActive() || scene.sys.isPaused())\r\n            {\r\n                scene.sys.shutdown();\r\n\r\n                scene.sys.start(data);\r\n            }\r\n            else\r\n            {\r\n                scene.sys.start(data);\r\n\r\n                var loader;\r\n    \r\n                if (scene.sys.load)\r\n                {\r\n                    loader = scene.sys.load;\r\n                }\r\n    \r\n                //  Files payload?\r\n                if (loader && scene.sys.settings.hasOwnProperty('pack'))\r\n                {\r\n                    loader.reset();\r\n    \r\n                    if (loader.addPack({ payload: scene.sys.settings.pack }))\r\n                    {\r\n                        scene.sys.settings.status = CONST.LOADING;\r\n    \r\n                        loader.once('complete', this.payloadComplete, this);\r\n    \r\n                        loader.start();\r\n    \r\n                        return this;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.bootScene(scene);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to stop.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    stop: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene && !scene.sys.isTransitioning())\r\n        {\r\n            scene.sys.shutdown();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sleeps one one Scene and starts the other.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#switch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} from - The Scene to sleep.\r\n     * @param {string} to - The Scene to start.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    switch: function (from, to)\r\n    {\r\n        var sceneA = this.getScene(from);\r\n        var sceneB = this.getScene(to);\r\n\r\n        if (sceneA && sceneB && sceneA !== sceneB)\r\n        {\r\n            this.sleep(from);\r\n\r\n            if (this.isSleeping(to))\r\n            {\r\n                this.wake(to);\r\n            }\r\n            else\r\n            {\r\n                this.start(to);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves a Scene by numeric index.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index of the Scene to retrieve.\r\n     *\r\n     * @return {(Phaser.Scene|undefined)} The Scene.\r\n     */\r\n    getAt: function (index)\r\n    {\r\n        return this.scenes[index];\r\n    },\r\n\r\n    /**\r\n     * Retrieves the numeric index of a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The key of the Scene.\r\n     *\r\n     * @return {integer} The index of the Scene.\r\n     */\r\n    getIndex: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        return this.scenes.indexOf(scene);\r\n    },\r\n\r\n    /**\r\n     * Brings a Scene to the top of the Scenes list.\r\n     *\r\n     * This means it will render above all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    bringToTop: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'bringToTop', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var index = this.getIndex(key);\r\n\r\n            if (index !== -1 && index < this.scenes.length)\r\n            {\r\n                var scene = this.getScene(key);\r\n\r\n                this.scenes.splice(index, 1);\r\n                this.scenes.push(scene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends a Scene to the back of the Scenes list.\r\n     *\r\n     * This means it will render below all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    sendToBack: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'sendToBack', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var index = this.getIndex(key);\r\n\r\n            if (index !== -1 && index > 0)\r\n            {\r\n                var scene = this.getScene(key);\r\n\r\n                this.scenes.splice(index, 1);\r\n                this.scenes.unshift(scene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene down one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveDown: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveDown', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(key);\r\n\r\n            if (indexA > 0)\r\n            {\r\n                var indexB = indexA - 1;\r\n                var sceneA = this.getScene(key);\r\n                var sceneB = this.getAt(indexB);\r\n\r\n                this.scenes[indexA] = sceneB;\r\n                this.scenes[indexB] = sceneA;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene up one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveUp: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveUp', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(key);\r\n\r\n            if (indexA < this.scenes.length - 1)\r\n            {\r\n                var indexB = indexA + 1;\r\n                var sceneA = this.getScene(key);\r\n                var sceneB = this.getAt(indexB);\r\n\r\n                this.scenes[indexA] = sceneB;\r\n                this.scenes[indexB] = sceneA;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene so it is immediately above another Scene in the Scenes list.\r\n     *\r\n     * This means it will render over the top of the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveAbove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveAbove: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveAbove', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexB);\r\n\r\n                //  Remove\r\n                this.scenes.splice(indexB, 1);\r\n\r\n                //  Add in new location\r\n                this.scenes.splice(indexA + 1, 0, tempScene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene so it is immediately below another Scene in the Scenes list.\r\n     *\r\n     * This means it will render behind the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveBelow\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveBelow: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveBelow', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexB);\r\n\r\n                //  Remove\r\n                this.scenes.splice(indexB, 1);\r\n\r\n                if (indexA === 0)\r\n                {\r\n                    this.scenes.unshift(tempScene);\r\n                }\r\n                else\r\n                {\r\n                    //  Add in new location\r\n                    this.scenes.splice(indexA, 0, tempScene);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Queue a Scene operation for the next update.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#queueOp\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} op - The operation to perform.\r\n     * @param {(string|Phaser.Scene)} keyA - Scene A.\r\n     * @param {(string|Phaser.Scene)} [keyB] - Scene B.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    queueOp: function (op, keyA, keyB)\r\n    {\r\n        this._queue.push({ op: op, keyA: keyA, keyB: keyB });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the positions of two Scenes in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#swapPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The first Scene to swap.\r\n     * @param {(string|Phaser.Scene)} keyB - The second Scene to swap.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    swapPosition: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'swapPosition', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== indexB && indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexA);\r\n\r\n                this.scenes[indexA] = this.scenes[indexB];\r\n                this.scenes[indexB] = tempScene;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Dumps debug information about each Scene to the developer console.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#dump\r\n     * @since 3.2.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        var out = [];\r\n        var map = [ 'pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed' ];\r\n\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            var key = (sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED)) ? '[*] ' : '[-] ';\r\n            key += sys.settings.key + ' (' + map[sys.settings.status] + ')';\r\n\r\n            out.push(key);\r\n        }\r\n\r\n        console.log(out.join('\\n'));\r\n    },\r\n\r\n    /**\r\n     * Destroy the SceneManager and all of its Scene's systems.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            sys.destroy();\r\n        }\r\n\r\n        this.update = NOOP;\r\n\r\n        this.scenes = [];\r\n\r\n        this._pending = [];\r\n        this._start = [];\r\n        this._queue = [];\r\n\r\n        this.game = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SceneManager;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Class","CONST","GetValue","NOOP","Scene","Systems","SceneManager","initialize","game","sceneConfig","keys","scenes","_pending","_start","_queue","_data","isBooted","isProcessing","customViewports","Array","isArray","i","length","push","key","scene","autoStart","data","events","once","bootQueue","entry","newScene","createSceneFromInstance","createSceneFromObject","createSceneFromFunction","sys","settings","active","start","processQueue","pendingLength","queueLength","add","op","keyA","keyB","undefined","getKey","remove","sceneToRemove","getScene","isTransitioning","index","indexOf","sceneKey","splice","destroy","bootScene","init","call","status","INIT","isTransition","emit","transitionFrom","transitionDuration","load","loader","reset","preload","list","size","create","LOADING","loadComplete","sound","onBlurPausedSounds","unlock","payloadComplete","update","time","delta","START","RUNNING","step","resize","width","height","render","renderer","visible","SLEEPING","CREATING","sceneUpdate","configKey","hasOwnProperty","Error","defaults","sceneCallback","propertyKey","extend","value","merge","isActive","isVisible","isSleeping","pause","resume","sleep","wake","run","queueOp","isPaused","shutdown","addPack","payload","pack","stop","switch","from","to","sceneA","sceneB","getAt","getIndex","bringToTop","sendToBack","unshift","moveDown","indexA","indexB","moveUp","moveAbove","tempScene","moveBelow","swapPosition","dump","out","map","PAUSED","console","log","join"]
}
