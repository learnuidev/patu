shadow$provide.module$node_modules$Phaser$src$physics$matter_js$lib$core$Engine=function(global,require,module,exports){var Engine={};module.exports=Engine;var World=require("module$node_modules$Phaser$src$physics$matter_js$lib$body$World"),Sleeping=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Sleeping"),Resolver=require("module$node_modules$Phaser$src$physics$matter_js$lib$collision$Resolver"),Pairs=require("module$node_modules$Phaser$src$physics$matter_js$lib$collision$Pairs"),
Metrics=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Metrics"),Grid=require("module$node_modules$Phaser$src$physics$matter_js$lib$collision$Grid"),Events=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Events"),Composite=require("module$node_modules$Phaser$src$physics$matter_js$lib$body$Composite"),Constraint=require("module$node_modules$Phaser$src$physics$matter_js$lib$constraint$Constraint"),Common=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Common"),
Body=require("module$node_modules$Phaser$src$physics$matter_js$lib$body$Body");(function(){Engine.create=function(element,options){options=Common.isElement(element)?options:element;element=Common.isElement(element)?element:null;options=options||{};(element||options.render)&&Common.warn("Engine.create: engine.render is deprecated (see docs)");var engine=Common.extend({positionIterations:6,velocityIterations:4,constraintIterations:2,enableSleeping:!1,events:[],plugin:{},timing:{timestamp:0,timeScale:1},
broadphase:{controller:Grid}},options);if(element||engine.render)engine.render=Common.extend({element:element,controller:Render},engine.render);engine.render&&engine.render.controller&&(engine.render=engine.render.controller.create(engine.render));engine.render&&(engine.render.engine=engine);engine.world=options.world||World.create(engine.world);engine.pairs=Pairs.create();engine.broadphase=engine.broadphase.controller.create(engine.broadphase);engine.metrics=engine.metrics||{extended:!1};engine.metrics=
Metrics.create(engine.metrics);return engine};Engine.update=function(engine,delta,correction){delta=delta||1E3/60;correction=correction||1;var world=engine.world,timing=engine.timing,broadphase=engine.broadphase;timing.timestamp+=delta*timing.timeScale;var event={timestamp:timing.timestamp};Events.trigger(engine,"beforeUpdate",event);var allBodies=Composite.allBodies(world),allConstraints=Composite.allConstraints(world);Metrics.reset(engine.metrics);engine.enableSleeping&&Sleeping.update(allBodies,
timing.timeScale);Engine._bodiesApplyGravity(allBodies,world.gravity);Engine._bodiesUpdate(allBodies,delta,timing.timeScale,correction,world.bounds);Constraint.preSolveAll(allBodies);for(delta=0;delta<engine.constraintIterations;delta++)Constraint.solveAll(allConstraints,timing.timeScale);Constraint.postSolveAll(allBodies);broadphase.controller?(world.isModified&&broadphase.controller.clear(broadphase),broadphase.controller.update(broadphase,allBodies,engine,world.isModified),delta=broadphase.pairsList):
delta=allBodies;world.isModified&&Composite.setModified(world,!1,!1,!0);broadphase=broadphase.detector(delta,engine);world=engine.pairs;delta=timing.timestamp;Pairs.update(world,broadphase,delta);Pairs.removeOld(world,delta);engine.enableSleeping&&Sleeping.afterCollisions(world.list,timing.timeScale);0<world.collisionStart.length&&Events.trigger(engine,"collisionStart",{pairs:world.collisionStart});Resolver.preSolvePosition(world.list);for(delta=0;delta<engine.positionIterations;delta++)Resolver.solvePosition(world.list,
allBodies,timing.timeScale);Resolver.postSolvePosition(allBodies);Constraint.preSolveAll(allBodies);for(delta=0;delta<engine.constraintIterations;delta++)Constraint.solveAll(allConstraints,timing.timeScale);Constraint.postSolveAll(allBodies);Resolver.preSolveVelocity(world.list);for(delta=0;delta<engine.velocityIterations;delta++)Resolver.solveVelocity(world.list,timing.timeScale);0<world.collisionActive.length&&Events.trigger(engine,"collisionActive",{pairs:world.collisionActive});0<world.collisionEnd.length&&
Events.trigger(engine,"collisionEnd",{pairs:world.collisionEnd});Metrics.update(engine.metrics,engine);Engine._bodiesClearForces(allBodies);Events.trigger(engine,"afterUpdate",event);return engine};Engine.merge=function(engineA,engineB){Common.extend(engineA,engineB);if(engineB.world)for(engineA.world=engineB.world,Engine.clear(engineA),engineA=Composite.allBodies(engineA.world),engineB=0;engineB<engineA.length;engineB++){var body=engineA[engineB];Sleeping.set(body,!1);body.id=Common.nextId()}};Engine.clear=
function(engine){var world=engine.world;Pairs.clear(engine.pairs);var broadphase=engine.broadphase;broadphase.controller&&(world=Composite.allBodies(world),broadphase.controller.clear(broadphase),broadphase.controller.update(broadphase,world,engine,!0))};Engine._bodiesClearForces=function(bodies){for(var i=0;i<bodies.length;i++){var body=bodies[i];body.force.x=0;body.force.y=0;body.torque=0}};Engine._bodiesApplyGravity=function(bodies,gravity){var gravityScale="undefined"!==typeof gravity.scale?gravity.scale:
.001;if((0!==gravity.x||0!==gravity.y)&&0!==gravityScale)for(var i=0;i<bodies.length;i++){var body=bodies[i];body.ignoreGravity||body.isStatic||body.isSleeping||(body.force.y+=body.mass*gravity.y*gravityScale,body.force.x+=body.mass*gravity.x*gravityScale)}};Engine._bodiesUpdate=function(bodies,deltaTime,timeScale,correction,worldBounds){for(worldBounds=0;worldBounds<bodies.length;worldBounds++){var body=bodies[worldBounds];body.isStatic||body.isSleeping||Body.update(body,deltaTime,timeScale,correction)}}})()}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$lib$core$Engine.js.map
