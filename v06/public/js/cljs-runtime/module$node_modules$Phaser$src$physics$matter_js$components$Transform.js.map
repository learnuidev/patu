{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$components$Transform.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/matter-js/components/Transform.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$components$Transform\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Body = require('../lib/body/Body');\r\nvar MATH_CONST = require('../../../math/const');\r\nvar WrapAngle = require('../../../math/angle/Wrap');\r\nvar WrapAngleDegrees = require('../../../math/angle/WrapDegrees');\r\n\r\n//  global bitmask flag for GameObject.renderMask (used by Scale)\r\nvar _FLAG = 4; // 0100\r\n\r\n//  Transform Component\r\n\r\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @name Phaser.Physics.Matter.Components.Transform\r\n * @since 3.0.0\r\n */\r\nvar Transform = {\r\n\r\n    /**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.position.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tempVec2.set(value, this.y);\r\n\r\n            Body.setPosition(this.body, this._tempVec2);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.position.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tempVec2.set(this.x, value);\r\n\r\n            Body.setPosition(this.body, this._tempVec2);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var factor = 1 / this._scaleX;\r\n\r\n            this._scaleX = value;\r\n\r\n            if (this._scaleX === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n\r\n            //  Reset Matter scale back to 1 (sigh)\r\n            Body.scale(this.body, factor, this._scaleY);\r\n\r\n            Body.scale(this.body, value, this._scaleY);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var factor = 1 / this._scaleY;\r\n\r\n            this._scaleY = value;\r\n\r\n            if (this._scaleY === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n\r\n            Body.scale(this.body, this._scaleX, factor);\r\n\r\n            Body.scale(this.body, this._scaleX, value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Use `angle` to set or get rotation of the physics body associated to this GameObject. Unlike rotation, when using set the value can be in degrees, which will be converted to radians internally.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#angle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in degrees\r\n            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Use `rotation` to set or get the rotation of the physics body associated with this GameObject. The value when set must be in radians.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.angle;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in radians\r\n            this._rotation = WrapAngle(value);\r\n\r\n            Body.setAngle(this.body, this._rotation);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the position of the physics body along x and y axes. Both the parameters to this function are optional and if not passed any they default to 0.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of the body.\r\n     * @param {number} [y=x] - The vertical position of the body.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this._tempVec2.set(x, y);\r\n\r\n        Body.setPosition(this.body, this._tempVec2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - [description]\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setRotation: function (radians)\r\n    {\r\n        if (radians === undefined) { radians = 0; }\r\n\r\n        this._rotation = WrapAngle(radians);\r\n\r\n        Body.setAngle(this.body, radians);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setFixedRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setFixedRotation: function ()\r\n    {\r\n        Body.setInertia(this.body, Infinity);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - [description]\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAngle: function (degrees)\r\n    {\r\n        if (degrees === undefined) { degrees = 0; }\r\n\r\n        this.angle = degrees;\r\n\r\n        Body.setAngle(this.body, this.rotation);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of this Game Object.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=1] - The horizontal scale of this Game Object.\r\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the x value.\r\n     * @param {Phaser.Math.Vector2} [point] - The point (Vector2) from which scaling will occur.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setScale: function (x, y, point)\r\n    {\r\n        if (x === undefined) { x = 1; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        var factorX = 1 / this._scaleX;\r\n        var factorY = 1 / this._scaleY;\r\n\r\n        this._scaleX = x;\r\n        this._scaleY = y;\r\n\r\n        Body.scale(this.body, factorX, factorY, point);\r\n\r\n        Body.scale(this.body, x, y, point);\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Transform;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Body","MATH_CONST","WrapAngle","WrapAngleDegrees","Transform","x","get","body","position","set","value","_tempVec2","y","setPosition","scaleX","_scaleX","factor","renderFlags","_FLAG","scale","_scaleY","scaleY","angle","RAD_TO_DEG","rotation","DEG_TO_RAD","_rotation","setAngle","undefined","setRotation","radians","setFixedRotation","setInertia","Infinity","degrees","setScale","point","factorX","factorY"]
}
