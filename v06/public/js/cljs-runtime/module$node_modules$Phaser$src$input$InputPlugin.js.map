{
"version":3,
"file":"module$node_modules$Phaser$src$input$InputPlugin.js",
"lineCount":39,
"mappings":"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",
"sources":["node_modules/Phaser/src/input/InputPlugin.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$input$InputPlugin\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Circle = require('../geom/circle/Circle');\r\nvar CircleContains = require('../geom/circle/Contains');\r\nvar Class = require('../utils/Class');\r\nvar CreateInteractiveObject = require('./CreateInteractiveObject');\r\nvar CreatePixelPerfectHandler = require('./CreatePixelPerfectHandler');\r\nvar DistanceBetween = require('../math/distance/DistanceBetween');\r\nvar Ellipse = require('../geom/ellipse/Ellipse');\r\nvar EllipseContains = require('../geom/ellipse/Contains');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar InputPluginCache = require('./InputPluginCache');\r\nvar IsPlainObject = require('../utils/object/IsPlainObject');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar RectangleContains = require('../geom/rectangle/Contains');\r\nvar Triangle = require('../geom/triangle/Triangle');\r\nvar TriangleContains = require('../geom/triangle/Contains');\r\n\r\n/**\r\n * @classdesc\r\n * The Input Plugin belongs to a Scene and handles all input related events and operations for it.\r\n *\r\n * You can access it from within a Scene using `this.input`.\r\n *\r\n * It emits events directly. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * To listen for a pointer down event anywhere on the game canvas.\r\n *\r\n * Game Objects can be enabled for input by calling their `setInteractive` method. After which they\r\n * will directly emit input events:\r\n *\r\n * ```javascript\r\n * var sprite = this.add.sprite(x, y, texture);\r\n * sprite.setInteractive();\r\n * sprite.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * Please see the Input examples and tutorials for more information.\r\n *\r\n * @class InputPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this Input Plugin is responsible for.\r\n */\r\nvar InputPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function InputPlugin (scene)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems class.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#settings\r\n         * @type {Phaser.Scenes.Settings.Object}\r\n         * @since 3.5.0\r\n         */\r\n        this.settings = scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Game Input Manager.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = scene.sys.game.input;\r\n\r\n        /**\r\n         * Internal event queue used for plugins only.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pluginEvents\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.pluginEvents = new EventEmitter();\r\n\r\n        /**\r\n         * If set, the Input Plugin will run its update loop every frame.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.5.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * A reference to the Scene Display List. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList;\r\n\r\n        /**\r\n         * A reference to the Scene Cameras Manager. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#cameras\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.cameras;\r\n\r\n        //  Inject the available input plugins into this class\r\n        InputPluginCache.install(this);\r\n\r\n        /**\r\n         * A reference to the Mouse Manager.\r\n         * \r\n         * This property is only set if Mouse support has been enabled in your Game Configuration file.\r\n         * \r\n         * If you just wish to get access to the mouse pointer, use the `mousePointer` property instead.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#mouse\r\n         * @type {?Phaser.Input.Mouse.MouseManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.mouse = this.manager.mouse;\r\n\r\n        /**\r\n         * When set to `true` (the default) the Input Plugin will emulate DOM behavior by only emitting events from\r\n         * the top-most Game Objects in the Display List.\r\n         *\r\n         * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#topOnly\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.topOnly = true;\r\n\r\n        /**\r\n         * How often should the Pointers be checked?\r\n         * \r\n         * The value is a time, given in ms, and is the time that must have elapsed between game steps before\r\n         * the Pointers will be polled again. When a pointer is polled it runs a hit test to see which Game\r\n         * Objects are currently below it, or being interacted with it.\r\n         * \r\n         * Pointers will *always* be checked if they have been moved by the user, or press or released.\r\n         * \r\n         * This property only controls how often they will be polled if they have not been updated.\r\n         * You should set this if you want to have Game Objects constantly check against the pointers, even\r\n         * if the pointer didn't move itself.\r\n         * \r\n         * Set to 0 to poll constantly. Set to -1 to only poll on user movement.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pollRate\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.pollRate = -1;\r\n\r\n        /**\r\n         * Internal poll timer value.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pollTimer\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._pollTimer = 0;\r\n\r\n        var _eventData = { cancelled: false };\r\n\r\n        /**\r\n         * Internal event propagation callback container.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventContainer\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventContainer = {\r\n            stopPropagation: function ()\r\n            {\r\n                _eventData.cancelled = true;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Internal event propagation data object.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventData\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventData = _eventData;\r\n\r\n        /**\r\n         * The distance, in pixels, a pointer has to move while being held down, before it thinks it is being dragged.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragDistanceThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragDistanceThreshold = 0;\r\n\r\n        /**\r\n         * The amount of time, in ms, a pointer has to be held down before it thinks it is dragging.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragTimeThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragTimeThreshold = 0;\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_temp\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._temp = [];\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test dropZones\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_tempZones\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._tempZones = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been set to be interactive in the Scene this Input Plugin is managing.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._list = [];\r\n\r\n        /**\r\n         * Objects waiting to be inserted to the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingInsertion\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingInsertion = [];\r\n\r\n        /**\r\n         * Objects waiting to be removed from the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingRemoval\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingRemoval = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been enabled for dragging.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_draggable\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._draggable = [];\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_drag\r\n         * @type {{0:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_over\r\n         * @type {{0:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A list of valid DOM event types.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_validTypes\r\n         * @type {string[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._validTypes = [ 'onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop' ];\r\n\r\n        scene.sys.events.once('boot', this.boot, this);\r\n        scene.sys.events.on('start', this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.cameras = this.systems.cameras;\r\n\r\n        this.displayList = this.systems.displayList;\r\n\r\n        this.systems.events.once('destroy', this.destroy, this);\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit('boot');\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on('transitionstart', this.transitionIn, this);\r\n        eventEmitter.on('transitionout', this.transitionOut, this);\r\n        eventEmitter.on('transitioncomplete', this.transitionComplete, this);\r\n        eventEmitter.on('preupdate', this.preUpdate, this);\r\n        eventEmitter.on('update', this.update, this);\r\n\r\n        eventEmitter.once('shutdown', this.shutdown, this);\r\n\r\n        this.enabled = true;\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit('start');\r\n    },\r\n\r\n    /**\r\n     * The pre-update handler is responsible for checking the pending removal and insertion lists and\r\n     * deleting old Game Objects.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#preUpdate\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit('preUpdate');\r\n\r\n        var removeList = this._pendingRemoval;\r\n        var insertList = this._pendingInsertion;\r\n\r\n        var toRemove = removeList.length;\r\n        var toInsert = insertList.length;\r\n\r\n        if (toRemove === 0 && toInsert === 0)\r\n        {\r\n            //  Quick bail\r\n            return;\r\n        }\r\n\r\n        var current = this._list;\r\n\r\n        //  Delete old gameObjects\r\n        for (var i = 0; i < toRemove; i++)\r\n        {\r\n            var gameObject = removeList[i];\r\n\r\n            var index = current.indexOf(gameObject);\r\n\r\n            if (index > -1)\r\n            {\r\n                current.splice(index, 1);\r\n\r\n                this.clear(gameObject);\r\n            }\r\n        }\r\n\r\n        //  Clear the removal list\r\n        removeList.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n\r\n        //  Move pendingInsertion to list (also clears pendingInsertion at the same time)\r\n        this._list = current.concat(insertList.splice(0));\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * The internal update loop for the Input Plugin.\r\n     * Called automatically by the Scene Systems step.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#update\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n     * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.isActive())\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.pluginEvents.emit('update', time, delta);\r\n\r\n        var manager = this.manager;\r\n\r\n        //  Another Scene above this one has already consumed the input events, or we're in transition\r\n        if (manager.globalTopOnly && manager.ignoreEvents)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var runUpdate = (manager.dirty || this.pollRate === 0);\r\n\r\n        if (this.pollRate > -1)\r\n        {\r\n            this._pollTimer -= delta;\r\n\r\n            if (this._pollTimer < 0)\r\n            {\r\n                runUpdate = true;\r\n\r\n                //  Discard timer diff\r\n                this._pollTimer = this.pollRate;\r\n            }\r\n        }\r\n\r\n        if (!runUpdate)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var pointers = this.manager.pointers;\r\n\r\n        for (var i = 0; i < this.manager.pointersTotal; i++)\r\n        {\r\n            var pointer = pointers[i];\r\n\r\n            //  Always reset this array\r\n            this._tempZones = [];\r\n\r\n            //  _temp contains a hit tested and camera culled list of IO objects\r\n            this._temp = this.hitTestPointer(pointer);\r\n\r\n            this.sortGameObjects(this._temp);\r\n            this.sortGameObjects(this._tempZones);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                //  Only the top-most one counts now, so safely ignore the rest\r\n                if (this._temp.length)\r\n                {\r\n                    this._temp.splice(1);\r\n                }\r\n\r\n                if (this._tempZones.length)\r\n                {\r\n                    this._tempZones.splice(1);\r\n                }\r\n            }\r\n\r\n            var total = this.processDragEvents(pointer, time);\r\n\r\n            //  TODO: Enable for touch\r\n            if (!pointer.wasTouch)\r\n            {\r\n                total += this.processOverOutEvents(pointer);\r\n            }\r\n\r\n            if (pointer.justDown)\r\n            {\r\n                total += this.processDownEvents(pointer);\r\n            }\r\n\r\n            if (pointer.justUp)\r\n            {\r\n                total += this.processUpEvents(pointer);\r\n            }\r\n\r\n            if (pointer.justMoved)\r\n            {\r\n                total += this.processMoveEvents(pointer);\r\n            }\r\n\r\n            if (total > 0 && manager.globalTopOnly)\r\n            {\r\n                //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\r\n                manager.ignoreEvents = true;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Clears a Game Object so it no longer has an Interactive Object associated with it.\r\n     * The Game Object is then queued for removal from the Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will have its Interactive Object removed.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that had its Interactive Object removed.\r\n     */\r\n    clear: function (gameObject)\r\n    {\r\n        var input = gameObject.input;\r\n\r\n        // If GameObject.input already cleared from higher class\r\n        if (!input)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.queueForRemoval(gameObject);\r\n\r\n        input.gameObject = undefined;\r\n        input.target = undefined;\r\n        input.hitArea = undefined;\r\n        input.hitAreaCallback = undefined;\r\n        input.callbackContext = undefined;\r\n\r\n        this.manager.resetCursor(input);\r\n\r\n        gameObject.input = null;\r\n\r\n        //  Clear from _draggable, _drag and _over\r\n        var index = this._draggable.indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._draggable.splice(index, 1);\r\n        }\r\n\r\n        index = this._drag[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._drag[0].splice(index, 1);\r\n        }\r\n\r\n        index = this._over[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._over[0].splice(index, 1);\r\n        }\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Disables Input on a single Game Object.\r\n     *\r\n     * An input disabled Game Object still retains its Interactive Object component and can be re-enabled\r\n     * at any time, by passing it to `InputPlugin.enable`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to have its input system disabled.\r\n     */\r\n    disable: function (gameObject)\r\n    {\r\n        gameObject.input.enabled = false;\r\n    },\r\n\r\n    /**\r\n     * Enable a Game Object for interaction.\r\n     *\r\n     * If the Game Object already has an Interactive Object component, it is enabled and returned.\r\n     *\r\n     * Otherwise, a new Interactive Object component is created and assigned to the Game Object's `input` property.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to be enabled for input.\r\n     * @param {(Phaser.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     * @param {boolean} [dropZone=false] - Is this Game Object a drop zone or not?\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This Input Plugin.\r\n     */\r\n    enable: function (gameObject, shape, callback, dropZone)\r\n    {\r\n        if (dropZone === undefined) { dropZone = false; }\r\n\r\n        if (gameObject.input)\r\n        {\r\n            //  If it is already has an InteractiveObject then just enable it and return\r\n            gameObject.input.enabled = true;\r\n        }\r\n        else\r\n        {\r\n            //  Create an InteractiveObject and enable it\r\n            this.setHitArea(gameObject, shape, callback);\r\n        }\r\n\r\n        if (gameObject.input && dropZone && !gameObject.input.dropZone)\r\n        {\r\n            gameObject.input.dropZone = dropZone;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes the given Pointer and performs a hit test against it, to see which interactive Game Objects\r\n     * it is currently above.\r\n     *\r\n     * The hit test is performed against which-ever Camera the Pointer is over. If it is over multiple\r\n     * cameras, it starts checking the camera at the top of the camera list, and if nothing is found, iterates down the list.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#hitTestPointer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of all the interactive Game Objects the Pointer was above.\r\n     */\r\n    hitTestPointer: function (pointer)\r\n    {\r\n        var cameras = this.cameras.getCamerasBelowPointer(pointer);\r\n\r\n        for (var c = 0; c < cameras.length; c++)\r\n        {\r\n            var camera = cameras[c];\r\n\r\n            //  Get a list of all objects that can be seen by the camera below the pointer in the scene and store in 'over' array.\r\n            //  All objects in this array are input enabled, as checked by the hitTest method, so we don't need to check later on as well.\r\n            var over = this.manager.hitTest(pointer, this._list, camera);\r\n\r\n            //  Filter out the drop zones\r\n            for (var i = 0; i < over.length; i++)\r\n            {\r\n                var obj = over[i];\r\n\r\n                if (obj.input.dropZone)\r\n                {\r\n                    this._tempZones.push(obj);\r\n                }\r\n            }\r\n\r\n            if (over.length > 0)\r\n            {\r\n                pointer.camera = camera;\r\n\r\n                return over;\r\n            }\r\n        }\r\n\r\n        //  If we got this far then there were no Game Objects below the pointer, but it was still over\r\n        //  a camera, so set that the top-most one into the pointer\r\n\r\n        pointer.camera = cameras[0];\r\n\r\n        return [];\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer down event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDownEvents\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer being tested.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processDownEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit('pointerdown', pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit('gameobjectdown', pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //  Contains ALL Game Objects currently over in the array\r\n        if (!aborted)\r\n        {\r\n            this.emit('pointerdown', pointer, currentlyOver);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer drag events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragEvents\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n     * @param {number} time - The time stamp of the most recent Game step.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processDragEvents: function (pointer, time)\r\n    {\r\n        if (this._draggable.length === 0)\r\n        {\r\n            //  There are no draggable items, so let's not even bother going further\r\n            return 0;\r\n        }\r\n\r\n        var i;\r\n        var gameObject;\r\n        var list;\r\n        var input;\r\n        var currentlyOver = this._temp;\r\n\r\n        //  0 = Not dragging anything\r\n        //  1 = Primary button down and objects below, so collect a draglist\r\n        //  2 = Pointer being checked if meets drag criteria\r\n        //  3 = Pointer meets criteria, notify the draglist\r\n        //  4 = Pointer actively dragging the draglist and has moved\r\n        //  5 = Pointer actively dragging but has been released, notify draglist\r\n\r\n        if (pointer.dragState === 0 && pointer.primaryDown && pointer.justDown && currentlyOver.length > 0)\r\n        {\r\n            pointer.dragState = 1;\r\n        }\r\n        else if (pointer.dragState > 0 && !pointer.primaryDown && pointer.justUp)\r\n        {\r\n            pointer.dragState = 5;\r\n        }\r\n\r\n        //  Process the various drag states\r\n\r\n        //  1 = Primary button down and objects below, so collect a draglist\r\n        if (pointer.dragState === 1)\r\n        {\r\n            //  Get draggable objects, sort them, pick the top (or all) and store them somewhere\r\n            var draglist = [];\r\n\r\n            for (i = 0; i < currentlyOver.length; i++)\r\n            {\r\n                gameObject = currentlyOver[i];\r\n\r\n                if (gameObject.input.draggable && (gameObject.input.dragState === 0))\r\n                {\r\n                    draglist.push(gameObject);\r\n                }\r\n            }\r\n\r\n            if (draglist.length === 0)\r\n            {\r\n                pointer.dragState = 0;\r\n\r\n                return 0;\r\n            }\r\n            else if (draglist.length > 1)\r\n            {\r\n                this.sortGameObjects(draglist);\r\n\r\n                if (this.topOnly)\r\n                {\r\n                    draglist.splice(1);\r\n                }\r\n            }\r\n\r\n            //  draglist now contains all potential candidates for dragging\r\n            this._drag[pointer.id] = draglist;\r\n\r\n            if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0)\r\n            {\r\n                //  No drag criteria, so snap immediately to mode 3\r\n                pointer.dragState = 3;\r\n            }\r\n            else\r\n            {\r\n                //  Check the distance / time\r\n                pointer.dragState = 2;\r\n            }\r\n        }\r\n\r\n        //  2 = Pointer being checked if meets drag criteria\r\n        if (pointer.dragState === 2)\r\n        {\r\n            //  Has it moved far enough to be considered a drag?\r\n            if (this.dragDistanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= this.dragDistanceThreshold)\r\n            {\r\n                //  Alrighty, we've got a drag going on ...\r\n                pointer.dragState = 3;\r\n            }\r\n\r\n            //  Held down long enough to be considered a drag?\r\n            if (this.dragTimeThreshold > 0 && (time >= pointer.downTime + this.dragTimeThreshold))\r\n            {\r\n                //  Alrighty, we've got a drag going on ...\r\n                pointer.dragState = 3;\r\n            }\r\n        }\r\n\r\n        //  3 = Pointer meets criteria and is freshly down, notify the draglist\r\n        if (pointer.dragState === 3)\r\n        {\r\n            list = this._drag[pointer.id];\r\n\r\n            for (i = 0; i < list.length; i++)\r\n            {\r\n                gameObject = list[i];\r\n\r\n                input = gameObject.input;\r\n\r\n                input.dragState = 2;\r\n\r\n                input.dragX = pointer.x - gameObject.x;\r\n                input.dragY = pointer.y - gameObject.y;\r\n\r\n                input.dragStartX = gameObject.x;\r\n                input.dragStartY = gameObject.y;\r\n\r\n                gameObject.emit('dragstart', pointer, input.dragX, input.dragY);\r\n\r\n                this.emit('dragstart', pointer, gameObject);\r\n            }\r\n\r\n            pointer.dragState = 4;\r\n\r\n            return list.length;\r\n        }\r\n\r\n        //  4 = Pointer actively dragging the draglist and has moved\r\n        if (pointer.dragState === 4 && pointer.justMoved && !pointer.justUp)\r\n        {\r\n            var dropZones = this._tempZones;\r\n\r\n            list = this._drag[pointer.id];\r\n\r\n            for (i = 0; i < list.length; i++)\r\n            {\r\n                gameObject = list[i];\r\n\r\n                input = gameObject.input;\r\n\r\n                //  If this GO has a target then let's check it\r\n                if (input.target)\r\n                {\r\n                    var index = dropZones.indexOf(input.target);\r\n\r\n                    //  Got a target, are we still over it?\r\n                    if (index === 0)\r\n                    {\r\n                        //  We're still over it, and it's still the top of the display list, phew ...\r\n                        gameObject.emit('dragover', pointer, input.target);\r\n\r\n                        this.emit('dragover', pointer, gameObject, input.target);\r\n                    }\r\n                    else if (index > 0)\r\n                    {\r\n                        //  Still over it but it's no longer top of the display list (targets must always be at the top)\r\n                        gameObject.emit('dragleave', pointer, input.target);\r\n\r\n                        this.emit('dragleave', pointer, gameObject, input.target);\r\n\r\n                        input.target = dropZones[0];\r\n\r\n                        gameObject.emit('dragenter', pointer, input.target);\r\n\r\n                        this.emit('dragenter', pointer, gameObject, input.target);\r\n                    }\r\n                    else\r\n                    {\r\n                        //  Nope, we've moved on (or the target has!), leave the old target\r\n                        gameObject.emit('dragleave', pointer, input.target);\r\n\r\n                        this.emit('dragleave', pointer, gameObject, input.target);\r\n\r\n                        //  Anything new to replace it?\r\n                        //  Yup!\r\n                        if (dropZones[0])\r\n                        {\r\n                            input.target = dropZones[0];\r\n\r\n                            gameObject.emit('dragenter', pointer, input.target);\r\n\r\n                            this.emit('dragenter', pointer, gameObject, input.target);\r\n                        }\r\n                        else\r\n                        {\r\n                            //  Nope\r\n                            input.target = null;\r\n                        }\r\n                    }\r\n                }\r\n                else if (!input.target && dropZones[0])\r\n                {\r\n                    input.target = dropZones[0];\r\n\r\n                    gameObject.emit('dragenter', pointer, input.target);\r\n\r\n                    this.emit('dragenter', pointer, gameObject, input.target);\r\n                }\r\n\r\n                var dragX = pointer.x - gameObject.input.dragX;\r\n                var dragY = pointer.y - gameObject.input.dragY;\r\n\r\n                gameObject.emit('drag', pointer, dragX, dragY);\r\n\r\n                this.emit('drag', pointer, gameObject, dragX, dragY);\r\n            }\r\n\r\n            return list.length;\r\n        }\r\n\r\n        //  5 = Pointer was actively dragging but has been released, notify draglist\r\n        if (pointer.dragState === 5)\r\n        {\r\n            list = this._drag[pointer.id];\r\n\r\n            for (i = 0; i < list.length; i++)\r\n            {\r\n                gameObject = list[i];\r\n\r\n                input = gameObject.input;\r\n\r\n                if (input.dragState === 2)\r\n                {\r\n                    input.dragState = 0;\r\n\r\n                    input.dragX = input.localX - gameObject.displayOriginX;\r\n                    input.dragY = input.localY - gameObject.displayOriginY;\r\n\r\n                    var dropped = false;\r\n\r\n                    if (input.target)\r\n                    {\r\n                        gameObject.emit('drop', pointer, input.target);\r\n\r\n                        this.emit('drop', pointer, gameObject, input.target);\r\n\r\n                        input.target = null;\r\n\r\n                        dropped = true;\r\n                    }\r\n\r\n                    //  And finally the dragend event\r\n\r\n                    gameObject.emit('dragend', pointer, input.dragX, input.dragY, dropped);\r\n\r\n                    this.emit('dragend', pointer, gameObject, dropped);\r\n                }\r\n            }\r\n\r\n            pointer.dragState = 0;\r\n\r\n            list.splice(0);\r\n        }\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer movement event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processMoveEvents\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processMoveEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit('pointermove', pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit('gameobjectmove', pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            if (this.topOnly)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            this.emit('pointermove', pointer, currentlyOver);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer over and out events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverOutEvents\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processOverOutEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var i;\r\n        var gameObject;\r\n        var justOut = [];\r\n        var justOver = [];\r\n        var stillOver = [];\r\n        var previouslyOver = this._over[pointer.id];\r\n        var currentlyDragging = this._drag[pointer.id];\r\n\r\n        var manager = this.manager;\r\n\r\n        //  Go through all objects the pointer was previously over, and see if it still is.\r\n        //  Splits the previouslyOver array into two parts: justOut and stillOver\r\n\r\n        for (i = 0; i < previouslyOver.length; i++)\r\n        {\r\n            gameObject = previouslyOver[i];\r\n\r\n            if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1)\r\n            {\r\n                //  Not in the currentlyOver array, so must be outside of this object now\r\n                justOut.push(gameObject);\r\n            }\r\n            else\r\n            {\r\n                //  In the currentlyOver array\r\n                stillOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  Go through all objects the pointer is currently over (the hit test results)\r\n        //  and if not in the previouslyOver array we know it's a new entry, so add to justOver\r\n        for (i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            gameObject = currentlyOver[i];\r\n\r\n            //  Is this newly over?\r\n\r\n            if (previouslyOver.indexOf(gameObject) === -1)\r\n            {\r\n                justOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  By this point the arrays are filled, so now we can process what happened...\r\n\r\n        //  Process the Just Out objects\r\n        var total = justOut.length;\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOut);\r\n\r\n            //  Call onOut for everything in the justOut array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOut[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                gameObject.emit('pointerout', pointer, _eventContainer);\r\n\r\n                manager.resetCursor(gameObject.input);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit('gameobjectout', pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit('pointerout', pointer, justOut);\r\n            }\r\n        }\r\n\r\n        //  Process the Just Over objects\r\n        total = justOver.length;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOver);\r\n\r\n            //  Call onOver for everything in the justOver array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                gameObject.emit('pointerover', pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n                manager.setCursor(gameObject.input);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit('gameobjectover', pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit('pointerover', pointer, justOver);\r\n            }\r\n        }\r\n\r\n        //  Add the contents of justOver to the previously over array\r\n        previouslyOver = stillOver.concat(justOver);\r\n\r\n        //  Then sort it into display list order\r\n        this._over[pointer.id] = this.sortGameObjects(previouslyOver);\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer up events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processUpEvents\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processUpEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            //  pointerupoutside\r\n\r\n            gameObject.emit('pointerup', pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit('gameobjectup', pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            //  Contains ALL Game Objects currently up in the array\r\n            this.emit('pointerup', pointer, currentlyOver);\r\n        }\r\n\r\n        return currentlyOver.length;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for insertion into this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForInsertion\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    queueForInsertion: function (child)\r\n    {\r\n        if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1)\r\n        {\r\n            this._pendingInsertion.push(child);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for removal from this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForRemoval\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    queueForRemoval: function (child)\r\n    {\r\n        this._pendingRemoval.push(child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the draggable state of the given array of Game Objects.\r\n     *\r\n     * They can either be set to be draggable, or can have their draggable state removed by passing `false`.\r\n     *\r\n     * A Game Object will not fire drag events unless it has been specifically enabled for drag.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDraggable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to change the draggable state on.\r\n     * @param {boolean} [value=true] - Set to `true` if the Game Objects should be made draggable, `false` if they should be unset.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setDraggable: function (gameObjects, value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            gameObject.input.draggable = value;\r\n\r\n            var index = this._draggable.indexOf(gameObject);\r\n\r\n            if (value && index === -1)\r\n            {\r\n                this._draggable.push(gameObject);\r\n            }\r\n            else if (!value && index > -1)\r\n            {\r\n                this._draggable.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a function that can be passed to `setInteractive`, `enable` or `setHitArea` that will handle\r\n     * pixel-perfect input detection on an Image or Sprite based Game Object, or any custom class that extends them.\r\n     *\r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 1.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect());\r\n     * ```\r\n     * \r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 150.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect(150));\r\n     * ```\r\n     *\r\n     * Once you have made an Interactive Object pixel perfect it impacts all input related events for it: down, up,\r\n     * dragstart, drag, etc.\r\n     *\r\n     * As a pointer interacts with the Game Object it will constantly poll the texture, extracting a single pixel from\r\n     * the given coordinates and checking its color values. This is an expensive process, so should only be enabled on\r\n     * Game Objects that really need it.\r\n     * \r\n     * You cannot make non-texture based Game Objects pixel perfect. So this will not work on Graphics, BitmapText,\r\n     * Render Textures, Text, Tilemaps, Containers or Particles.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#makePixelPerfect\r\n     * @since 3.10.0\r\n     *\r\n     * @param {integer} [alphaTolerance=1] - The alpha level that the pixel should be above to be included as a successful interaction.\r\n     *\r\n     * @return {function} A Pixel Perfect Handler for use as a hitArea shape callback.\r\n     */\r\n    makePixelPerfect: function (alphaTolerance)\r\n    {\r\n        if (alphaTolerance === undefined) { alphaTolerance = 1; }\r\n\r\n        var textureManager = this.systems.textures;\r\n\r\n        return CreatePixelPerfectHandler(textureManager, alphaTolerance);\r\n    },\r\n\r\n    /**\r\n     * @typedef {object} Phaser.Input.InputConfiguration\r\n     *\r\n     * @property {any} [hitArea] - The object / shape to use as the Hit Area. If not given it will try to create a Rectangle based on the texture frame.\r\n     * @property {function} [hitAreaCallback] - The callback that determines if the pointer is within the Hit Area shape or not.\r\n     * @property {boolean} [draggable=false] - If `true` the Interactive Object will be set to be draggable and emit drag events.\r\n     * @property {boolean} [dropZone=false] - If `true` the Interactive Object will be set to be a drop zone for draggable objects.\r\n     * @property {boolean} [useHandCursor=false] - If `true` the Interactive Object will set the `pointer` hand cursor when a pointer is over it. This is a short-cut for setting `cursor: 'pointer'`.\r\n     * @property {string} [cursor] - The CSS string to be used when the cursor is over this Interactive Object.\r\n     * @property {boolean} [pixelPerfect=false] - If `true` the a pixel perfect function will be set for the hit area callback. Only works with texture based Game Objects.\r\n     * @property {integer} [alphaTolerance=1] - If `pixelPerfect` is set, this is the alpha tolerance threshold value used in the callback.\r\n     */\r\n\r\n    /**\r\n     * Sets the hit area for the given array of Game Objects.\r\n     *\r\n     * A hit area is typically one of the geometric shapes Phaser provides, such as a `Phaser.Geom.Rectangle`\r\n     * or `Phaser.Geom.Circle`. However, it can be any object as long as it works with the provided callback.\r\n     *\r\n     * If no hit area is provided a Rectangle is created based on the size of the Game Object, if possible\r\n     * to calculate.\r\n     *\r\n     * The hit area callback is the function that takes an `x` and `y` coordinate and returns a boolean if\r\n     * those values fall within the area of the shape or not. All of the Phaser geometry objects provide this,\r\n     * such as `Phaser.Geom.Rectangle.Contains`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitArea\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set the hit area on.\r\n     * @param {(Phaser.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitArea: function (gameObjects, shape, callback)\r\n    {\r\n        if (shape === undefined)\r\n        {\r\n            return this.setHitAreaFromTexture(gameObjects);\r\n        }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        var draggable = false;\r\n        var dropZone = false;\r\n        var cursor = false;\r\n        var useHandCursor = false;\r\n\r\n        //  Config object?\r\n        if (IsPlainObject(shape))\r\n        {\r\n            var config = shape;\r\n\r\n            shape = GetFastValue(config, 'hitArea', null);\r\n            callback = GetFastValue(config, 'hitAreaCallback', null);\r\n            draggable = GetFastValue(config, 'draggable', false);\r\n            dropZone = GetFastValue(config, 'dropZone', false);\r\n            cursor = GetFastValue(config, 'cursor', false);\r\n            useHandCursor = GetFastValue(config, 'useHandCursor', false);\r\n\r\n            var pixelPerfect = GetFastValue(config, 'pixelPerfect', false);\r\n            var alphaTolerance = GetFastValue(config, 'alphaTolerance', 1);\r\n\r\n            if (pixelPerfect)\r\n            {\r\n                shape = {};\r\n                callback = this.makePixelPerfect(alphaTolerance);\r\n            }\r\n\r\n            //  Still no hitArea or callback?\r\n            if (!shape || !callback)\r\n            {\r\n                this.setHitAreaFromTexture(gameObjects);\r\n            }\r\n        }\r\n        else if (typeof shape === 'function' && !callback)\r\n        {\r\n            callback = shape;\r\n            shape = {};\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            var io = (!gameObject.input) ? CreateInteractiveObject(gameObject, shape, callback) : gameObject.input;\r\n\r\n            io.dropZone = dropZone;\r\n            io.cursor = (useHandCursor) ? 'pointer' : cursor;\r\n\r\n            gameObject.input = io;\r\n\r\n            if (draggable)\r\n            {\r\n                this.setDraggable(gameObject);\r\n            }\r\n\r\n            this.queueForInsertion(gameObject);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Circle` shape, using\r\n     * the given coordinates and radius to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a circle hit area.\r\n     * @param {number} x - The center of the circle.\r\n     * @param {number} y - The center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Circle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaCircle: function (gameObjects, x, y, radius, callback)\r\n    {\r\n        if (callback === undefined) { callback = CircleContains; }\r\n\r\n        var shape = new Circle(x, y, radius);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Ellipse` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {number} x - The center of the ellipse.\r\n     * @param {number} y - The center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Ellipse.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaEllipse: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = EllipseContains; }\r\n\r\n        var shape = new Ellipse(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the Game Objects texture frame to define the position and size of the hit area.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaFromTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaFromTexture: function (gameObjects, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            var frame = gameObject.frame;\r\n\r\n            var width = 0;\r\n            var height = 0;\r\n\r\n            if (frame)\r\n            {\r\n                width = frame.realWidth;\r\n                height = frame.realHeight;\r\n            }\r\n            else if (gameObject.width)\r\n            {\r\n                width = gameObject.width;\r\n                height = gameObject.height;\r\n            }\r\n\r\n            if (gameObject.type === 'Container' && (width === 0 || height === 0))\r\n            {\r\n                console.warn('Container.setInteractive() must specify a Shape or call setSize() first');\r\n                continue;\r\n            }\r\n\r\n            if (width !== 0 && height !== 0)\r\n            {\r\n                gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);\r\n\r\n                this.queueForInsertion(gameObject);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a rectangular hit area.\r\n     * @param {number} x - The top-left of the rectangle.\r\n     * @param {number} y - The top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaRectangle: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        var shape = new Rectangle(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Triangle` shape, using\r\n     * the given coordinates to control the position of its points.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a  triangular hit area.\r\n     * @param {number} x1 - The x coordinate of the first point of the triangle.\r\n     * @param {number} y1 - The y coordinate of the first point of the triangle.\r\n     * @param {number} x2 - The x coordinate of the second point of the triangle.\r\n     * @param {number} y2 - The y coordinate of the second point of the triangle.\r\n     * @param {number} x3 - The x coordinate of the third point of the triangle.\r\n     * @param {number} y3 - The y coordinate of the third point of the triangle.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Triangle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaTriangle: function (gameObjects, x1, y1, x2, y2, x3, y3, callback)\r\n    {\r\n        if (callback === undefined) { callback = TriangleContains; }\r\n\r\n        var shape = new Triangle(x1, y1, x2, y2, x3, y3);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to always poll.\r\n     * \r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it, regardless if the Pointer has actually moved or not.\r\n     *\r\n     * You should enable this if you want objects in your game to fire over / out events, and the objects\r\n     * are constantly moving, but the pointer may not have. Polling every frame has additional computation\r\n     * costs, especially if there are a large number of interactive objects in your game.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollAlways\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setPollAlways: function ()\r\n    {\r\n        this.pollRate = 0;\r\n        this._pollTimer = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to only poll when they are moved or updated.\r\n     * \r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollOnMove\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setPollOnMove: function ()\r\n    {\r\n        this.pollRate = -1;\r\n        this._pollTimer = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the poll rate value. This is the amount of time that should have elapsed before a pointer\r\n     * will be polled again. See the `setPollAlways` and `setPollOnMove` methods.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollRate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of time, in ms, that should elapsed before re-polling the pointers.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setPollRate: function (value)\r\n    {\r\n        this.pollRate = value;\r\n        this._pollTimer = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` the global Input Manager will emulate DOM behavior by only emitting events from\r\n     * the top-most Game Objects in the Display List.\r\n     *\r\n     * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setGlobalTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setGlobalTopOnly: function (value)\r\n    {\r\n        this.manager.globalTopOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` this Input Plugin will emulate DOM behavior by only emitting events from\r\n     * the top-most Game Objects in the Display List.\r\n     *\r\n     * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setTopOnly: function (value)\r\n    {\r\n        this.topOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Given an array of Game Objects, sort the array and return it, so that the objects are in depth index order\r\n     * with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortGameObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n     */\r\n    sortGameObjects: function (gameObjects)\r\n    {\r\n        if (gameObjects.length < 2)\r\n        {\r\n            return gameObjects;\r\n        }\r\n\r\n        this.scene.sys.depthSort();\r\n\r\n        return gameObjects.sort(this.sortHandlerGO.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Return the child lowest down the display list (with the smallest index)\r\n     * Will iterate through all parent containers, if present.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortHandlerGO\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object to compare.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object to compare.\r\n     *\r\n     * @return {integer} Returns either a negative or positive integer, or zero if they match.\r\n     */\r\n    sortHandlerGO: function (childA, childB)\r\n    {\r\n        if (!childA.parentContainer && !childB.parentContainer)\r\n        {\r\n            //  Quick bail out when neither child has a container\r\n            return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB.parentContainer)\r\n        {\r\n            //  Quick bail out when both children have the same container\r\n            return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return -1;\r\n        }\r\n        else if (childB.parentContainer === childA)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            //  Container index check\r\n            var listA = childA.getIndexList();\r\n            var listB = childB.getIndexList();\r\n            var len = Math.min(listA.length, listB.length);\r\n\r\n            for (var i = 0; i < len; i++)\r\n            {\r\n                var indexA = listA[i];\r\n                var indexB = listB[i];\r\n\r\n                if (indexA === indexB)\r\n                {\r\n                    //  Go to the next level down\r\n                    continue;\r\n                }\r\n                else\r\n                {\r\n                    //  Non-matching parents, so return\r\n                    return indexB - indexA;\r\n                }\r\n            }\r\n        }\r\n\r\n        //  Technically this shouldn't happen, but ...\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Causes the Input Manager to stop emitting any events for the remainder of this game step.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#stopPropagation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    stopPropagation: function ()\r\n    {\r\n        if (this.manager.globalTopOnly)\r\n        {\r\n            this.manager.ignoreEvents = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to be invoked whenever the native DOM `mouseup` or `touchend` events are received.\r\n     * By setting the `isOnce` argument you can control if the callback is called once,\r\n     * or every time the DOM event occurs.\r\n     *\r\n     * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n     * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n     * from the perspective of the browser. This means they can be used for tasks such as\r\n     * opening new browser windows, or anything which explicitly requires user input to activate.\r\n     * However, as a result of this, they come with their own risks, and as such should not be used\r\n     * for general game input, but instead be reserved for special circumstances.\r\n     *\r\n     * If all you're trying to do is execute a callback when a pointer is released, then\r\n     * please use the internal Input event system instead.\r\n     *\r\n     * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n     * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n     * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n     * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n     * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n     * solve.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#addUpCallback\r\n     * @since 3.10.0\r\n     *\r\n     * @param {function} callback - The callback to be invoked on this DOM event.\r\n     * @param {boolean} [isOnce=true] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n     *\r\n     * @return {this} The Input Plugin.\r\n     */\r\n    addUpCallback: function (callback, isOnce)\r\n    {\r\n        this.manager.addUpCallback(callback, isOnce);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to be invoked whenever the native DOM `mousedown` or `touchstart` events are received.\r\n     * By setting the `isOnce` argument you can control if the callback is called once,\r\n     * or every time the DOM event occurs.\r\n     *\r\n     * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n     * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n     * from the perspective of the browser. This means they can be used for tasks such as\r\n     * opening new browser windows, or anything which explicitly requires user input to activate.\r\n     * However, as a result of this, they come with their own risks, and as such should not be used\r\n     * for general game input, but instead be reserved for special circumstances.\r\n     *\r\n     * If all you're trying to do is execute a callback when a pointer is down, then\r\n     * please use the internal Input event system instead.\r\n     *\r\n     * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n     * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n     * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n     * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n     * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n     * solve.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#addDownCallback\r\n     * @since 3.10.0\r\n     *\r\n     * @param {function} callback - The callback to be invoked on this dom event.\r\n     * @param {boolean} [isOnce=true] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n     *\r\n     * @return {this} The Input Plugin.\r\n     */\r\n    addDownCallback: function (callback, isOnce)\r\n    {\r\n        this.manager.addDownCallback(callback, isOnce);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to be invoked whenever the native DOM `mousemove` or `touchmove` events are received.\r\n     * By setting the `isOnce` argument you can control if the callback is called once,\r\n     * or every time the DOM event occurs.\r\n     *\r\n     * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n     * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n     * from the perspective of the browser. This means they can be used for tasks such as\r\n     * opening new browser windows, or anything which explicitly requires user input to activate.\r\n     * However, as a result of this, they come with their own risks, and as such should not be used\r\n     * for general game input, but instead be reserved for special circumstances.\r\n     *\r\n     * If all you're trying to do is execute a callback when a pointer is moved, then\r\n     * please use the internal Input event system instead.\r\n     *\r\n     * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n     * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n     * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n     * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n     * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n     * solve.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#addMoveCallback\r\n     * @since 3.10.0\r\n     *\r\n     * @param {function} callback - The callback to be invoked on this dom event.\r\n     * @param {boolean} [isOnce=false] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n     *\r\n     * @return {this} The Input Plugin.\r\n     */\r\n    addMoveCallback: function (callback, isOnce)\r\n    {\r\n        this.manager.addMoveCallback(callback, isOnce);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds new Pointer objects to the Input Manager.\r\n     *\r\n     * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n     *\r\n     * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n     * in the Game Config, up to a maximum of 10 pointers.\r\n     *\r\n     * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n     * via this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#addPointer\r\n     * @since 3.10.0\r\n     * \r\n     * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n     *\r\n     * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n     */\r\n    addPointer: function (quantity)\r\n    {\r\n        return this.manager.addPointer(quantity);\r\n    },\r\n\r\n    /**\r\n     * Tells the Input system to set a custom cursor.\r\n     * \r\n     * This cursor will be the default cursor used when interacting with the game canvas.\r\n     *\r\n     * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n     *\r\n     * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n     *\r\n     * ```javascript\r\n     * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n     * ```\r\n     * \r\n     * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n     *\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n     *\r\n     * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDefaultCursor\r\n     * @since 3.10.0\r\n     * \r\n     * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This Input instance.\r\n     */\r\n    setDefaultCursor: function (cursor)\r\n    {\r\n        this.manager.setDefaultCursor(cursor);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionIn\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionIn: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin has finished transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionComplete\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionComplete: function ()\r\n    {\r\n        if (!this.settings.transitionAllowInput)\r\n        {\r\n            this.enabled = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning out.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionOut\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionOut: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit('shutdown');\r\n\r\n        this._temp.length = 0;\r\n        this._list.length = 0;\r\n        this._draggable.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n        this._pendingInsertion.length = 0;\r\n\r\n        for (var i = 0; i < 10; i++)\r\n        {\r\n            this._drag[i] = [];\r\n            this._over[i] = [];\r\n        }\r\n\r\n        this.removeAllListeners();\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off('transitionstart', this.transitionIn, this);\r\n        eventEmitter.off('transitionout', this.transitionOut, this);\r\n        eventEmitter.off('transitioncomplete', this.transitionComplete, this);\r\n\r\n        eventEmitter.off('preupdate', this.preUpdate, this);\r\n        eventEmitter.off('update', this.update, this);\r\n        eventEmitter.off('shutdown', this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.     \r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit('destroy');\r\n\r\n        this.pluginEvents.removeAllListeners();\r\n\r\n        this.scene.sys.events.off('start', this.start, this);\r\n\r\n        this.scene = null;\r\n        this.cameras = null;\r\n        this.manager = null;\r\n        this.events = null;\r\n        this.mouse = null;\r\n    },\r\n\r\n    /**\r\n     * The x coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#x\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#y\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n     * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n     * which will always map to the most recently interacted pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#mousePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    mousePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.mousePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The current active input Pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#activePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    activePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer1\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[1];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer2\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[2];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer3\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer3: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[3];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer4\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer4: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[4];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer5\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer5: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[5];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer6\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer6: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[6];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer7\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer7: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[7];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer8\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer8: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[8];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer9\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer9: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[9];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer10\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.10.0\r\n     */\r\n    pointer10: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[10];\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('InputPlugin', InputPlugin, 'input');\r\n\r\nmodule.exports = InputPlugin;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Circle","CircleContains","Class","CreateInteractiveObject","CreatePixelPerfectHandler","DistanceBetween","Ellipse","EllipseContains","EventEmitter","GetFastValue","InputPluginCache","IsPlainObject","PluginCache","Rectangle","RectangleContains","Triangle","TriangleContains","InputPlugin","Extends","initialize","scene","call","systems","sys","settings","manager","game","input","pluginEvents","enabled","install","mouse","topOnly","pollRate","_pollTimer","_eventData","cancelled","_eventContainer","stopPropagation","dragTimeThreshold","dragDistanceThreshold","_temp","_tempZones","_list","_pendingInsertion","_pendingRemoval","_draggable","_drag","_over","_validTypes","events","once","boot","on","start","cameras","displayList","destroy","emit","eventEmitter","transitionIn","transitionOut","transitionComplete","preUpdate","update","shutdown","removeList","insertList","toRemove","length","toInsert","current","i","gameObject","index","indexOf","splice","clear","concat","isActive","time","delta","globalTopOnly","ignoreEvents","runUpdate","dirty","pointers","pointersTotal","pointer","hitTestPointer","sortGameObjects","total","processDragEvents","wasTouch","processOverOutEvents","justDown","processDownEvents","justUp","processUpEvents","justMoved","processMoveEvents","queueForRemoval","undefined","target","hitArea","hitAreaCallback","callbackContext","resetCursor","disable","enable","shape","callback","dropZone","setHitArea","getCamerasBelowPointer","c","camera","over","hitTest","obj","push","currentlyOver","aborted","localX","localY","dragState","primaryDown","draglist","draggable","id","x","y","downX","downY","downTime","list","dragX","dragY","dragStartX","dragStartY","dropZones","displayOriginX","displayOriginY","dropped","justOut","justOver","stillOver","previouslyOver","currentlyDragging","totalInteracted","setCursor","queueForInsertion","child","setDraggable","gameObjects","value","Array","isArray","makePixelPerfect","alphaTolerance","textures","setHitAreaFromTexture","cursor","useHandCursor","config","pixelPerfect","io","setHitAreaCircle","radius","setHitAreaEllipse","width","height","frame","realWidth","realHeight","type","console","warn","setHitAreaRectangle","setHitAreaTriangle","x1","y1","x2","y2","x3","y3","setPollAlways","setPollOnMove","setPollRate","setGlobalTopOnly","setTopOnly","depthSort","sort","sortHandlerGO","bind","childA","childB","parentContainer","getIndex","listA","getIndexList","listB","len","Math","min","indexA","indexB","addUpCallback","isOnce","addDownCallback","addMoveCallback","addPointer","quantity","setDefaultCursor","transitionAllowInput","removeAllListeners","off","get","activePointer","mousePointer","pointer1","pointer2","pointer3","pointer4","pointer5","pointer6","pointer7","pointer8","pointer9","pointer10","register"]
}
