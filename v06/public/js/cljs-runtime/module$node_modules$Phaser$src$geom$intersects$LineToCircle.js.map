{
"version":3,
"file":"module$node_modules$Phaser$src$geom$intersects$LineToCircle.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,4DAAA,CAAgF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAUxH,IAAIC,SAAWH,OAAA,CAAQ,qDAAR,CAAf,CAGII,IAAM,KAFEJ,OAAAK,CAAQ,iDAARA,CAEF,CAkEVJ,OAAAC,QAAA,CApDmBI,QAAS,CAACC,IAAD,CAAOC,MAAP,CAAeC,OAAf,CAC5B,CACoBC,IAAAA,EAAhB,GAAID,OAAJ,GAA6BA,OAA7B,CAAuCL,GAAvC,CAEA,IAAID,QAAA,CAASK,MAAT,CAAiBD,IAAAI,GAAjB,CAA0BJ,IAAAK,GAA1B,CAAJ,CAKI,MAHAH,QAAAI,EAGO,CAHKN,IAAAI,GAGL,CAFPF,OAAAK,EAEO,CAFKP,IAAAK,GAEL,CAAA,CAAA,CAGX,IAAIT,QAAA,CAASK,MAAT,CAAiBD,IAAAQ,GAAjB,CAA0BR,IAAAS,GAA1B,CAAJ,CAKI,MAHAP,QAAAI,EAGO,CAHKN,IAAAQ,GAGL,CAFPN,OAAAK,EAEO,CAFKP,IAAAS,GAEL,CAAA,CAAA,CAGX;IAAIC,GAAKV,IAAAQ,GAALE,CAAeV,IAAAI,GAAnB,CACIO,GAAKX,IAAAS,GAALE,CAAeX,IAAAK,GADnB,CAGIO,IAAMX,MAAAK,EAANM,CAAiBZ,IAAAI,GAHrB,CAIIS,IAAMZ,MAAAM,EAANM,CAAiBb,IAAAK,GAJrB,CAOIS,MAASJ,EAATI,CAAcJ,EAAdI,CAAqBH,EAArBG,CAA0BH,EAP9B,CAQII,GAAKL,EART,CASIM,GAAKL,EAEG,EAAZ,CAAIG,KAAJ,GAEQG,GAGJ,EAHWL,GAGX,CAHiBF,EAGjB,CAHwBG,GAGxB,CAH8BF,EAG9B,EAHqCG,KAGrC,CADAC,EACA,EADME,GACN,CAAAD,EAAA,EAAMC,GALV,CAQAf,QAAAI,EAAA,CAAYN,IAAAI,GAAZ,CAAsBW,EACtBb,QAAAK,EAAA,CAAYP,IAAAK,GAAZ,CAAsBW,EAKtB,OAFaD,GAEb,CAFkBA,EAElB,CAFyBC,EAEzB,CAF8BA,EAE9B,EACaF,KADb,EAE+B,CAF/B,EAEMC,EAFN,CAEWL,EAFX,CAEkBM,EAFlB,CAEuBL,EAFvB,EAGIf,QAAA,CAASK,MAAT,CAAiBC,OAAAI,EAAjB,CAA4BJ,OAAAK,EAA5B,CA/CR,CA5BwH;",
"sources":["node_modules/Phaser/src/geom/intersects/LineToCircle.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$geom$intersects$LineToCircle\"] = function(global,require,module,exports) {\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n//  Based on code by Matt DesLauriers\r\n//  https://github.com/mattdesl/line-circle-collision/blob/master/LICENSE.md\r\n\r\nvar Contains = require('../circle/Contains');\r\nvar Point = require('../point/Point');\r\n\r\nvar tmp = new Point();\r\n\r\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.LineToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {Phaser.Geom.Circle} circle - [description]\r\n * @param {Phaser.Geom.Point} [nearest] - [description]\r\n *\r\n * @return {boolean} [description]\r\n */\r\nvar LineToCircle = function (line, circle, nearest)\r\n{\r\n    if (nearest === undefined) { nearest = tmp; }\r\n\r\n    if (Contains(circle, line.x1, line.y1))\r\n    {\r\n        nearest.x = line.x1;\r\n        nearest.y = line.y1;\r\n\r\n        return true;\r\n    }\r\n\r\n    if (Contains(circle, line.x2, line.y2))\r\n    {\r\n        nearest.x = line.x2;\r\n        nearest.y = line.y2;\r\n\r\n        return true;\r\n    }\r\n\r\n    var dx = line.x2 - line.x1;\r\n    var dy = line.y2 - line.y1;\r\n\r\n    var lcx = circle.x - line.x1;\r\n    var lcy = circle.y - line.y1;\r\n\r\n    //  project lc onto d, resulting in vector p\r\n    var dLen2 = (dx * dx) + (dy * dy);\r\n    var px = dx;\r\n    var py = dy;\r\n\r\n    if (dLen2 > 0)\r\n    {\r\n        var dp = ((lcx * dx) + (lcy * dy)) / dLen2;\r\n\r\n        px *= dp;\r\n        py *= dp;\r\n    }\r\n\r\n    nearest.x = line.x1 + px;\r\n    nearest.y = line.y1 + py;\r\n    \r\n    //  len2 of p\r\n    var pLen2 = (px * px) + (py * py);\r\n    \r\n    return (\r\n        pLen2 <= dLen2 &&\r\n        ((px * dx) + (py * dy)) >= 0 &&\r\n        Contains(circle, nearest.x, nearest.y)\r\n    );\r\n};\r\n\r\nmodule.exports = LineToCircle;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Contains","tmp","Point","LineToCircle","line","circle","nearest","undefined","x1","y1","x","y","x2","y2","dx","dy","lcx","lcy","dLen2","px","py","dp"]
}
