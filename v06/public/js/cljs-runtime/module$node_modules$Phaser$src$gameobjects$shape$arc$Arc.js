shadow$provide.module$node_modules$Phaser$src$gameobjects$shape$arc$Arc=function(global,require,module,exports){global=require("module$node_modules$Phaser$src$gameobjects$shape$arc$ArcRender");exports=require("module$node_modules$Phaser$src$utils$Class");var DegToRad=require("module$node_modules$Phaser$src$math$DegToRad"),Earcut=require("module$node_modules$Phaser$src$geom$polygon$Earcut"),GeomCircle=require("module$node_modules$Phaser$src$geom$circle$Circle"),MATH_CONST=require("module$node_modules$Phaser$src$math$const"),
Shape=require("module$node_modules$Phaser$src$gameobjects$shape$Shape");require=new exports({Extends:Shape,Mixins:[global],initialize:function(scene,x,y,radius,startAngle,endAngle,anticlockwise,fillColor,fillAlpha){void 0===x&&(x=0);void 0===y&&(y=0);void 0===radius&&(radius=128);void 0===startAngle&&(startAngle=0);void 0===endAngle&&(endAngle=360);void 0===anticlockwise&&(anticlockwise=!1);Shape.call(this,scene,"Arc",new GeomCircle(0,0,radius));this._startAngle=startAngle;this._endAngle=endAngle;
this._anticlockwise=anticlockwise;this._iterations=.01;this.setPosition(x,y);this.setSize(this.geom.radius,this.geom.radius);void 0!==fillColor&&this.setFillStyle(fillColor,fillAlpha);this.updateDisplayOrigin();this.updateData()},iterations:{get:function(){return this._iterations},set:function(value){this._iterations=value;this.updateData()}},radius:{get:function(){return this.geom.radius},set:function(value){this.geom.radius=value;this.updateData()}},startAngle:{get:function(){return this._startAngle},
set:function(value){this._startAngle=value;this.updateData()}},endAngle:{get:function(){return this._endAngle},set:function(value){this._endAngle=value;this.updateData()}},anticlockwise:{get:function(){return this._anticlockwise},set:function(value){this._anticlockwise=value;this.updateData()}},setRadius:function(value){this.radius=value;return this},setIterations:function(value){void 0===value&&(value=.01);this.iterations=value;return this},setStartAngle:function(angle,anticlockwise){this._startAngle=
angle;void 0!==anticlockwise&&(this._anticlockwise=anticlockwise);return this.updateData()},setEndAngle:function(angle,anticlockwise){this._endAngle=angle;void 0!==anticlockwise&&(this._anticlockwise=anticlockwise);return this.updateData()},updateData:function(){var step=this._iterations,iteration=step,radius=this.geom.radius,startAngle=DegToRad(this._startAngle),endAngle=DegToRad(this._endAngle),anticlockwise=this._anticlockwise,x=radius/2,y=radius/2;endAngle-=startAngle;anticlockwise?endAngle<-MATH_CONST.PI2?
endAngle=-MATH_CONST.PI2:0<endAngle&&(endAngle=-MATH_CONST.PI2+endAngle%MATH_CONST.PI2):endAngle>MATH_CONST.PI2?endAngle=MATH_CONST.PI2:0>endAngle&&(endAngle=MATH_CONST.PI2+endAngle%MATH_CONST.PI2);anticlockwise=[x+Math.cos(startAngle)*radius,y+Math.sin(startAngle)*radius];for(var ta;1>iteration;)ta=endAngle*iteration+startAngle,anticlockwise.push(x+Math.cos(ta)*radius,y+Math.sin(ta)*radius),iteration+=step;ta=endAngle+startAngle;anticlockwise.push(x+Math.cos(ta)*radius,y+Math.sin(ta)*radius);anticlockwise.push(x+
Math.cos(startAngle)*radius,y+Math.sin(startAngle)*radius);this.pathIndexes=Earcut(anticlockwise);this.pathData=anticlockwise;return this}});module.exports=require}
//# sourceMappingURL=module$node_modules$Phaser$src$gameobjects$shape$arc$Arc.js.map
