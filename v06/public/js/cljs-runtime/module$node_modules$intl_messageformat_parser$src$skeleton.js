shadow$provide.module$node_modules$intl_messageformat_parser$src$skeleton=function(global,require,module,exports){function parseSignificantPrecision(str){var result={};str.replace(SIGNIFICANT_PRECISION_REGEX,function(_,g1,g2){"string"!==typeof g2?(result.minimumSignificantDigits=g1.length,result.maximumSignificantDigits=g1.length):"+"===g2?result.minimumSignificantDigits=g1.length:"#"===g1[0]?result.maximumSignificantDigits=g1.length:(result.minimumSignificantDigits=g1.length,result.maximumSignificantDigits=
g1.length+("string"===typeof g2?g2.length:0));return""});return result}function parseSign(str){switch(str){case "sign-auto":return{signDisplay:"auto"};case "sign-accounting":return{currencySign:"accounting"};case "sign-always":return{signDisplay:"always"};case "sign-accounting-always":return{signDisplay:"always",currencySign:"accounting"};case "sign-except-zero":return{signDisplay:"exceptZero"};case "sign-accounting-except-zero":return{signDisplay:"exceptZero",currencySign:"accounting"};case "sign-never":return{signDisplay:"never"}}}
function parseNotationOptions(opt){return(opt=parseSign(opt))?opt:{}}Object.defineProperty(exports,"__esModule",{value:!0});exports.parseNumberSkeleton=exports.parseDateTimeSkeleton=void 0;var tslib_1=require("module$node_modules$tslib$tslib"),DATE_TIME_REGEX=/(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;exports.parseDateTimeSkeleton=function(skeleton){var result={};skeleton.replace(DATE_TIME_REGEX,
function(match){var len=match.length;switch(match[0]){case "G":result.era=4===len?"long":5===len?"narrow":"short";break;case "y":result.year=2===len?"2-digit":"numeric";break;case "Y":case "u":case "U":case "r":throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");case "q":case "Q":throw new RangeError("`q/Q` (quarter) patterns are not supported");case "M":case "L":result.month=["numeric","2-digit","short","long","narrow"][len-1];break;case "w":case "W":throw new RangeError("`w/W` (week) patterns are not supported");
case "d":result.day=["numeric","2-digit"][len-1];break;case "D":case "F":case "g":throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");case "E":result.weekday=4===len?"short":5===len?"narrow":"short";break;case "e":if(4>len)throw new RangeError("`e..eee` (weekday) patterns are not supported");result.weekday=["short","long","narrow","short"][len-4];break;case "c":if(4>len)throw new RangeError("`c..ccc` (weekday) patterns are not supported");result.weekday=["short","long",
"narrow","short"][len-4];break;case "a":result.hour12=!0;break;case "b":case "B":throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");case "h":result.hourCycle="h12";result.hour=["numeric","2-digit"][len-1];break;case "H":result.hourCycle="h23";result.hour=["numeric","2-digit"][len-1];break;case "K":result.hourCycle="h11";result.hour=["numeric","2-digit"][len-1];break;case "k":result.hourCycle="h24";result.hour=["numeric","2-digit"][len-1];break;case "j":case "J":case "C":throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
case "m":result.minute=["numeric","2-digit"][len-1];break;case "s":result.second=["numeric","2-digit"][len-1];break;case "S":case "A":throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");case "z":result.timeZoneName=4>len?"short":"long";break;case "Z":case "O":case "v":case "V":case "X":case "x":throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");}return""});return result};var FRACTION_PRECISION_REGEX=/^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g,
SIGNIFICANT_PRECISION_REGEX=/^(@+)?(\+|#+)?$/g;exports.parseNumberSkeleton=function(tokens){for(var result={},_i=0;_i<tokens.length;_i++){var token=tokens[_i];switch(token.stem){case "percent":result.style="percent";continue;case "currency":result.style="currency";result.currency=token.options[0];continue;case "group-off":result.useGrouping=!1;continue;case "precision-integer":case ".":result.maximumFractionDigits=0;continue;case "measure-unit":result.style="unit";result.unit=token.options[0].replace(/^(.*?)-/,
"");continue;case "compact-short":result.notation="compact";result.compactDisplay="short";continue;case "compact-long":result.notation="compact";result.compactDisplay="long";continue;case "scientific":result=tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({},result),{notation:"scientific"}),token.options.reduce(function(all,opt){return tslib_1.__assign(tslib_1.__assign({},all),parseNotationOptions(opt))},{}));continue;case "engineering":result=tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({},
result),{notation:"engineering"}),token.options.reduce(function(all,opt){return tslib_1.__assign(tslib_1.__assign({},all),parseNotationOptions(opt))},{}));continue;case "notation-simple":result.notation="standard";continue;case "unit-width-narrow":result.currencyDisplay="narrowSymbol";result.unitDisplay="narrow";continue;case "unit-width-short":result.currencyDisplay="code";result.unitDisplay="short";continue;case "unit-width-full-name":result.currencyDisplay="name";result.unitDisplay="long";continue;
case "unit-width-iso-code":result.currencyDisplay="symbol";continue;case "scale":result.scale=parseFloat(token.options[0]);continue}if(FRACTION_PRECISION_REGEX.test(token.stem)){if(1<token.options.length)throw new RangeError("Fraction-precision stems only accept a single optional option");token.stem.replace(FRACTION_PRECISION_REGEX,function(_,g1,g2,g3,g4,g5){"*"===g2?result.minimumFractionDigits=g1.length:g3&&"#"===g3[0]?result.maximumFractionDigits=g3.length:g4&&g5?(result.minimumFractionDigits=
g4.length,result.maximumFractionDigits=g4.length+g5.length):(result.minimumFractionDigits=g1.length,result.maximumFractionDigits=g1.length);return""});token.options.length&&(result=tslib_1.__assign(tslib_1.__assign({},result),parseSignificantPrecision(token.options[0])))}else SIGNIFICANT_PRECISION_REGEX.test(token.stem)?result=tslib_1.__assign(tslib_1.__assign({},result),parseSignificantPrecision(token.stem)):(token=parseSign(token.stem))&&(result=tslib_1.__assign(tslib_1.__assign({},result),token))}return result}}
//# sourceMappingURL=module$node_modules$intl_messageformat_parser$src$skeleton.js.map
