{
"version":3,
"file":"module$node_modules$Phaser$src$textures$parsers$JSONArray.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,0DAAA,CAA8E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAOtH,IAAIC,MAAQH,OAAA,CAAQ,mDAAR,CA8FZC,OAAAC,QAAA,CA7EgBE,QAAS,CAACC,OAAD,CAAUC,WAAV,CAAuBC,IAAvB,CACzB,CAEI,GAAKA,IAAA,OAAL,EAAwBA,IAAA,SAAxB,CAAA,CAOA,IAAIC,OAASH,OAAAG,OAAA,CAAeF,WAAf,CAEbD,QAAAI,IAAA,CAAY,QAAZ,CAAsBH,WAAtB,CAAmC,CAAnC,CAAsC,CAAtC,CAAyCE,MAAAE,MAAzC,CAAuDF,MAAAG,OAAvD,CAGIC,OAAAA,CAAUC,KAAAC,QAAA,CAAcP,IAAAQ,SAAd,CAAD,CAAiCR,IAAAQ,SAAA,CAAcT,WAAd,CAAAM,OAAjC,CAAqEL,IAAAK,OAIlF,KAFA,IAAII,QAAJ,CAESC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBL,MAAAM,OAApB,CAAmCD,CAAA,EAAnC,CACA,CACI,IAAIE;AAAMP,MAAA,CAAOK,CAAP,CAGVD,SAAA,CAAWX,OAAAI,IAAA,CAAYU,GAAAC,SAAZ,CAA0Bd,WAA1B,CAAuCa,GAAAE,MAAAC,EAAvC,CAAoDH,GAAAE,MAAAE,EAApD,CAAiEJ,GAAAE,MAAAG,EAAjE,CAA8EL,GAAAE,MAAAI,EAA9E,CAGPN,IAAAO,QAAJ,EAEIV,QAAAW,QAAA,CACIR,GAAAS,WAAAJ,EADJ,CAEIL,GAAAS,WAAAH,EAFJ,CAGIN,GAAAU,iBAAAP,EAHJ,CAIIH,GAAAU,iBAAAN,EAJJ,CAKIJ,GAAAU,iBAAAL,EALJ,CAMIL,GAAAU,iBAAAJ,EANJ,CAUAN,IAAAW,QAAJ,GAEId,QAAAc,QACA,CADmB,CAAA,CACnB,CAAAd,QAAAe,kBAAA,EAHJ,CAMIZ,IAAAa,OAAJ,GAEIhB,QAAAiB,YAEA,CAFuB,CAAA,CAEvB,CADAjB,QAAAkB,OACA,CADkBf,GAAAa,OAAAV,EAClB,CAAAN,QAAAmB,OAAA,CAAkBhB,GAAAa,OAAAT,EAJtB,CAQAP,SAAAoB,WAAA,CAAsBjC,KAAA,CAAMgB,GAAN,CAjC1B,CAqCA,IAAKkB,IAAIA,OAAT,GAAoB9B,KAApB,CAEoB,QAAhB,GAAI8B,OAAJ,GAKIxB,KAAAC,QAAA,CAAcP,IAAA,CAAK8B,OAAL,CAAd,CAAJ;AAEIhC,OAAA+B,WAAA,CAAmBC,OAAnB,CAFJ,CAEkC9B,IAAA,CAAK8B,OAAL,CAAAC,MAAA,CAAoB,CAApB,CAFlC,CAMIjC,OAAA+B,WAAA,CAAmBC,OAAnB,CANJ,CAMkC9B,IAAA,CAAK8B,OAAL,CAXlC,CAeJ,OAAOhC,QAvEP,CAEIkC,OAAAC,KAAA,CAAa,kCAAb,CAJR,CAzBsH;",
"sources":["node_modules/Phaser/src/textures/parsers/JSONArray.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$textures$parsers$JSONArray\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Clone = require('../../utils/object/Clone');\r\n\r\n/**\r\n * Parses a Texture Atlas JSON Array and adds the Frames to the Texture.\r\n * JSON format expected to match that defined by Texture Packer, with the frames property containing an array of Frames.\r\n *\r\n * @function Phaser.Textures.Parsers.JSONArray\r\n * @memberOf Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n * @param {object} json - The JSON data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar JSONArray = function (texture, sourceIndex, json)\r\n{\r\n    //  Malformed?\r\n    if (!json['frames'] && !json['textures'])\r\n    {\r\n        console.warn('Invalid Texture Atlas JSON Array');\r\n        return;\r\n    }\r\n\r\n    //  Add in a __BASE entry (for the entire atlas)\r\n    var source = texture.source[sourceIndex];\r\n\r\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\r\n\r\n    //  By this stage frames is a fully parsed array\r\n    var frames = (Array.isArray(json.textures)) ? json.textures[sourceIndex].frames : json.frames;\r\n\r\n    var newFrame;\r\n\r\n    for (var i = 0; i < frames.length; i++)\r\n    {\r\n        var src = frames[i];\r\n\r\n        //  The frame values are the exact coordinates to cut the frame out of the atlas from\r\n        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);\r\n\r\n        //  These are the original (non-trimmed) sprite values\r\n        if (src.trimmed)\r\n        {\r\n            newFrame.setTrim(\r\n                src.sourceSize.w,\r\n                src.sourceSize.h,\r\n                src.spriteSourceSize.x,\r\n                src.spriteSourceSize.y,\r\n                src.spriteSourceSize.w,\r\n                src.spriteSourceSize.h\r\n            );\r\n        }\r\n\r\n        if (src.rotated)\r\n        {\r\n            newFrame.rotated = true;\r\n            newFrame.updateUVsInverted();\r\n        }\r\n\r\n        if (src.anchor)\r\n        {\r\n            newFrame.customPivot = true;\r\n            newFrame.pivotX = src.anchor.x;\r\n            newFrame.pivotY = src.anchor.y;\r\n        }\r\n\r\n        //  Copy over any extra data\r\n        newFrame.customData = Clone(src);\r\n    }\r\n\r\n    //  Copy over any additional data that was in the JSON to Texture.customData\r\n    for (var dataKey in json)\r\n    {\r\n        if (dataKey === 'frames')\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (Array.isArray(json[dataKey]))\r\n        {\r\n            texture.customData[dataKey] = json[dataKey].slice(0);\r\n        }\r\n        else\r\n        {\r\n            texture.customData[dataKey] = json[dataKey];\r\n        }\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = JSONArray;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Clone","JSONArray","texture","sourceIndex","json","source","add","width","height","frames","Array","isArray","textures","newFrame","i","length","src","filename","frame","x","y","w","h","trimmed","setTrim","sourceSize","spriteSourceSize","rotated","updateUVsInverted","anchor","customPivot","pivotX","pivotY","customData","dataKey","slice","console","warn"]
}
