{
"version":3,
"file":"module$node_modules$Phaser$src$tilemaps$components$GetTilesWithin.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,kEAAA,CAAsF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAO9H,IAAIC,aAAeH,OAAA,CAAQ,0DAAR,CA+EnBC,OAAAC,QAAA,CArDqBE,QAAS,CAACC,KAAD,CAAQC,KAAR,CAAeC,KAAf,CAAsBC,MAAtB,CAA8BC,gBAA9B,CAAgDC,KAAhD,CAC9B,CACkBC,IAAAA,EAAd,GAAIN,KAAJ,GAA2BA,KAA3B,CAAmC,CAAnC,CACcM,KAAAA,EAAd,GAAIL,KAAJ,GAA2BA,KAA3B,CAAmC,CAAnC,CACcK,KAAAA,EAAd,GAAIJ,KAAJ,GAA2BA,KAA3B,CAAmCG,KAAAH,MAAnC,CACeI,KAAAA,EAAf,GAAIH,MAAJ,GAA4BA,MAA5B,CAAqCE,KAAAF,OAArC,CAEA,KAAII,WAAaT,YAAA,CAAaM,gBAAb,CAA+B,YAA/B,CAA6C,CAAA,CAA7C,CAAjB,CACII,YAAcV,YAAA,CAAaM,gBAAb;AAA+B,aAA/B,CAA8C,CAAA,CAA9C,CACdK,iBAAAA,CAAqBX,YAAA,CAAaM,gBAAb,CAA+B,oBAA/B,CAAqD,CAAA,CAArD,CAGb,EAAZ,CAAIJ,KAAJ,GAEIE,KACA,EADSF,KACT,CAAAA,KAAA,CAAQ,CAHZ,CAKY,EAAZ,CAAIC,KAAJ,GAEIE,MACA,EADUF,KACV,CAAAA,KAAA,CAAQ,CAHZ,CAOID,MAAJ,CAAYE,KAAZ,CAAoBG,KAAAH,MAApB,GAEIA,KAFJ,CAEYQ,IAAAC,IAAA,CAASN,KAAAH,MAAT,CAAuBF,KAAvB,CAA8B,CAA9B,CAFZ,CAIIC,MAAJ,CAAYE,MAAZ,CAAqBE,KAAAF,OAArB,GAEIA,MAFJ,CAEaO,IAAAC,IAAA,CAASN,KAAAF,OAAT,CAAwBF,KAAxB,CAA+B,CAA/B,CAFb,CAOA,KAFA,IAAIW,QAAU,EAAd,CAESC,GAAKZ,KAAd,CAAqBY,EAArB,CAA0BZ,KAA1B,CAAkCE,MAAlC,CAA0CU,EAAA,EAA1C,CAEI,IAAK,IAAIC,GAAKd,KAAd,CAAqBc,EAArB,CAA0Bd,KAA1B,CAAkCE,KAAlC,CAAyCY,EAAA,EAAzC,CACA,CACI,IAAIC,KAAOV,KAAAW,KAAA,CAAWH,EAAX,CAAA,CAAeC,EAAf,CACE,KAAb,GAAIC,IAAJ,EAEQR,UAFR,EAEqC,EAFrC,GAEsBQ,IAAAE,MAFtB,EAGI,EAAIT,WAAJ,EAAoBU,CAAAH,IAAAG,SAApB,EACIT,gBADJ,EAC2BA,CAAAM,IAAAN,mBAD3B,CAHJ;AAKIG,OAAAO,KAAA,CAAaJ,IAAb,CAPR,CAYJ,MAAOH,QAjDX,CAlC8H;",
"sources":["node_modules/Phaser/src/tilemaps/components/GetTilesWithin.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$tilemaps$components$GetTilesWithin\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @typedef {object} GetTilesWithinFilteringOptions\r\n *\r\n * @property {boolean} [isNotEmpty=false] - If true, only return tiles that don't have -1 for an index.\r\n * @property {boolean} [isColliding=false] - If true, only return tiles that collide on at least one side.\r\n * @property {boolean} [hasInterestingFace=false] - If true, only return tiles that have at least one interesting face.\r\n */\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithin\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {integer} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {object} GetTilesWithinFilteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithin = function (tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    if (tileX === undefined) { tileX = 0; }\r\n    if (tileY === undefined) { tileY = 0; }\r\n    if (width === undefined) { width = layer.width; }\r\n    if (height === undefined) { height = layer.height; }\r\n\r\n    var isNotEmpty = GetFastValue(filteringOptions, 'isNotEmpty', false);\r\n    var isColliding = GetFastValue(filteringOptions, 'isColliding', false);\r\n    var hasInterestingFace = GetFastValue(filteringOptions, 'hasInterestingFace', false);\r\n\r\n    // Clip x, y to top left of map, while shrinking width/height to match.\r\n    if (tileX < 0)\r\n    {\r\n        width += tileX;\r\n        tileX = 0;\r\n    }\r\n    if (tileY < 0)\r\n    {\r\n        height += tileY;\r\n        tileY = 0;\r\n    }\r\n\r\n    // Clip width and height to bottom right of map.\r\n    if (tileX + width > layer.width)\r\n    {\r\n        width = Math.max(layer.width - tileX, 0);\r\n    }\r\n    if (tileY + height > layer.height)\r\n    {\r\n        height = Math.max(layer.height - tileY, 0);\r\n    }\r\n\r\n    var results = [];\r\n\r\n    for (var ty = tileY; ty < tileY + height; ty++)\r\n    {\r\n        for (var tx = tileX; tx < tileX + width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n            if (tile !== null)\r\n            {\r\n                if (isNotEmpty && tile.index === -1) { continue; }\r\n                if (isColliding && !tile.collides) { continue; }\r\n                if (hasInterestingFace && !tile.hasInterestingFace) { continue; }\r\n                results.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = GetTilesWithin;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","GetFastValue","GetTilesWithin","tileX","tileY","width","height","filteringOptions","layer","undefined","isNotEmpty","isColliding","hasInterestingFace","Math","max","results","ty","tx","tile","data","index","collides","push"]
}
