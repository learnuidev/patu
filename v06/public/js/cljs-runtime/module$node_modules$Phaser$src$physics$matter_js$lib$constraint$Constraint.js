shadow$provide.module$node_modules$Phaser$src$physics$matter_js$lib$constraint$Constraint=function(global,require,module,exports){var Constraint={};module.exports=Constraint;var Vertices=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices"),Vector=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vector"),Sleeping=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Sleeping"),Bounds=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Bounds"),
Axes=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Axes"),Common=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Common");(function(){Constraint._warming=.4;Constraint._torqueDampen=1;Constraint._minLength=1E-6;Constraint.create=function(options){options.bodyA&&!options.pointA&&(options.pointA={x:0,y:0});options.bodyB&&!options.pointB&&(options.pointB={x:0,y:0});var initialPointA=options.bodyA?Vector.add(options.bodyA.position,options.pointA):options.pointA,
initialPointB=options.bodyB?Vector.add(options.bodyB.position,options.pointB):options.pointB;initialPointA=Vector.magnitude(Vector.sub(initialPointA,initialPointB));options.length="undefined"!==typeof options.length?options.length:initialPointA;options.id=options.id||Common.nextId();options.label=options.label||"Constraint";options.type="constraint";options.stiffness=options.stiffness||(0<options.length?1:.7);options.damping=options.damping||0;options.angularStiffness=options.angularStiffness||0;
options.angleA=options.bodyA?options.bodyA.angle:options.angleA;options.angleB=options.bodyB?options.bodyB.angle:options.angleB;options.plugin={};initialPointA={visible:!0,lineWidth:2,strokeStyle:"#ffffff",type:"line",anchors:!0};0===options.length&&.1<options.stiffness?(initialPointA.type="pin",initialPointA.anchors=!1):.9>options.stiffness&&(initialPointA.type="spring");options.render=Common.extend(initialPointA,options.render);return options};Constraint.preSolveAll=function(bodies){for(var i=0;i<
bodies.length;i+=1){var body=bodies[i],impulse=body.constraintImpulse;body.isStatic||0===impulse.x&&0===impulse.y&&0===impulse.angle||(body.position.x+=impulse.x,body.position.y+=impulse.y,body.angle+=impulse.angle)}};Constraint.solveAll=function(constraints,timeScale){for(var i=0;i<constraints.length;i+=1){var constraint=constraints[i],fixedA=!constraint.bodyA||constraint.bodyA&&constraint.bodyA.isStatic;constraint=!constraint.bodyB||constraint.bodyB&&constraint.bodyB.isStatic;(fixedA||constraint)&&
Constraint.solve(constraints[i],timeScale)}for(i=0;i<constraints.length;i+=1)constraint=constraints[i],fixedA=!constraint.bodyA||constraint.bodyA&&constraint.bodyA.isStatic,constraint=!constraint.bodyB||constraint.bodyB&&constraint.bodyB.isStatic,fixedA||constraint||Constraint.solve(constraints[i],timeScale)};Constraint.solve=function(constraint,timeScale){var bodyA=constraint.bodyA,bodyB=constraint.bodyB,pointA=constraint.pointA,pointB=constraint.pointB;if(bodyA||bodyB){bodyA&&!bodyA.isStatic&&(Vector.rotate(pointA,
bodyA.angle-constraint.angleA,pointA),constraint.angleA=bodyA.angle);bodyB&&!bodyB.isStatic&&(Vector.rotate(pointB,bodyB.angle-constraint.angleB,pointB),constraint.angleB=bodyB.angle);var pointAWorld=pointA,pointBWorld=pointB;bodyA&&(pointAWorld=Vector.add(bodyA.position,pointA));bodyB&&(pointBWorld=Vector.add(bodyB.position,pointB));if(pointAWorld&&pointBWorld){var delta=Vector.sub(pointAWorld,pointBWorld),currentLength=Vector.magnitude(delta);currentLength<Constraint._minLength&&(currentLength=
Constraint._minLength);timeScale=Vector.mult(delta,(currentLength-constraint.length)/currentLength*(1>constraint.stiffness?constraint.stiffness*timeScale:constraint.stiffness));pointAWorld=(bodyA?bodyA.inverseMass:0)+(bodyB?bodyB.inverseMass:0);pointBWorld=pointAWorld+((bodyA?bodyA.inverseInertia:0)+(bodyB?bodyB.inverseInertia:0));if(constraint.damping){var normalVelocity=Vector.create();var normal=Vector.div(delta,currentLength);normalVelocity=Vector.sub(bodyB&&Vector.sub(bodyB.position,bodyB.positionPrev)||
normalVelocity,bodyA&&Vector.sub(bodyA.position,bodyA.positionPrev)||normalVelocity);normalVelocity=Vector.dot(normal,normalVelocity)}bodyA&&!bodyA.isStatic&&(delta=bodyA.inverseMass/pointAWorld,bodyA.constraintImpulse.x-=timeScale.x*delta,bodyA.constraintImpulse.y-=timeScale.y*delta,bodyA.position.x-=timeScale.x*delta,bodyA.position.y-=timeScale.y*delta,constraint.damping&&(bodyA.positionPrev.x-=constraint.damping*normal.x*normalVelocity*delta,bodyA.positionPrev.y-=constraint.damping*normal.y*normalVelocity*
delta),pointA=Vector.cross(pointA,timeScale)/pointBWorld*Constraint._torqueDampen*bodyA.inverseInertia*(1-constraint.angularStiffness),bodyA.constraintImpulse.angle-=pointA,bodyA.angle-=pointA);bodyB&&!bodyB.isStatic&&(delta=bodyB.inverseMass/pointAWorld,bodyB.constraintImpulse.x+=timeScale.x*delta,bodyB.constraintImpulse.y+=timeScale.y*delta,bodyB.position.x+=timeScale.x*delta,bodyB.position.y+=timeScale.y*delta,constraint.damping&&(bodyB.positionPrev.x+=constraint.damping*normal.x*normalVelocity*
delta,bodyB.positionPrev.y+=constraint.damping*normal.y*normalVelocity*delta),pointA=Vector.cross(pointB,timeScale)/pointBWorld*Constraint._torqueDampen*bodyB.inverseInertia*(1-constraint.angularStiffness),bodyB.constraintImpulse.angle+=pointA,bodyB.angle+=pointA)}}};Constraint.postSolveAll=function(bodies){for(var i=0;i<bodies.length;i++){var body=bodies[i],impulse=body.constraintImpulse;if(!(body.isStatic||0===impulse.x&&0===impulse.y&&0===impulse.angle)){Sleeping.set(body,!1);for(var j=0;j<body.parts.length;j++){var part=
body.parts[j];Vertices.translate(part.vertices,impulse);0<j&&(part.position.x+=impulse.x,part.position.y+=impulse.y);0!==impulse.angle&&(Vertices.rotate(part.vertices,impulse.angle,body.position),Axes.rotate(part.axes,impulse.angle),0<j&&Vector.rotateAbout(part.position,impulse.angle,body.position,part.position));Bounds.update(part.bounds,part.vertices,body.velocity)}impulse.angle*=Constraint._warming;impulse.x*=Constraint._warming;impulse.y*=Constraint._warming}}}})()}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$lib$constraint$Constraint.js.map
