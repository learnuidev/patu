{
"version":3,
"file":"module$node_modules$Phaser$src$physics$arcade$tilemap$SeparateTile.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,mEAAA,CAAuF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAO/H,IAAIC,WAAaH,OAAA,CAAQ,kEAAR,CAAjB,CACII,WAAaJ,OAAA,CAAQ,kEAAR,CADjB,CAEIK,mBAAqBL,OAAA,CAAQ,0EAAR,CAkGzBC,OAAAC,QAAA,CAjFmBI,QAAS,CAACC,CAAD,CAAIC,IAAJ,CAAUC,IAAV,CAAgBC,aAAhB,CAA+BC,YAA/B,CAA6CC,QAA7C,CAC5B,CACQC,CAAAA,CAAWH,aAAAI,KACXC,aAAAA;AAAUL,aAAAM,IACd,KAAIC,UAAYP,aAAAQ,MAAhB,CACIC,WAAaT,aAAAU,OADjB,CAEIC,eAAiBZ,IAAAa,SAAjBD,EAAkCZ,IAAAc,UAFtC,CAGIC,aAAef,IAAAgB,QAAfD,EAA+Bf,IAAAiB,WAKnC,IAAI,CAACL,cAAL,EAAuB,CAACG,YAAxB,CAEI,MAAO,CAAA,CAGX,KAAIG,GAAK,CAAT,CACIC,GAAK,CADT,CAEIC,KAAO,CAFX,CAGIC,KAAO,CAEPtB,KAAAuB,UAAA,EAAJ,CAAuBvB,IAAAwB,UAAA,EAAvB,CAGIH,IAHJ,CAGW,EAHX,CAKSrB,IAAAuB,UAAA,EALT,CAK4BvB,IAAAwB,UAAA,EAL5B,GAQIF,IARJ,CAQW,EARX,CAWsB,EAAtB,GAAItB,IAAAyB,OAAA,EAAJ,EAA6C,CAA7C,GAA2BzB,IAAA0B,OAAA,EAA3B,EAAkDb,cAAlD,EAAoEG,YAApE,GAIIK,IACA,CADOM,IAAAC,IAAA,CAASD,IAAAE,IAAA,CAAS7B,IAAA8B,SAAAC,EAAT,CAA2BtB,SAA3B,CAAT,CAAgDkB,IAAAE,IAAA,CAAS7B,IAAAU,MAAT,CAAsBL,CAAtB,CAAhD,CACP,CAAAiB,IAAA,CAAOK,IAAAC,IAAA,CAASD,IAAAE,IAAA,CAAS7B,IAAA8B,SAAAE,EAAT;AAA2BrB,UAA3B,CAAT,CAAiDgB,IAAAE,IAAA,CAAS7B,IAAAY,OAAT,CAAuBL,YAAvB,CAAjD,CALX,CAQA,IAAIc,IAAJ,CAAWC,IAAX,CACA,CACI,GAAIT,cAAJ,GAEIM,EAGI,CAHCxB,UAAA,CAAWK,IAAX,CAAiBC,IAAjB,CAAuBI,CAAvB,CAAiCI,SAAjC,CAA4CL,QAA5C,CAGD,CAAO,CAAP,GAAAe,EAAA,EAAY,CAACtB,kBAAA,CAAmBK,aAAnB,CAAkCF,IAAlC,CALrB,EAOQ,MAAO,CAAA,CAIXgB,aAAJ,GAEII,EAFJ,CAESxB,UAAA,CAAWI,IAAX,CAAiBC,IAAjB,CAAuBM,YAAvB,CAAgCI,UAAhC,CAA4CP,QAA5C,CAFT,CAZJ,CADA,IAmBA,CACI,GAAIY,YAAJ,GAEII,EAGI,CAHCxB,UAAA,CAAWI,IAAX,CAAiBC,IAAjB,CAAuBM,YAAvB,CAAgCI,UAAhC,CAA4CP,QAA5C,CAGD,CAAO,CAAP,GAAAgB,EAAA,EAAY,CAACvB,kBAAA,CAAmBK,aAAnB,CAAkCF,IAAlC,CALrB,EAOQ,MAAO,CAAA,CAIXa,eAAJ,GAEIM,EAFJ,CAESxB,UAAA,CAAWK,IAAX,CAAiBC,IAAjB,CAAuBI,CAAvB,CAAiCI,SAAjC,CAA4CL,QAA5C,CAFT,CAZJ,CAkBA,MAAe,EAAf,GAAQe,EAAR,EAA2B,CAA3B,GAAoBC,EA7ExB,CA3B+H;",
"sources":["node_modules/Phaser/src/physics/arcade/tilemap/SeparateTile.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$arcade$tilemap$SeparateTile\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar TileCheckX = require('./TileCheckX');\r\nvar TileCheckY = require('./TileCheckY');\r\nvar TileIntersectsBody = require('./TileIntersectsBody');\r\n\r\n/**\r\n * The core separation function to separate a physics body and a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.SeparateTile\r\n * @since 3.0.0\r\n *\r\n * @param {number} i - [description]\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to collide against.\r\n * @param {Phaser.Geom.Rectangle} tileWorldRect - [description]\r\n * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemapLayer to collide against.\r\n * @param {number} tileBias - [description]\r\n *\r\n * @return {boolean} Returns true if the body was separated, otherwise false.\r\n */\r\nvar SeparateTile = function (i, body, tile, tileWorldRect, tilemapLayer, tileBias)\r\n{\r\n    var tileLeft = tileWorldRect.left;\r\n    var tileTop = tileWorldRect.top;\r\n    var tileRight = tileWorldRect.right;\r\n    var tileBottom = tileWorldRect.bottom;\r\n    var faceHorizontal = tile.faceLeft || tile.faceRight;\r\n    var faceVertical = tile.faceTop || tile.faceBottom;\r\n\r\n    //  We don't need to go any further if this tile doesn't actually have any colliding faces. This\r\n    //  could happen if the tile was meant to be collided with re: a callback, but otherwise isn't\r\n    //  needed for separation.\r\n    if (!faceHorizontal && !faceVertical)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var ox = 0;\r\n    var oy = 0;\r\n    var minX = 0;\r\n    var minY = 1;\r\n\r\n    if (body.deltaAbsX() > body.deltaAbsY())\r\n    {\r\n        //  Moving faster horizontally, check X axis first\r\n        minX = -1;\r\n    }\r\n    else if (body.deltaAbsX() < body.deltaAbsY())\r\n    {\r\n        //  Moving faster vertically, check Y axis first\r\n        minY = -1;\r\n    }\r\n\r\n    if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical)\r\n    {\r\n        //  We only need do this if both axes have colliding faces AND we're moving in both\r\n        //  directions\r\n        minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));\r\n        minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));\r\n    }\r\n\r\n    if (minX < minY)\r\n    {\r\n        if (faceHorizontal)\r\n        {\r\n            ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias);\r\n\r\n            //  That's horizontal done, check if we still intersects? If not then we can return now\r\n            if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (faceVertical)\r\n        {\r\n            oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if (faceVertical)\r\n        {\r\n            oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias);\r\n\r\n            //  That's vertical done, check if we still intersects? If not then we can return now\r\n            if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (faceHorizontal)\r\n        {\r\n            ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias);\r\n        }\r\n    }\r\n\r\n    return (ox !== 0 || oy !== 0);\r\n};\r\n\r\nmodule.exports = SeparateTile;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","TileCheckX","TileCheckY","TileIntersectsBody","SeparateTile","i","body","tile","tileWorldRect","tilemapLayer","tileBias","tileLeft","left","tileTop","top","tileRight","right","tileBottom","bottom","faceHorizontal","faceLeft","faceRight","faceVertical","faceTop","faceBottom","ox","oy","minX","minY","deltaAbsX","deltaAbsY","deltaX","deltaY","Math","min","abs","position","x","y"]
}
