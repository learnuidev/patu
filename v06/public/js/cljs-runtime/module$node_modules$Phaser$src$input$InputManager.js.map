{
"version":3,
"file":"module$node_modules$Phaser$src$input$InputManager.js",
"lineCount":19,
"mappings":"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",
"sources":["node_modules/Phaser/src/input/InputManager.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$input$InputManager\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Mouse = require('./mouse/MouseManager');\r\nvar Pointer = require('./Pointer');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Touch = require('./touch/TouchManager');\r\nvar TransformMatrix = require('../gameobjects/components/TransformMatrix');\r\nvar TransformXY = require('../math/TransformXY');\r\n\r\n/**\r\n * @classdesc\r\n * The Input Manager is responsible for handling the pointer related systems in a single Phaser Game instance.\r\n *\r\n * Based on the Game Config it will create handlers for mouse and touch support.\r\n *\r\n * Keyboard and Gamepad are plugins, handled directly by the InputPlugin class.\r\n *\r\n * It then manages the event queue, pointer creation and general hit test related operations.\r\n *\r\n * You rarely need to interact with the Input Manager directly, and as such, all of its properties and methods\r\n * should be considered private. Instead, you should use the Input Plugin, which is a Scene level system, responsible\r\n * for dealing with all input events for a Scene.\r\n *\r\n * @class InputManager\r\n * @memberOf Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Game instance that owns the Input Manager.\r\n * @param {object} config - The Input Configuration object, as set in the Game Config.\r\n */\r\nvar InputManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function InputManager (game, config)\r\n    {\r\n        /**\r\n         * The Game instance that owns the Input Manager.\r\n         * A Game only maintains on instance of the Input Manager at any time.\r\n         *\r\n         * @name Phaser.Input.InputManager#game\r\n         * @type {Phaser.Game}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * The Canvas that is used for all DOM event input listeners.\r\n         *\r\n         * @name Phaser.Input.InputManager#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas;\r\n\r\n        /**\r\n         * The Input Configuration object, as set in the Game Config.\r\n         *\r\n         * @name Phaser.Input.InputManager#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = config;\r\n\r\n        /**\r\n         * If set, the Input Manager will run its update loop every frame.\r\n         *\r\n         * @name Phaser.Input.InputManager#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The Event Emitter instance that the Input Manager uses to emit events from.\r\n         *\r\n         * @name Phaser.Input.InputManager#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = new EventEmitter();\r\n\r\n        /**\r\n         * A standard FIFO queue for the native DOM events waiting to be handled by the Input Manager.\r\n         *\r\n         * @name Phaser.Input.InputManager#queue\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.queue = [];\r\n\r\n        /**\r\n         * DOM Callbacks container.\r\n         *\r\n         * @name Phaser.Input.InputManager#domCallbacks\r\n         * @private\r\n         * @type {object}\r\n         * @since 3.10.0\r\n         */\r\n        this.domCallbacks = { up: [], down: [], move: [], upOnce: [], downOnce: [], moveOnce: [] };\r\n\r\n        /**\r\n         * Are there any up callbacks defined?\r\n         *\r\n         * @name Phaser.Input.InputManager#_hasUpCallback\r\n         * @private\r\n         * @type {boolean}\r\n         * @since 3.10.0\r\n         */\r\n        this._hasUpCallback = false;\r\n\r\n        /**\r\n         * Are there any down callbacks defined?\r\n         *\r\n         * @name Phaser.Input.InputManager#_hasDownCallback\r\n         * @private\r\n         * @type {boolean}\r\n         * @since 3.10.0\r\n         */\r\n        this._hasDownCallback = false;\r\n\r\n        /**\r\n         * Are there any move callbacks defined?\r\n         *\r\n         * @name Phaser.Input.InputManager#_hasMoveCallback\r\n         * @private\r\n         * @type {boolean}\r\n         * @since 3.10.0\r\n         */\r\n        this._hasMoveCallback = false;\r\n\r\n        /**\r\n         * Is a custom cursor currently set? (desktop only)\r\n         *\r\n         * @name Phaser.Input.InputManager#_customCursor\r\n         * @private\r\n         * @type {string}\r\n         * @since 3.10.0\r\n         */\r\n        this._customCursor = '';\r\n\r\n        /**\r\n         * Custom cursor tracking value.\r\n         *\r\n         * 0 - No change.\r\n         * 1 - Set new cursor.\r\n         * 2 - Reset cursor.\r\n         *\r\n         * @name Phaser.Input.InputManager#_setCursor\r\n         * @private\r\n         * @type {integer}\r\n         * @since 3.10.0\r\n         */\r\n        this._setCursor = 0;\r\n\r\n        /**\r\n         * The default CSS cursor to be used when interacting with your game.\r\n         *\r\n         * See the `setDefaultCursor` method for more details.\r\n         *\r\n         * @name Phaser.Input.InputManager#defaultCursor\r\n         * @type {string}\r\n         * @since 3.10.0\r\n         */\r\n        this.defaultCursor = '';\r\n\r\n        /**\r\n         * A reference to the Mouse Manager class, if enabled via the `input.mouse` Game Config property.\r\n         *\r\n         * @name Phaser.Input.InputManager#mouse\r\n         * @type {?Phaser.Input.Mouse.MouseManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.mouse = (config.inputMouse) ? new Mouse(this) : null;\r\n\r\n        /**\r\n         * A reference to the Touch Manager class, if enabled via the `input.touch` Game Config property.\r\n         *\r\n         * @name Phaser.Input.InputManager#touch\r\n         * @type {Phaser.Input.Touch.TouchManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.touch = (config.inputTouch) ? new Touch(this) : null;\r\n\r\n        /**\r\n         * An array of Pointers that have been added to the game.\r\n         * The first entry is reserved for the Mouse Pointer, the rest are Touch Pointers.\r\n         *\r\n         * By default there is 1 touch pointer enabled. If you need more use the `addPointer` method to start them,\r\n         * or set the `input.activePointers` property in the Game Config.\r\n         *\r\n         * @name Phaser.Input.InputManager#pointers\r\n         * @type {Phaser.Input.Pointer[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.pointers = [];\r\n\r\n        /**\r\n         * The number of touch objects activated and being processed each update.\r\n         *\r\n         * You can change this by either calling `addPointer` at run-time, or by\r\n         * setting the `input.activePointers` property in the Game Config.\r\n         *\r\n         * @name Phaser.Input.InputManager#pointersTotal\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.10.0\r\n         */\r\n        this.pointersTotal = config.inputActivePointers;\r\n\r\n        if (config.inputTouch && this.pointersTotal === 1)\r\n        {\r\n            this.pointersTotal = 2;\r\n        }\r\n\r\n        for (var i = 0; i <= this.pointersTotal; i++)\r\n        {\r\n            this.pointers.push(new Pointer(this, i));\r\n        }\r\n\r\n        /**\r\n         * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n         * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n         * which will always map to the most recently interacted pointer.\r\n         *\r\n         * @name Phaser.Input.InputManager#mousePointer\r\n         * @type {?Phaser.Input.Pointer}\r\n         * @since 3.10.0\r\n         */\r\n        this.mousePointer = (config.inputMouse) ? this.pointers[0] : null;\r\n\r\n        /**\r\n         * The most recently active Pointer object.\r\n         *\r\n         * If you've only 1 Pointer in your game then this will accurately be either the first finger touched, or the mouse.\r\n         *\r\n         * If your game doesn't need to support multi-touch then you can safely use this property in all of your game\r\n         * code and it will adapt to be either the mouse or the touch, based on device.\r\n         *\r\n         * @name Phaser.Input.InputManager#activePointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @since 3.0.0\r\n         */\r\n        this.activePointer = this.pointers[0];\r\n\r\n        /**\r\n         * Reset every frame. Set to `true` if any of the Pointers are dirty this frame.\r\n         *\r\n         * @name Phaser.Input.InputManager#dirty\r\n         * @type {boolean}\r\n         * @since 3.10.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * The Scale factor being applied to input coordinates.\r\n         *\r\n         * @name Phaser.Input.InputManager#scale\r\n         * @type { { x:number, y:number } }\r\n         * @since 3.0.0\r\n         */\r\n        this.scale = { x: 1, y: 1 };\r\n\r\n        /**\r\n         * If the top-most Scene in the Scene List receives an input it will stop input from\r\n         * propagating any lower down the scene list, i.e. if you have a UI Scene at the top\r\n         * and click something on it, that click will not then be passed down to any other\r\n         * Scene below. Disable this to have input events passed through all Scenes, all the time.\r\n         *\r\n         * @name Phaser.Input.InputManager#globalTopOnly\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.globalTopOnly = true;\r\n\r\n        /**\r\n         * An internal flag that controls if the Input Manager will ignore or process native DOM events this frame.\r\n         * Set via the InputPlugin.stopPropagation method.\r\n         *\r\n         * @name Phaser.Input.InputManager#ignoreEvents\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.ignoreEvents = false;\r\n\r\n        /**\r\n         * The bounds of the Input Manager, used for pointer hit test calculations.\r\n         *\r\n         * @name Phaser.Input.InputManager#bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.0.0\r\n         */\r\n        this.bounds = new Rectangle();\r\n\r\n        /**\r\n         * A re-cycled point-like object to store hit test values in.\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempPoint\r\n         * @type {{x:number,y:number}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempPoint = { x: 0, y: 0 };\r\n\r\n        /**\r\n         * A re-cycled array to store hit results in.\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempHitTest\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._tempHitTest = [];\r\n\r\n        /**\r\n         * A re-cycled matrix used in hit test calculations.\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._tempMatrix = new TransformMatrix();\r\n\r\n        /**\r\n         * A re-cycled matrix used in hit test calculations.\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempMatrix2\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        game.events.once('boot', this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * The Boot handler is called by Phaser.Game when it first starts up.\r\n     * The renderer is available by now.\r\n     *\r\n     * @method Phaser.Input.InputManager#boot\r\n     * @protected\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.canvas = this.game.canvas;\r\n\r\n        this.updateBounds();\r\n\r\n        this.events.emit('boot');\r\n\r\n        this.game.events.on('prestep', this.update, this);\r\n        this.game.events.on('poststep', this.postUpdate, this);\r\n        this.game.events.once('destroy', this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Updates the Input Manager bounds rectangle to match the bounding client rectangle of the\r\n     * canvas element being used to track input events.\r\n     *\r\n     * @method Phaser.Input.InputManager#updateBounds\r\n     * @since 3.0.0\r\n     */\r\n    updateBounds: function ()\r\n    {\r\n        var bounds = this.bounds;\r\n\r\n        var clientRect = this.canvas.getBoundingClientRect();\r\n\r\n        bounds.x = clientRect.left + window.pageXOffset - document.documentElement.clientLeft;\r\n        bounds.y = clientRect.top + window.pageYOffset - document.documentElement.clientTop;\r\n        bounds.width = clientRect.width;\r\n        bounds.height = clientRect.height;\r\n    },\r\n\r\n    /**\r\n     * Resizes the Input Manager internal values, including the bounds and scale factor.\r\n     *\r\n     * @method Phaser.Input.InputManager#resize\r\n     * @since 3.2.0\r\n     */\r\n    resize: function ()\r\n    {\r\n        this.updateBounds();\r\n\r\n        //  Game config size\r\n        var gw = this.game.config.width;\r\n        var gh = this.game.config.height;\r\n\r\n        //  Actual canvas size\r\n        var bw = this.bounds.width;\r\n        var bh = this.bounds.height;\r\n\r\n        //  Scale factor\r\n        this.scale.x = gw / bw;\r\n        this.scale.y = gh / bh;\r\n    },\r\n\r\n    /**\r\n     * Internal update loop, called automatically by the Game Step.\r\n     *\r\n     * @method Phaser.Input.InputManager#update\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The time stamp value of this game step.\r\n     */\r\n    update: function (time)\r\n    {\r\n        var i;\r\n\r\n        this._setCursor = 0;\r\n\r\n        this.events.emit('update');\r\n\r\n        this.ignoreEvents = false;\r\n\r\n        this.dirty = false;\r\n\r\n        var len = this.queue.length;\r\n\r\n        var pointers = this.pointers;\r\n\r\n        for (i = 0; i < this.pointersTotal; i++)\r\n        {\r\n            pointers[i].reset();\r\n        }\r\n\r\n        if (!this.enabled || len === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        this.updateBounds();\r\n\r\n        this.scale.x = this.game.config.width / this.bounds.width;\r\n        this.scale.y = this.game.config.height / this.bounds.height;\r\n\r\n        //  Clears the queue array, and also means we don't work on array data that could potentially\r\n        //  be modified during the processing phase\r\n        var queue = this.queue.splice(0, len);\r\n        var mouse = this.mousePointer;\r\n\r\n        //  Process the event queue, dispatching all of the events that have stored up\r\n        for (i = 0; i < len; i += 2)\r\n        {\r\n            var type = queue[i];\r\n            var event = queue[i + 1];\r\n\r\n            switch (type)\r\n            {\r\n                case CONST.MOUSE_DOWN:\r\n                    mouse.down(event, time);\r\n                    break;\r\n\r\n                case CONST.MOUSE_MOVE:\r\n                    mouse.move(event, time);\r\n                    break;\r\n\r\n                case CONST.MOUSE_UP:\r\n                    mouse.up(event, time);\r\n                    break;\r\n\r\n                case CONST.TOUCH_START:\r\n                    this.startPointer(event, time);\r\n                    break;\r\n\r\n                case CONST.TOUCH_MOVE:\r\n                    this.updatePointer(event, time);\r\n                    break;\r\n\r\n                case CONST.TOUCH_END:\r\n                    this.stopPointer(event, time);\r\n                    break;\r\n\r\n                case CONST.POINTER_LOCK_CHANGE:\r\n                    this.events.emit('pointerlockchange', event, this.mouse.locked);\r\n                    break;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal post-update, called automatically by the Game step.\r\n     *\r\n     * @method Phaser.Input.InputManager#postUpdate\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n        if (this._setCursor === 1)\r\n        {\r\n            this.canvas.style.cursor = this._customCursor;\r\n        }\r\n        else if (this._setCursor === 2)\r\n        {\r\n            this.canvas.style.cursor = this.defaultCursor;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Tells the Input system to set a custom cursor.\r\n     * \r\n     * This cursor will be the default cursor used when interacting with the game canvas.\r\n     *\r\n     * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n     *\r\n     * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n     *\r\n     * ```javascript\r\n     * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n     * ```\r\n     * \r\n     * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n     *\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n     *\r\n     * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n     *\r\n     * @method Phaser.Input.InputManager#setDefaultCursor\r\n     * @since 3.10.0\r\n     * \r\n     * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n     */\r\n    setDefaultCursor: function (cursor)\r\n    {\r\n        this.defaultCursor = cursor;\r\n\r\n        if (this.canvas.style.cursor !== cursor)\r\n        {\r\n            this.canvas.style.cursor = cursor;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the InputPlugin when processing over and out events.\r\n     * \r\n     * Tells the Input Manager to set a custom cursor during its postUpdate step.\r\n     *\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n     *\r\n     * @method Phaser.Input.InputManager#setCursor\r\n     * @private\r\n     * @since 3.10.0\r\n     * \r\n     * @param {Phaser.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.\r\n     */\r\n    setCursor: function (interactiveObject)\r\n    {\r\n        if (interactiveObject.cursor)\r\n        {\r\n            this._setCursor = 1;\r\n            this._customCursor = interactiveObject.cursor;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the InputPlugin when processing over and out events.\r\n     * \r\n     * Tells the Input Manager to clear the hand cursor, if set, during its postUpdate step.\r\n     *\r\n     * @method Phaser.Input.InputManager#resetCursor\r\n     * @private\r\n     * @since 3.10.0\r\n     * \r\n     * @param {Phaser.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.\r\n     */\r\n    resetCursor: function (interactiveObject)\r\n    {\r\n        if (interactiveObject.cursor)\r\n        {\r\n            this._setCursor = 2;\r\n        }\r\n    },\r\n\r\n    //  event.targetTouches = list of all touches on the TARGET ELEMENT (i.e. game dom element)\r\n    //  event.touches = list of all touches on the ENTIRE DOCUMENT, not just the target element\r\n    //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\r\n\r\n    /**\r\n     * Called by the main update loop when a Touch Start Event is received.\r\n     *\r\n     * @method Phaser.Input.InputManager#startPointer\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM event to be processed.\r\n     * @param {number} time - The time stamp value of this game step.\r\n     */\r\n    startPointer: function (event, time)\r\n    {\r\n        var pointers = this.pointers;\r\n\r\n        for (var c = 0; c < event.changedTouches.length; c++)\r\n        {\r\n            var changedTouch = event.changedTouches[c];\r\n\r\n            for (var i = 1; i < this.pointersTotal; i++)\r\n            {\r\n                var pointer = pointers[i];\r\n\r\n                if (!pointer.active)\r\n                {\r\n                    pointer.touchstart(changedTouch, time);\r\n                    this.activePointer = pointer;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the main update loop when a Touch Move Event is received.\r\n     *\r\n     * @method Phaser.Input.InputManager#updatePointer\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM event to be processed.\r\n     * @param {number} time - The time stamp value of this game step.\r\n     */\r\n    updatePointer: function (event, time)\r\n    {\r\n        var pointers = this.pointers;\r\n\r\n        for (var c = 0; c < event.changedTouches.length; c++)\r\n        {\r\n            var changedTouch = event.changedTouches[c];\r\n\r\n            for (var i = 1; i < this.pointersTotal; i++)\r\n            {\r\n                var pointer = pointers[i];\r\n\r\n                if (pointer.active && pointer.identifier === changedTouch.identifier)\r\n                {\r\n                    pointer.touchmove(changedTouch, time);\r\n                    this.activePointer = pointer;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    //  For touch end its a list of the touch points that have been removed from the surface\r\n    //  https://developer.mozilla.org/en-US/docs/DOM/TouchList\r\n    //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\r\n\r\n    /**\r\n     * Called by the main update loop when a Touch End Event is received.\r\n     *\r\n     * @method Phaser.Input.InputManager#stopPointer\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM event to be processed.\r\n     * @param {number} time - The time stamp value of this game step.\r\n     */\r\n    stopPointer: function (event, time)\r\n    {\r\n        var pointers = this.pointers;\r\n\r\n        for (var c = 0; c < event.changedTouches.length; c++)\r\n        {\r\n            var changedTouch = event.changedTouches[c];\r\n\r\n            for (var i = 1; i < this.pointersTotal; i++)\r\n            {\r\n                var pointer = pointers[i];\r\n\r\n                if (pointer.active && pointer.identifier === changedTouch.identifier)\r\n                {\r\n                    pointer.touchend(changedTouch, time);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds new Pointer objects to the Input Manager.\r\n     *\r\n     * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n     *\r\n     * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n     * in the Game Config, up to a maximum of 10 pointers.\r\n     *\r\n     * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n     * via this method.\r\n     *\r\n     * @method Phaser.Input.InputManager#addPointer\r\n     * @since 3.10.0\r\n     *\r\n     * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n     *\r\n     * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n     */\r\n    addPointer: function (quantity)\r\n    {\r\n        if (quantity === undefined) { quantity = 1; }\r\n\r\n        var output = [];\r\n\r\n        if (this.pointersTotal + quantity > 10)\r\n        {\r\n            quantity = 10 - this.pointersTotal;\r\n        }\r\n\r\n        for (var i = 0; i < quantity; i++)\r\n        {\r\n            var id = this.pointers.length;\r\n\r\n            var pointer = new Pointer(this, id);\r\n\r\n            this.pointers.push(pointer);\r\n\r\n            this.pointersTotal++;\r\n\r\n            output.push(pointer);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Process any pending DOM callbacks.\r\n     *\r\n     * @method Phaser.Input.InputManager#processDomCallbacks\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {array} once - The isOnce callbacks to invoke.\r\n     * @param {array} every - The every frame callbacks to invoke.\r\n     * @param {any} event - The native DOM event that is passed to the callbacks.\r\n     *\r\n     * @return {boolean} `true` if there are callbacks still in the list, otherwise `false`.\r\n     */\r\n    processDomCallbacks: function (once, every, event)\r\n    {\r\n        var i = 0;\r\n\r\n        for (i = 0; i < once.length; i++)\r\n        {\r\n            once[i](event);\r\n        }\r\n\r\n        for (i = 0; i < every.length; i++)\r\n        {\r\n            every[i](event);\r\n        }\r\n\r\n        once = [];\r\n\r\n        return (every.length > 0);\r\n    },\r\n\r\n    /**\r\n     * Queues a touch start event, as passed in by the TouchManager.\r\n     * Also dispatches any DOM callbacks for this event.\r\n     *\r\n     * @method Phaser.Input.InputManager#queueTouchStart\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM Touch event.\r\n     */\r\n    queueTouchStart: function (event)\r\n    {\r\n        this.queue.push(CONST.TOUCH_START, event);\r\n\r\n        if (this._hasDownCallback)\r\n        {\r\n            var callbacks = this.domCallbacks;\r\n\r\n            this._hasDownCallback = this.processDomCallbacks(callbacks.downOnce, callbacks.down, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Queues a touch move event, as passed in by the TouchManager.\r\n     * Also dispatches any DOM callbacks for this event.\r\n     *\r\n     * @method Phaser.Input.InputManager#queueTouchMove\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM Touch event.\r\n     */\r\n    queueTouchMove: function (event)\r\n    {\r\n        this.queue.push(CONST.TOUCH_MOVE, event);\r\n\r\n        if (this._hasMoveCallback)\r\n        {\r\n            var callbacks = this.domCallbacks;\r\n\r\n            this._hasMoveCallback = this.processDomCallbacks(callbacks.moveOnce, callbacks.move, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Queues a touch end event, as passed in by the TouchManager.\r\n     * Also dispatches any DOM callbacks for this event.\r\n     *\r\n     * @method Phaser.Input.InputManager#queueTouchEnd\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM Touch event.\r\n     */\r\n    queueTouchEnd: function (event)\r\n    {\r\n        this.queue.push(CONST.TOUCH_END, event);\r\n\r\n        if (this._hasUpCallback)\r\n        {\r\n            var callbacks = this.domCallbacks;\r\n\r\n            this._hasUpCallback = this.processDomCallbacks(callbacks.upOnce, callbacks.up, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Queues a mouse down event, as passed in by the MouseManager.\r\n     * Also dispatches any DOM callbacks for this event.\r\n     *\r\n     * @method Phaser.Input.InputManager#queueMouseDown\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {MouseEvent} event - The native DOM Mouse event.\r\n     */\r\n    queueMouseDown: function (event)\r\n    {\r\n        this.queue.push(CONST.MOUSE_DOWN, event);\r\n\r\n        if (this._hasDownCallback)\r\n        {\r\n            var callbacks = this.domCallbacks;\r\n\r\n            this._hasDownCallback = this.processDomCallbacks(callbacks.downOnce, callbacks.down, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Queues a mouse move event, as passed in by the MouseManager.\r\n     * Also dispatches any DOM callbacks for this event.\r\n     *\r\n     * @method Phaser.Input.InputManager#queueMouseMove\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {MouseEvent} event - The native DOM Mouse event.\r\n     */\r\n    queueMouseMove: function (event)\r\n    {\r\n        this.queue.push(CONST.MOUSE_MOVE, event);\r\n\r\n        if (this._hasMoveCallback)\r\n        {\r\n            var callbacks = this.domCallbacks;\r\n\r\n            this._hasMoveCallback = this.processDomCallbacks(callbacks.moveOnce, callbacks.move, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Queues a mouse up event, as passed in by the MouseManager.\r\n     * Also dispatches any DOM callbacks for this event.\r\n     *\r\n     * @method Phaser.Input.InputManager#queueMouseUp\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {MouseEvent} event - The native DOM Mouse event.\r\n     */\r\n    queueMouseUp: function (event)\r\n    {\r\n        this.queue.push(CONST.MOUSE_UP, event);\r\n\r\n        if (this._hasUpCallback)\r\n        {\r\n            var callbacks = this.domCallbacks;\r\n\r\n            this._hasUpCallback = this.processDomCallbacks(callbacks.upOnce, callbacks.up, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to be invoked whenever the native DOM `mouseup` or `touchend` events are received.\r\n     * By setting the `isOnce` argument you can control if the callback is called once,\r\n     * or every time the DOM event occurs.\r\n     *\r\n     * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n     * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n     * from the perspective of the browser. This means they can be used for tasks such as\r\n     * opening new browser windows, or anything which explicitly requires user input to activate.\r\n     * However, as a result of this, they come with their own risks, and as such should not be used\r\n     * for general game input, but instead be reserved for special circumstances.\r\n     *\r\n     * If all you're trying to do is execute a callback when a pointer is released, then\r\n     * please use the internal Input event system instead.\r\n     *\r\n     * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n     * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n     * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n     * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n     * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n     * solve.\r\n     *\r\n     * @method Phaser.Input.InputManager#addUpCallback\r\n     * @since 3.10.0\r\n     *\r\n     * @param {function} callback - The callback to be invoked on this dom event.\r\n     * @param {boolean} [isOnce=true] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n     *\r\n     * @return {this} The Input Manager.\r\n     */\r\n    addUpCallback: function (callback, isOnce)\r\n    {\r\n        if (isOnce === undefined) { isOnce = true; }\r\n\r\n        if (isOnce)\r\n        {\r\n            this.domCallbacks.upOnce.push(callback);\r\n        }\r\n        else\r\n        {\r\n            this.domCallbacks.up.push(callback);\r\n        }\r\n\r\n        this._hasUpCallback = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to be invoked whenever the native DOM `mousedown` or `touchstart` events are received.\r\n     * By setting the `isOnce` argument you can control if the callback is called once,\r\n     * or every time the DOM event occurs.\r\n     *\r\n     * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n     * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n     * from the perspective of the browser. This means they can be used for tasks such as\r\n     * opening new browser windows, or anything which explicitly requires user input to activate.\r\n     * However, as a result of this, they come with their own risks, and as such should not be used\r\n     * for general game input, but instead be reserved for special circumstances.\r\n     *\r\n     * If all you're trying to do is execute a callback when a pointer is down, then\r\n     * please use the internal Input event system instead.\r\n     *\r\n     * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n     * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n     * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n     * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n     * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n     * solve.\r\n     *\r\n     * @method Phaser.Input.InputManager#addDownCallback\r\n     * @since 3.10.0\r\n     *\r\n     * @param {function} callback - The callback to be invoked on this dom event.\r\n     * @param {boolean} [isOnce=true] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n     *\r\n     * @return {this} The Input Manager.\r\n     */\r\n    addDownCallback: function (callback, isOnce)\r\n    {\r\n        if (isOnce === undefined) { isOnce = true; }\r\n\r\n        if (isOnce)\r\n        {\r\n            this.domCallbacks.downOnce.push(callback);\r\n        }\r\n        else\r\n        {\r\n            this.domCallbacks.down.push(callback);\r\n        }\r\n\r\n        this._hasDownCallback = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to be invoked whenever the native DOM `mousemove` or `touchmove` events are received.\r\n     * By setting the `isOnce` argument you can control if the callback is called once,\r\n     * or every time the DOM event occurs.\r\n     *\r\n     * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,\r\n     * within the scope of the DOM event handler. Therefore, they are considered as 'native'\r\n     * from the perspective of the browser. This means they can be used for tasks such as\r\n     * opening new browser windows, or anything which explicitly requires user input to activate.\r\n     * However, as a result of this, they come with their own risks, and as such should not be used\r\n     * for general game input, but instead be reserved for special circumstances.\r\n     *\r\n     * If all you're trying to do is execute a callback when a pointer is moved, then\r\n     * please use the internal Input event system instead.\r\n     *\r\n     * Please understand that these callbacks are invoked when the browser feels like doing so,\r\n     * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep\r\n     * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,\r\n     * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating\r\n     * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind\r\n     * solve.\r\n     *\r\n     * @method Phaser.Input.InputManager#addMoveCallback\r\n     * @since 3.10.0\r\n     *\r\n     * @param {function} callback - The callback to be invoked on this dom event.\r\n     * @param {boolean} [isOnce=false] - `true` if the callback will only be invoked once, `false` to call every time this event happens.\r\n     *\r\n     * @return {this} The Input Manager.\r\n     */\r\n    addMoveCallback: function (callback, isOnce)\r\n    {\r\n        if (isOnce === undefined) { isOnce = false; }\r\n\r\n        if (isOnce)\r\n        {\r\n            this.domCallbacks.moveOnce.push(callback);\r\n        }\r\n        else\r\n        {\r\n            this.domCallbacks.move.push(callback);\r\n        }\r\n\r\n        this._hasMoveCallback = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Game Object should be considered as a candidate for input or not.\r\n     *\r\n     * Checks if the Game Object has an input component that is enabled, that it will render,\r\n     * and finally, if it has a parent, that the parent parent, or any ancestor, is visible or not.\r\n     *\r\n     * @method Phaser.Input.InputManager#inputCandidate\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to test.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.\r\n     *\r\n     * @return {boolean} `true` if the Game Object should be considered for input, otherwise `false`.\r\n     */\r\n    inputCandidate: function (gameObject, camera)\r\n    {\r\n        var input = gameObject.input;\r\n\r\n        if (!input || !input.enabled || !gameObject.willRender(camera))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var visible = true;\r\n        var parent = gameObject.parentContainer;\r\n\r\n        if (parent)\r\n        {\r\n            do\r\n            {\r\n                if (!parent.willRender(camera))\r\n                {\r\n                    visible = false;\r\n                    break;\r\n                }\r\n\r\n                parent = parent.parentContainer;\r\n\r\n            } while (parent);\r\n        }\r\n\r\n        return visible;\r\n    },\r\n\r\n    /**\r\n     * Performs a hit test using the given Pointer and camera, against an array of interactive Game Objects.\r\n     *\r\n     * The Game Objects are culled against the camera, and then the coordinates are translated into the local camera space\r\n     * and used to determine if they fall within the remaining Game Objects hit areas or not.\r\n     *\r\n     * If nothing is matched an empty array is returned.\r\n     *\r\n     * This method is called automatically by InputPlugin.hitTestPointer and doesn't usually need to be invoked directly.\r\n     *\r\n     * @method Phaser.Input.InputManager#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to test against.\r\n     * @param {array} gameObjects - An array of interactive Game Objects to check.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.\r\n     * @param {array} [output] - An array to store the results in. If not given, a new empty array is created.\r\n     *\r\n     * @return {array} An array of the Game Objects that were hit during this hit test.\r\n     */\r\n    hitTest: function (pointer, gameObjects, camera, output)\r\n    {\r\n        if (output === undefined) { output = this._tempHitTest; }\r\n\r\n        var tempPoint = this._tempPoint;\r\n\r\n        var csx = camera.scrollX;\r\n        var csy = camera.scrollY;\r\n\r\n        output.length = 0;\r\n\r\n        var x = pointer.x;\r\n        var y = pointer.y;\r\n\r\n        if (camera.resolution !== 1)\r\n        {\r\n            x += camera._x;\r\n            y += camera._y;\r\n        }\r\n\r\n        //  Stores the world point inside of tempPoint\r\n        camera.getWorldPoint(x, y, tempPoint);\r\n\r\n        pointer.worldX = tempPoint.x;\r\n        pointer.worldY = tempPoint.y;\r\n\r\n        var point = { x: 0, y: 0 };\r\n\r\n        var matrix = this._tempMatrix;\r\n        var parentMatrix = this._tempMatrix2;\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            //  Checks if the Game Object can receive input (isn't being ignored by the camera, invisible, etc)\r\n            //  and also checks all of its parents, if any\r\n            if (!this.inputCandidate(gameObject, camera))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var px = tempPoint.x + (csx * gameObject.scrollFactorX) - csx;\r\n            var py = tempPoint.y + (csy * gameObject.scrollFactorY) - csy;\r\n\r\n            if (gameObject.parentContainer)\r\n            {\r\n                gameObject.getWorldTransformMatrix(matrix, parentMatrix);\r\n\r\n                matrix.applyInverse(px, py, point);\r\n            }\r\n            else\r\n            {\r\n                TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);\r\n            }\r\n    \r\n            if (this.pointWithinHitArea(gameObject, point.x, point.y))\r\n            {\r\n                output.push(gameObject);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given x and y coordinate are within the hit area of the Game Object.\r\n     *\r\n     * This method assumes that the coordinate values have already been translated into the space of the Game Object.\r\n     *\r\n     * If the coordinates are within the hit area they are set into the Game Objects Input `localX` and `localY` properties.\r\n     *\r\n     * @method Phaser.Input.InputManager#pointWithinHitArea\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object to check against.\r\n     * @param {number} x - The translated x coordinate for the hit test.\r\n     * @param {number} y - The translated y coordinate for the hit test.\r\n     *\r\n     * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.\r\n     */\r\n    pointWithinHitArea: function (gameObject, x, y)\r\n    {\r\n        //  Normalize the origin\r\n        x += gameObject.displayOriginX;\r\n        y += gameObject.displayOriginY;\r\n\r\n        var input = gameObject.input;\r\n\r\n        if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject))\r\n        {\r\n            input.localX = x;\r\n            input.localY = y;\r\n\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if the given x and y coordinate are within the hit area of the Interactive Object.\r\n     *\r\n     * This method assumes that the coordinate values have already been translated into the space of the Interactive Object.\r\n     *\r\n     * If the coordinates are within the hit area they are set into the Interactive Objects Input `localX` and `localY` properties.\r\n     *\r\n     * @method Phaser.Input.InputManager#pointWithinInteractiveObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.InteractiveObject} object - The Interactive Object to check against.\r\n     * @param {number} x - The translated x coordinate for the hit test.\r\n     * @param {number} y - The translated y coordinate for the hit test.\r\n     *\r\n     * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.\r\n     */\r\n    pointWithinInteractiveObject: function (object, x, y)\r\n    {\r\n        if (!object.hitArea)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  Normalize the origin\r\n        x += object.gameObject.displayOriginX;\r\n        y += object.gameObject.displayOriginY;\r\n\r\n        object.localX = x;\r\n        object.localY = y;\r\n\r\n        return object.hitAreaCallback(object.hitArea, x, y, object);\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageX and pageY values of a Pointer into the scaled coordinate space of the Input Manager.\r\n     *\r\n     * @method Phaser.Input.InputManager#transformPointer\r\n     * @since 3.10.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to transform the values for.\r\n     * @param {number} pageX - The Page X value.\r\n     * @param {number} pageY - The Page Y value.\r\n     */\r\n    transformPointer: function (pointer, pageX, pageY)\r\n    {\r\n        //  Store the previous position\r\n        pointer.prevPosition.x = pointer.x;\r\n        pointer.prevPosition.y = pointer.y;\r\n\r\n        pointer.x = (pageX - this.bounds.left) * this.scale.x;\r\n        pointer.y = (pageY - this.bounds.top) * this.scale.y;\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageX value into the scaled coordinate space of the Input Manager.\r\n     *\r\n     * @method Phaser.Input.InputManager#transformX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} pageX - The DOM pageX value.\r\n     *\r\n     * @return {number} The translated value.\r\n     */\r\n    transformX: function (pageX)\r\n    {\r\n        return (pageX - this.bounds.left) * this.scale.x;\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageY value into the scaled coordinate space of the Input Manager.\r\n     *\r\n     * @method Phaser.Input.InputManager#transformY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} pageY - The DOM pageY value.\r\n     *\r\n     * @return {number} The translated value.\r\n     */\r\n    transformY: function (pageY)\r\n    {\r\n        return (pageY - this.bounds.top) * this.scale.y;\r\n    },\r\n\r\n    /**\r\n     * Returns the left offset of the Input bounds.\r\n     *\r\n     * @method Phaser.Input.InputManager#getOffsetX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The left bounds value.\r\n     */\r\n    getOffsetX: function ()\r\n    {\r\n        return this.bounds.left;\r\n    },\r\n\r\n    /**\r\n     * Returns the top offset of the Input bounds.\r\n     *\r\n     * @method Phaser.Input.InputManager#getOffsetY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The top bounds value.\r\n     */\r\n    getOffsetY: function ()\r\n    {\r\n        return this.bounds.top;\r\n    },\r\n\r\n    /**\r\n     * Returns the horizontal Input Scale value.\r\n     *\r\n     * @method Phaser.Input.InputManager#getScaleX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The horizontal scale factor of the input.\r\n     */\r\n    getScaleX: function ()\r\n    {\r\n        return this.game.config.width / this.bounds.width;\r\n    },\r\n\r\n    /**\r\n     * Returns the vertical Input Scale value.\r\n     *\r\n     * @method Phaser.Input.InputManager#getScaleY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The vertical scale factor of the input.\r\n     */\r\n    getScaleY: function ()\r\n    {\r\n        return this.game.config.height / this.bounds.height;\r\n    },\r\n\r\n    /**\r\n     * Destroys the Input Manager and all of its systems.\r\n     *\r\n     * There is no way to recover from doing this.\r\n     *\r\n     * @method Phaser.Input.InputManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.events.removeAllListeners();\r\n\r\n        if (this.mouse)\r\n        {\r\n            this.mouse.destroy();\r\n        }\r\n\r\n        if (this.touch)\r\n        {\r\n            this.touch.destroy();\r\n        }\r\n\r\n        for (var i = 0; i < this.pointers.length; i++)\r\n        {\r\n            this.pointers[i].destroy();\r\n        }\r\n\r\n        this.domCallbacks = {};\r\n        this.pointers = [];\r\n        this.queue = [];\r\n        this._tempHitTest = [];\r\n        this._tempMatrix.destroy();\r\n        this.canvas = null;\r\n        this.game = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = InputManager;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Class","CONST","EventEmitter","Mouse","Pointer","Rectangle","Touch","TransformMatrix","TransformXY","InputManager","initialize","game","config","enabled","events","queue","domCallbacks","up","down","move","upOnce","downOnce","moveOnce","_hasMoveCallback","_hasDownCallback","_hasUpCallback","_customCursor","_setCursor","defaultCursor","mouse","inputMouse","touch","inputTouch","pointers","pointersTotal","inputActivePointers","i","push","mousePointer","activePointer","dirty","scale","x","y","globalTopOnly","ignoreEvents","bounds","_tempPoint","_tempHitTest","_tempMatrix","_tempMatrix2","once","boot","canvas","updateBounds","emit","on","update","postUpdate","destroy","clientRect","getBoundingClientRect","left","window","pageXOffset","document","documentElement","clientLeft","top","pageYOffset","clientTop","width","height","resize","gh","bh","time","len","length","reset","splice","event","type","MOUSE_DOWN","MOUSE_MOVE","MOUSE_UP","TOUCH_START","startPointer","TOUCH_MOVE","updatePointer","TOUCH_END","stopPointer","POINTER_LOCK_CHANGE","locked","style","cursor","setDefaultCursor","setCursor","interactiveObject","resetCursor","c","changedTouches","changedTouch","pointer","active","touchstart","identifier","touchmove","touchend","addPointer","quantity","undefined","output","processDomCallbacks","every","queueTouchStart","callbacks","queueTouchMove","queueTouchEnd","queueMouseDown","queueMouseMove","queueMouseUp","addUpCallback","callback","isOnce","addDownCallback","addMoveCallback","inputCandidate","gameObject","camera","input","willRender","visible","parent","parentContainer","hitTest","gameObjects","tempPoint","csx","scrollX","csy","scrollY","resolution","_x","_y","getWorldPoint","worldX","worldY","point","matrix","parentMatrix","px","scrollFactorX","py","scrollFactorY","getWorldTransformMatrix","applyInverse","rotation","scaleX","scaleY","pointWithinHitArea","displayOriginX","displayOriginY","hitAreaCallback","hitArea","localX","localY","pointWithinInteractiveObject","object","transformPointer","pageX","pageY","prevPosition","transformX","transformY","getOffsetX","getOffsetY","getScaleX","getScaleY","removeAllListeners"]
}
