{
"version":3,
"file":"module$node_modules$Phaser$src$physics$arcade$World.js",
"lineCount":51,
"mappings":"AAAAA,cAAA,oDAAA,CAAwE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAOhH,IAAIC,KAAOH,OAAA,CAAQ,oDAAR,CAAX,CACII,MAAQJ,OAAA,CAAQ,2CAAR,CACRK,OAAAA,CAAQL,OAAA,CAAQ,4CAAR,CACZ,KAAIM,SAAWN,OAAA,CAAQ,wDAAR,CAAf,CACIO,MAAQP,OAAA,CAAQ,qDAAR,CADZ,CAEIQ,gBAAkBR,OAAA,CAAQ,8DAAR,CAFtB;AAGIS,aAAeT,OAAA,CAAQ,yCAAR,CAHnB,CAIIU,WAAaV,OAAA,CAAQ,iDAAR,CAJjB,CAKIW,iBAAmBX,OAAA,CAAQ,uDAAR,CALvB,CAMIY,cAAgBZ,OAAA,CAAQ,oDAAR,CANpB,CAOIa,YAAcb,OAAA,CAAQ,2DAAR,CAPlB,CAQIc,YAAcd,OAAA,CAAQ,2DAAR,CARlB,CASIe,SAAWf,OAAA,CAAQ,sDAAR,CATf;AAUIgB,aAAehB,OAAA,CAAQ,qDAAR,CAVnB,CAWIiB,qBAAuBjB,OAAA,CAAQ,4EAAR,CAX3B,CAYIkB,UAAYlB,OAAA,CAAQ,yDAAR,CAZhB,CAaImB,MAAQnB,OAAA,CAAQ,8CAAR,CAbZ,CAcIoB,aAAepB,OAAA,CAAQ,oEAAR,CAdnB,CAeIqB,UAAYrB,OAAA,CAAQ,yDAAR,CAfhB,CAgBIsB,UAAYtB,OAAA,CAAQ,yDAAR,CAhBhB;AAiBIuB,IAAMvB,OAAA,CAAQ,4CAAR,CAjBV,CAkBIwB,WAAaxB,OAAA,CAAQ,0DAAR,CAlBjB,CAmBIyB,mBAAqBzB,OAAA,CAAQ,0EAAR,CAnBzB,CAoBI0B,gBAAkB1B,OAAA,CAAQ,uEAAR,CApBtB,CAqBI2B,QAAU3B,OAAA,CAAQ,6CAAR,CArBd,CAsBI4B,KAAO5B,OAAA,CAAQ,0CAAR,CAuIP6B,QAAAA,CAAQ,IAAIxB,MAAJ,CAAU,CAElByB,QAASrB,YAFS,CAIlBsB,WAEAF,QAAe,CAACG,KAAD;AAAQC,MAAR,CACf,CACIxB,YAAAyB,KAAA,CAAkB,IAAlB,CASA,KAAAF,MAAA,CAAaA,KASb,KAAAG,OAAA,CAAc,IAAIZ,GASlB,KAAAa,aAAA,CAAoB,IAAIb,GASxB,KAAAc,eAAA,CAAsB,IAAId,GAS1B,KAAAe,UAAA,CAAiB,IAAItB,YASrB,KAAAuB,QAAA,CAAe,IAAIZ,OAAJ,CAAYZ,QAAA,CAASkB,MAAT,CAAiB,WAAjB,CAA8B,CAA9B,CAAZ,CAA8ClB,QAAA,CAASkB,MAAT,CAAiB,WAAjB,CAA8B,CAA9B,CAA9C,CASf,KAAAO,OAAA,CAAc,IAAItB,SAAJ,CACVH,QAAA,CAASkB,MAAT,CAAiB,GAAjB,CAAsB,CAAtB,CADU,CAEVlB,QAAA,CAASkB,MAAT,CAAiB,GAAjB,CAAsB,CAAtB,CAFU,CAGVlB,QAAA,CAASkB,MAAT,CAAiB,OAAjB,CAA0BD,KAAAS,IAAAC,KAAAT,OAAAU,MAA1B,CAHU,CAIV5B,QAAA,CAASkB,MAAT,CAAiB,QAAjB,CAA2BD,KAAAS,IAAAC,KAAAT,OAAAW,OAA3B,CAJU,CAcd,KAAAC,eAAA,CAAsB,CAClBC,GAAI/B,QAAA,CAASkB,MAAT,CAAiB,mBAAjB,CAAsC,CAAA,CAAtC,CADc,CAElBc,KAAMhC,QAAA,CAASkB,MAAT;AAAiB,qBAAjB,CAAwC,CAAA,CAAxC,CAFY,CAGlBe,KAAMjC,QAAA,CAASkB,MAAT,CAAiB,qBAAjB,CAAwC,CAAA,CAAxC,CAHY,CAIlBgB,MAAOlC,QAAA,CAASkB,MAAT,CAAiB,sBAAjB,CAAyC,CAAA,CAAzC,CAJW,CAkBtB,KAAAiB,IAAA,CAAWnC,QAAA,CAASkB,MAAT,CAAiB,KAAjB,CAAwB,EAAxB,CAUX,KAAAkB,SAAA,CAAgB,CAUhB,KAAAC,WAAA,CAAkB,CAAlB,CAAsB,IAAAF,IAUtB,KAAAG,aAAA,CAAoB,GAApB,CAA2B,IAAAD,WAU3B,KAAAE,eAAA,CAAsB,CActB,KAAAC,UAAA,CAAiBxC,QAAA,CAASkB,MAAT,CAAiB,WAAjB,CAA8B,CAA9B,CAYjB,KAAAuB,aAAA,CAAoBzC,QAAA,CAASkB,MAAT,CAAiB,aAAjB,CAAgC,CAAhC,CAapB,KAAAwB,UAAA,CAAiB1C,QAAA,CAASkB,MAAT,CAAiB,UAAjB,CAA6B,EAA7B,CAWjB,KAAAyB,OAAA,CAAc3C,QAAA,CAASkB,MAAT,CAAiB,QAAjB,CAA2B,CAAA,CAA3B,CAUd,KAAA0B,SAAA,CAAgB5C,QAAA,CAASkB,MAAT,CAAiB,UAAjB,CAA6B,CAAA,CAA7B,CAWhB,KAAA2B,OAAA;AAAc,CAUd,KAAAC,UAAA,CAAiB9C,QAAA,CAASkB,MAAT,CAAiB,OAAjB,CAA0B,CAAA,CAA1B,CAkBjB,KAAA6B,SAAA,CAAgB,CACZC,cAAehD,QAAA,CAASkB,MAAT,CAAiB,eAAjB,CAAkC,CAAA,CAAlC,CADH,CAEZ+B,oBAAqBjD,QAAA,CAASkB,MAAT,CAAiB,qBAAjB,CAAwC,CAAA,CAAxC,CAFT,CAGZgC,kBAAmBlD,QAAA,CAASkB,MAAT,CAAiB,mBAAjB,CAAsC,CAAA,CAAtC,CAHP,CAIZiC,eAAgBnD,QAAA,CAASkB,MAAT,CAAiB,gBAAjB,CAAmC,QAAnC,CAJJ,CAKZkC,qBAAsBpD,QAAA,CAASkB,MAAT,CAAiB,sBAAjB,CAAyC,GAAzC,CALV,CAMZmC,mBAAoBrD,QAAA,CAASkB,MAAT,CAAiB,oBAAjB,CAAuC,KAAvC,CANR,CAqBhB,KAAAoC,WAAA,CAAkBtD,QAAA,CAASkB,MAAT,CAAiB,YAAjB,CAA+B,EAA/B,CAuBlB,KAAAqC,QAAA,CAAevD,QAAA,CAASkB,MAAT,CAAiB,SAAjB;AAA4B,CAAA,CAA5B,CASf,KAAAsC,KAAA,CAAY,IAAIpD,KAAJ,CAAU,IAAAkD,WAAV,CASZ,KAAAG,WAAA,CAAkB,IAAIrD,KAAJ,CAAU,IAAAkD,WAAV,CASlB,KAAAI,WAAA,CAAkB,CAAEC,KAAM,CAAR,CAAWC,KAAM,CAAjB,CAAoBC,KAAM,CAA1B,CAA6BC,KAAM,CAAnC,CAUlB,KAAAC,YAAA,CAAmB,IAAIpD,eAUvB,KAAAqD,aAAA,CAAoB,IAAIrD,eAEpB,KAAAmC,UAAJ,EAEI,IAAAmB,mBAAA,EA1UR,CAPkB,CAkXlBC,OAAQA,QAAS,CAACC,MAAD,CAASC,QAAT,CACjB,CACqBC,IAAAA,EAAjB,GAAID,QAAJ,GAA8BA,QAA9B,CAAyC5E,KAAA8E,aAAzC,CAEKC,MAAAC,QAAA,CAAcL,MAAd,CAAL,GAEIA,MAFJ,CAEa,CAAEA,MAAF,CAFb,CAKA,KAAK,IAAIM,EAAI,CAAb,CAAgBA,CAAhB,CAAoBN,MAAAO,OAApB,CAAmCD,CAAA,EAAnC,CACA,CACI,IAAIE,MAAQR,MAAA,CAAOM,CAAP,CAEZ,IAAIE,KAAAC,SAAJ,CACA,CACQC,KAAAA,CAAWF,KAAAG,YAAA,EAEf,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBF,KAAAH,OAApB,CAAqCK,CAAA,EAArC,CACA,CACI,IAAIC;AAAQH,KAAA,CAASE,CAAT,CAERC,MAAAJ,SAAJ,CAGI,IAAAV,OAAA,CAAYc,KAAZ,CAAmBZ,QAAnB,CAHJ,CAOI,IAAAa,WAAA,CAAgBD,KAAhB,CAAuBZ,QAAvB,CAVR,CAJJ,CADA,IAqBI,KAAAa,WAAA,CAAgBN,KAAhB,CAAuBP,QAAvB,CAxBR,CATJ,CAnXkB,CAublBa,WAAYA,QAAS,CAACd,MAAD,CAASC,QAAT,CACrB,CACqBC,IAAAA,EAAjB,GAAID,QAAJ,GAA8BA,QAA9B,CAAyC5E,KAAA8E,aAAzC,CAEKH,OAAAe,KAAL,GAEQd,QAAJ,GAAiB5E,KAAA8E,aAAjB,CAEIH,MAAAe,KAFJ,CAEkB,IAAI9F,IAAJ,CAAS,IAAT,CAAe+E,MAAf,CAFlB,CAISC,QAJT,GAIsB5E,KAAA2F,YAJtB,GAMIhB,MAAAe,KANJ,CAMkB,IAAIzE,UAAJ,CAAe,IAAf,CAAqB0D,MAArB,CANlB,CAFJ,CAYA,KAAAiB,IAAA,CAASjB,MAAAe,KAAT,CAEA,OAAOf,OAjBX,CAxbkB,CAwdlBiB,IAAKA,QAAS,CAACF,IAAD,CACd,CACQA,IAAAG,YAAJ,GAAyB7F,KAAA8E,aAAzB,CAEI,IAAAlD,OAAAkE,IAAA,CAAgBJ,IAAhB,CAFJ,CAISA,IAAAG,YAJT,GAI8B7F,KAAA2F,YAJ9B;CAMI,IAAA9D,aAAAiE,IAAA,CAAsBJ,IAAtB,CAEA,CAAA,IAAAzB,WAAA8B,OAAA,CAAuBL,IAAvB,CARJ,CAWAA,KAAAhB,OAAA,CAAc,CAAA,CAEd,OAAOgB,KAdX,CAzdkB,CAwflBM,QAASA,QAAS,CAACrB,MAAD,CAClB,CACSI,KAAAC,QAAA,CAAcL,MAAd,CAAL,GAEIA,MAFJ,CAEa,CAAEA,MAAF,CAFb,CAKA,KAAK,IAAIM,EAAI,CAAb,CAAgBA,CAAhB,CAAoBN,MAAAO,OAApB,CAAmCD,CAAA,EAAnC,CACA,CACI,IAAIE,MAAQR,MAAA,CAAOM,CAAP,CAEZ,IAAIE,KAAAC,SAAJ,CACA,CACQC,KAAAA,CAAWF,KAAAG,YAAA,EAEf,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBF,KAAAH,OAApB,CAAqCK,CAAA,EAArC,CACA,CACI,IAAIC,MAAQH,KAAA,CAASE,CAAT,CAERC,MAAAJ,SAAJ,CAGI,IAAAY,QAAA,CAAaR,KAAb,CAHJ,CAOI,IAAAS,YAAA,CAAiBT,KAAAE,KAAjB,CAVR,CAJJ,CADA,IAqBI,KAAAO,YAAA,CAAiBd,KAAAO,KAAjB,CAxBR,CAPJ,CAzfkB,CA0iBlBO,YAAaA,QAAS,CAACP,IAAD,CACtB,CACI,IAAAQ,OAAA,CAAYR,IAAZ,CAEAA,KAAAhB,OAAA,CAAc,CAAA,CAHlB,CA3iBkB,CA8jBlBwB,OAAQA,QAAS,CAACR,IAAD,CACjB,CACQA,IAAAG,YAAJ;AAAyB7F,KAAA8E,aAAzB,EAEI,IAAAd,KAAAkC,OAAA,CAAiBR,IAAjB,CACA,CAAA,IAAA9D,OAAAuE,OAAA,CAAmBT,IAAnB,CAHJ,EAKSA,IAAAG,YALT,GAK8B7F,KAAA2F,YAL9B,GAOI,IAAA9D,aAAAsE,OAAA,CAAyBT,IAAzB,CACA,CAAA,IAAAzB,WAAAiC,OAAA,CAAuBR,IAAvB,CARJ,CADJ,CA/jBkB,CA6lBlBjB,mBAAoBA,QAAS,EAC7B,CACI,IAAI2B,QAAU,IAAA3E,MAAAS,IAAA0D,IAAAS,SAAA,CAA4B,CAAEC,EAAG,CAAL,CAAQC,EAAG,CAAX,CAA5B,CAEdH,QAAAI,SAAA,CAAiBC,MAAAC,UAAjB,CAEA,KAAAC,aAAA,CAAoBP,OAEpB,KAAA9C,UAAA,CAAiB,CAAA,CAEjB,OAAO8C,QATX,CA9lBkB,CAgoBlBQ,UAAWA,QAAS,CAACN,CAAD,CAAIC,CAAJ,CAAOnE,KAAP,CAAcC,MAAd,CAAsBwE,SAAtB,CAAiCC,UAAjC,CAA6CC,OAA7C,CAAsDC,SAAtD,CACpB,CACI,IAAA/E,OAAAgF,MAAA,CAAkBX,CAAlB,CAAqBC,CAArB,CAAwBnE,KAAxB,CAA+BC,MAA/B,CAEkBwC,KAAAA,EAAlB,GAAIgC,SAAJ,EAEI,IAAAK,mBAAA,CAAwBL,SAAxB;AAAmCC,UAAnC,CAA+CC,OAA/C,CAAwDC,SAAxD,CAGJ,OAAO,KARX,CAjoBkB,CAypBlBE,mBAAoBA,QAAS,CAACzE,IAAD,CAAOC,KAAP,CAAcH,EAAd,CAAkBC,IAAlB,CAC7B,CACiBqC,IAAAA,EAAb,GAAIpC,IAAJ,GAA0BA,IAA1B,CAAiC,CAAA,CAAjC,CACcoC,KAAAA,EAAd,GAAInC,KAAJ,GAA2BA,KAA3B,CAAmC,CAAA,CAAnC,CACWmC,KAAAA,EAAX,GAAItC,EAAJ,GAAwBA,EAAxB,CAA6B,CAAA,CAA7B,CACasC,KAAAA,EAAb,GAAIrC,IAAJ,GAA0BA,IAA1B,CAAiC,CAAA,CAAjC,CAEA,KAAAF,eAAAG,KAAA,CAA2BA,IAC3B,KAAAH,eAAAI,MAAA,CAA4BA,KAC5B,KAAAJ,eAAAC,GAAA,CAAyBA,EACzB,KAAAD,eAAAE,KAAA,CAA2BA,IAE3B,OAAO,KAXX,CA1pBkB,CAsrBlB2E,MAAOA,QAAS,EAChB,CACI,IAAA/D,SAAA,CAAgB,CAAA,CAEhB,KAAAgE,KAAA,CAAU,OAAV,CAEA,OAAO,KALX,CAvrBkB,CAwsBlBC,OAAQA,QAAS,EACjB,CACI,IAAAjE,SAAA,CAAgB,CAAA,CAEhB,KAAAgE,KAAA,CAAU,QAAV,CAEA,OAAO,KALX,CAzsBkB,CAwuBlBE,YAAaA,QAAS,CAACC,OAAD,CAAUC,OAAV,CAAmBC,eAAnB;AAAoCC,eAApC,CAAqDC,eAArD,CACtB,CAC4B9C,IAAAA,EAAxB,GAAI4C,eAAJ,GAAqCA,eAArC,CAAuD,IAAvD,CACwB5C,KAAAA,EAAxB,GAAI6C,eAAJ,GAAqCA,eAArC,CAAuD,IAAvD,CACwB7C,KAAAA,EAAxB,GAAI8C,eAAJ,GAAqCA,eAArC,CAAuDF,eAAvD,CAEIG,QAAAA,CAAW,IAAI7H,QAAJ,CAAa,IAAb,CAAmB,CAAA,CAAnB,CAA0BwH,OAA1B,CAAmCC,OAAnC,CAA4CC,eAA5C,CAA6DC,eAA7D,CAA8EC,eAA9E,CAEf,KAAA5F,UAAA6D,IAAA,CAAmBgC,OAAnB,CAEA,OAAOA,QATX,CAzuBkB,CA2wBlBC,WAAYA,QAAS,CAACN,OAAD,CAAUC,OAAV,CAAmBC,eAAnB,CAAoCC,eAApC,CAAqDC,eAArD,CACrB,CAC4B9C,IAAAA,EAAxB,GAAI4C,eAAJ,GAAqCA,eAArC,CAAuD,IAAvD,CACwB5C,KAAAA,EAAxB,GAAI6C,eAAJ,GAAqCA,eAArC;AAAuD,IAAvD,CACwB7C,KAAAA,EAAxB,GAAI8C,eAAJ,GAAqCA,eAArC,CAAuDF,eAAvD,CAEIG,QAAAA,CAAW,IAAI7H,QAAJ,CAAa,IAAb,CAAmB,CAAA,CAAnB,CAAyBwH,OAAzB,CAAkCC,OAAlC,CAA2CC,eAA3C,CAA4DC,eAA5D,CAA6EC,eAA7E,CAEf,KAAA5F,UAAA6D,IAAA,CAAmBgC,OAAnB,CAEA,OAAOA,QATX,CA5wBkB,CAyyBlBE,eAAgBA,QAAS,CAACF,QAAD,CACzB,CACI,IAAA7F,UAAAmE,OAAA,CAAsB0B,QAAtB,CAEA,OAAO,KAHX,CA1yBkB,CAm0BlBG,OAAQA,QAAS,CAACC,SAAD,CACjB,CACI,IAAArF,IAAA,CAAWqF,SACX,KAAAnF,WAAA,CAAkB,CAAlB,CAAsB,IAAAF,IACtB,KAAAG,aAAA,CAAoB,GAApB,CAA2B,IAAAD,WAE3B,OAAO,KALX,CAp0BkB,CAw1BlBoF,OAAQA,QAAS,CAACC,IAAD,CAAOC,KAAP,CACjB,CACI,GAAI/E,CAAA,IAAAA,SAAJ,EAA0C,CAA1C,GAAqB,IAAAxB,OAAAwG,KAArB,CAAA,CAKIC,IAAAA,CAAiB,CACrB,KAAIC,WAAa,IAAAzF,WAAjB;AACI0F,WAAa,IAAAzF,aAAbyF,CAAiC,IAAAvF,UAIrC,KAFA,IAAAJ,SAEA,EAFiBuF,KAEjB,CAAO,IAAAvF,SAAP,EAAwB2F,UAAxB,CAAA,CAEI,IAAA3F,SAIA,EAJiB2F,UAIjB,CAFAF,IAAA,EAEA,CAAA,IAAAG,KAAA,CAAUF,UAAV,CAGJ,KAAAvF,eAAA,CAAsBsF,IApBtB,CADJ,CAz1BkB,CAy3BlBG,KAAMA,QAAS,CAACL,KAAD,CACf,CAEI,IAAIlD,CAAJ,CAEIrD,OAAS,IAAAA,OAAA6G,QAFb,CAGIC,IAAM9G,MAAAsD,OAEV,KAAKD,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgByD,GAAhB,CAAqBzD,CAAA,EAArB,CACA,CACI,IAAAS,KAAO9D,MAAA,CAAOqD,CAAP,CAEHS,KAAAhB,OAAJ,EAEIgB,IAAAuC,OAAA,CAAYE,KAAZ,CALR,CAUI,IAAApE,QAAJ,GAEI,IAAAC,KAAA2E,MAAA,EACA,CAAA,IAAA3E,KAAA4E,KAAA,CAAehH,MAAf,CAHJ,CAOIG,MAAAA,CAAY,IAAAA,UAAAkG,OAAA,EAEhB,KAAKhD,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBlD,KAAAmD,OAAhB,CAAkCD,CAAA,EAAlC,CAEQ2C,IAEJ,CAFe7F,KAAA,CAAUkD,CAAV,CAEf,CAAI2C,IAAAiB,OAAJ,EAEIjB,IAAAK,OAAA,EAIRS,IAAA,CAAM9G,MAAAsD,OAEN,KAAKD,CAAL,CAAS,CAAT,CAAYA,CAAZ;AAAgByD,GAAhB,CAAqBzD,CAAA,EAArB,CAEIS,IAEA,CAFO9D,MAAA,CAAOqD,CAAP,CAEP,CAAIS,IAAAhB,OAAJ,EAEIgB,IAAAoD,WAAA,EA7CZ,CA13BkB,CAk7BlBA,WAAYA,QAAS,EACrB,CACI,IAAI7D,CAAJ,CAGI8D,QAAU,IAAAnH,OAHd,CAIIC,aAAe,IAAAA,aAJnB,CAKImH,QAAU,IAAAlH,eALd,CAOIF,OAASmH,OAAAN,QAPb,CAQIC,IAAM9G,MAAAsD,OAEV,IAAI,IAAA5B,UAAJ,CACA,CACI,IAAI+C,SAAW,IAAAM,aAEfN,SAAAsC,MAAA,EAEA,KAAK1D,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgByD,GAAhB,CAAqBzD,CAAA,EAArB,CACA,CACI,IAAAS,KAAO9D,MAAA,CAAOqD,CAAP,CAEHS,KAAAuD,cAAA,EAAJ,EAEIvD,IAAApC,UAAA,CAAe+C,QAAf,CALR,CASAzE,MAAA,CAASC,YAAA4G,QACTC,IAAA,CAAM9G,MAAAsD,OAEN,KAAKD,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgByD,GAAhB,CAAqBzD,CAAA,EAArB,CAEIS,IAEA,CAFO9D,MAAA,CAAOqD,CAAP,CAEP,CAAIS,IAAAuD,cAAA,EAAJ,EAEIvD,IAAApC,UAAA,CAAe+C,QAAf,CAxBZ,CA6BA,GAAmB,CAAnB,CAAI2C,OAAAZ,KAAJ,CACA,CACQc,QAAAA;AAAc,IAAAlF,KAClB,KAAIC,WAAa,IAAAA,WAEjBrC,OAAA,CAASoH,OAAAP,QACTC,IAAA,CAAM9G,MAAAsD,OAEN,KAAKD,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgByD,GAAhB,CAAqBzD,CAAA,EAArB,CAEIS,IAcA,CAdO9D,MAAA,CAAOqD,CAAP,CAcP,CAZIS,IAAAG,YAAJ,GAAyB7F,KAAA8E,aAAzB,EAEIoE,QAAAhD,OAAA,CAAmBR,IAAnB,CACA,CAAAqD,OAAA5C,OAAA,CAAeT,IAAf,CAHJ,EAKSA,IAAAG,YALT,GAK8B7F,KAAA2F,YAL9B,GAOI1B,UAAAiC,OAAA,CAAkBR,IAAlB,CACA,CAAA7D,YAAAsE,OAAA,CAAoBT,IAApB,CARJ,CAYA,CADAA,IAAAyD,MACA,CADatE,IAAAA,EACb,CAAAa,IAAA0D,WAAA,CAAkBvE,IAAAA,EAGtBmE,QAAAL,MAAA,EA1BJ,CA1CJ,CAn7BkB,CAogClBU,aAAcA,QAAS,CAAC3D,IAAD,CAAOyC,KAAP,CACvB,CACQzC,IAAA4D,cAAJ,EAEI,IAAAC,uBAAA,CAA4B7D,IAA5B,CAAkCyC,KAAlC,CAGJ,KAAAqB,gBAAA,CAAqB9D,IAArB,CAA2ByC,KAA3B,CANJ,CArgCkB,CAuhClBoB,uBAAwBA,QAAS,CAAC7D,IAAD;AAAOyC,KAAP,CACjC,CACI,IAAIsB,SAAW/D,IAAAgE,gBAAf,CACIC,aAAejE,IAAAkE,oBADnB,CAEIC,KAAOnE,IAAAoE,YAFX,CAGIC,IAAMrE,IAAAsE,WAENL,aAAJ,CAEIF,QAFJ,EAEgBE,YAFhB,CAE+BxB,KAF/B,CAISzC,IAAAuE,UAJT,EAI2BJ,IAJ3B,GAMIA,IAII,EAJI1B,KAIJ,CAAAsB,QAAA,CAFArJ,gBAAA,CAAiBqJ,QAAjB,CAA4BI,IAA5B,CAAkC,CAAlC,CAAqC,EAArC,CAAJ,CAEIJ,QAFJ,CAEgBI,IAFhB,CAISxJ,aAAA,CAAcoJ,QAAd,CAAyBI,IAAzB,CAA+B,CAA/B,CAAkC,EAAlC,CAAJ,CAEDJ,QAFC,CAEWI,IAFX,CAMU,CAlBnB,CAsBAJ,SAAA,CAAW5J,KAAA,CAAM4J,QAAN,CAAgB,CAACM,GAAjB,CAAsBA,GAAtB,CAIXrE,KAAAgE,gBAAA,EAFoBD,QAEpB,CAF+B/D,IAAAgE,gBAG/BhE,KAAAwE,SAAA,EAAkBxE,IAAAgE,gBAAlB,CAAyCvB,KAjC7C,CAxhCkB,CAqkClBqB,gBAAiBA,QAAS,CAAC9D,IAAD,CAAOyC,KAAP,CAC1B,CACI,IAAIgC,UAAYzE,IAAA+D,SAAAnD,EAAhB;AACI8D,cAAgB1E,IAAAiE,aAAArD,EADpB,CAEI+D,MAAQ3E,IAAAmE,KAAAvD,EAFZ,CAGIjC,KAAOqB,IAAA4E,YAAAhE,EAHX,CAKIiE,UAAY7E,IAAA+D,SAAAlD,EALhB,CAMIiE,cAAgB9E,IAAAiE,aAAApD,EANpB,CAOIkE,MAAQ/E,IAAAmE,KAAAtD,EAPZ,CAQIjC,KAAOoB,IAAA4E,YAAA/D,EARX,CAUImE,MAAQhF,IAAAgF,MAVZ,CAWIT,UAAYvE,IAAAuE,UAXhB,CAYIU,WAAajF,IAAAiF,WAEbjF,KAAAkF,aAAJ,GAEIT,SACA,GADc,IAAAnI,QAAAsE,EACd,CAD+BZ,IAAA1D,QAAAsE,EAC/B,EADiD6B,KACjD,CAAAoC,SAAA,GAAc,IAAAvI,QAAAuE,EAAd,CAA+Bb,IAAA1D,QAAAuE,EAA/B,EAAiD4B,KAHrD,CAMIiC,cAAJ,CAEID,SAFJ,EAEiBC,aAFjB,CAEiCjC,KAFjC,CAIS8B,SAJT,EAIsBI,KAJtB,GAMQM,UAAJ,EAGIR,SAEA,EAFaE,KAEb,CAAIlK,UAAA,CAAWuK,KAAX,CAAkB,CAAlB,CAAqB,IAArB,CAAJ,GAEIP,SAFJ,CAEgB,CAFhB,CALJ,GAaIE,KAII;AAJKlC,KAIL,CAAAgC,SAAA,CAFA/J,gBAAA,CAAiB+J,SAAjB,CAA6BE,KAA7B,CAAoC,CAApC,CAAuC,GAAvC,CAAJ,CAEIF,SAFJ,CAEiBE,KAFjB,CAIShK,aAAA,CAAc8J,SAAd,CAA0BE,KAA1B,CAAiC,CAAjC,CAAoC,GAApC,CAAJ,CAEDF,SAFC,CAEYE,KAFZ,CAMW,CAzBpB,CANJ,CAoCIG,cAAJ,CAEID,SAFJ,EAEiBC,aAFjB,CAEiCrC,KAFjC,CAIS8B,SAJT,EAIsBQ,KAJtB,GAMQE,UAAJ,EAGIJ,SAEA,EAFaE,KAEb,CAAItK,UAAA,CAAWuK,KAAX,CAAkB,CAAlB,CAAqB,IAArB,CAAJ,GAEIH,SAFJ,CAEgB,CAFhB,CALJ,GAaIE,KAII,EAJKtC,KAIL,CAAAoC,SAAA,CAFAnK,gBAAA,CAAiBmK,SAAjB,CAA6BE,KAA7B,CAAoC,CAApC,CAAuC,GAAvC,CAAJ,CAEIF,SAFJ,CAEiBE,KAFjB,CAISpK,aAAA,CAAckK,SAAd,CAA0BE,KAA1B,CAAiC,CAAjC,CAAoC,GAApC,CAAJ,CAEDF,SAFC,CAEYE,KAFZ,CAMW,CAzBpB,CANJ,CAoCAN,UAAA,CAAYtK,KAAA,CAAMsK,SAAN,CAAiB,CAAC9F,IAAlB,CAAwBA,IAAxB,CACZkG,UAAA,CAAY1K,KAAA,CAAM0K,SAAN,CAAiB,CAACjG,IAAlB,CAAwBA,IAAxB,CAEZoB,KAAA+D,SAAA3D,IAAA,CAAkBqE,SAAlB;AAA6BI,SAA7B,CAhGJ,CAtkCkB,CAyrClBM,SAAUA,QAAS,CAACC,KAAD,CAAQC,KAAR,CAAerD,eAAf,CAAgCC,eAAhC,CAAiDqD,WAAjD,CACnB,CAYI,GAVI,CAACF,KAAApG,OAUL,EATI,CAACqG,KAAArG,OASL,EARIoG,KAAAxI,eAAA2I,KAQJ,EAPIF,KAAAzI,eAAA2I,KAOJ,EANI,CAAC,IAAAC,WAAA,CAAgBJ,KAAhB,CAAuBC,KAAvB,CAML,EAAIrD,eAAJ,EAAqG,CAAA,CAArG,GAAuBA,eAAA/F,KAAA,CAAqBgG,eAArB,CAAsCmD,KAAA1B,WAAtC,CAAwD2B,KAAA3B,WAAxD,CAAvB,CAEI,MAAO,CAAA,CAIX,IAAI0B,KAAAK,SAAJ,EAAsBJ,KAAAI,SAAtB,CAEI,MAAO,KAAAC,eAAA,CAAoBN,KAApB,CAA2BC,KAA3B,CAAkCC,WAAlC,CAOX,IAAIF,KAAAK,SAAJ,GAAuBJ,KAAAI,SAAvB,CACA,CACQE,eAAAA,CAAYP,KAAAK,SAAD,CAAmBJ,KAAnB,CAA2BD,KAInCxE,gBAAAA,CAAA+E,eAAA/E,EAEI5D;IAAAA,oCAAA2I,eAAA3I,MAAAA,CACC4I,qCAAAD,eAAAC,OADD5I,CAIP6I,OAASC,CATKV,KAAAK,SAADM,CAAmBX,KAAnBW,CAA2BV,KAS/BS,QAEb,IAAID,MAAAhF,EAAJ,CAPO8E,eAAA9E,EAOP,EAAyBgF,MAAAhF,EAAzB,CAAoC+E,oCAApC,CAEI,GAAIC,MAAAjF,EAAJ,CAAeA,eAAf,EAAyBiF,MAAAjF,EAAzB,CAAoC5D,mCAApC,CAEI,MAAO,KAAA0I,eAAA,CAAoBN,KAApB,CAA2BC,KAA3B,CAAkCC,WAAlC,CAjBnB,CAuBIU,eAAAA,CADAC,eACAD,CADU,CAAA,CAIV,KAAAvI,OAAJ,EAAmByI,IAAAC,IAAA,CAAS,IAAA7J,QAAAuE,EAAT,CAA0BuE,KAAA9I,QAAAuE,EAA1B,CAAnB,CAAgEqF,IAAAC,IAAA,CAAS,IAAA7J,QAAAsE,EAAT,CAA0BwE,KAAA9I,QAAAsE,EAA1B,CAAhE,EAEIqF,eAGA;AAHU7K,SAAA,CAAUgK,KAAV,CAAiBC,KAAjB,CAAwBC,WAAxB,CAAqC,IAAA/H,aAArC,CAGV,CAAI,IAAAiI,WAAA,CAAgBJ,KAAhB,CAAuBC,KAAvB,CAAJ,GAEIW,eAFJ,CAEc3K,SAAA,CAAU+J,KAAV,CAAiBC,KAAjB,CAAwBC,WAAxB,CAAqC,IAAA/H,aAArC,CAFd,CALJ,GAYIyI,eAGA,CAHU3K,SAAA,CAAU+J,KAAV,CAAiBC,KAAjB,CAAwBC,WAAxB,CAAqC,IAAA/H,aAArC,CAGV,CAAI,IAAAiI,WAAA,CAAgBJ,KAAhB,CAAuBC,KAAvB,CAAJ,GAEIY,eAFJ,CAEc7K,SAAA,CAAUgK,KAAV,CAAiBC,KAAjB,CAAwBC,WAAxB,CAAqC,IAAA/H,aAArC,CAFd,CAfJ,CAuBA,IAFI6I,eAEJ,CAFcH,eAEd,EAFyBD,eAEzB,CAEQV,WAAJ,GAAoBF,KAAAiB,UAApB,EAAuChB,KAAAgB,UAAvC,EAEI,IAAA3E,KAAA,CAAU,SAAV,CAAqB0D,KAAA1B,WAArB,CAAuC2B,KAAA3B,WAAvC,CAAyD0B,KAAzD,CAAgEC,KAAhE,CAFJ,EAMID,KAAAhC,WAAA,EAGA;AAFAiC,KAAAjC,WAAA,EAEA,EAAIgC,KAAAkB,UAAJ,EAAuBjB,KAAAiB,UAAvB,GAEI,IAAA5E,KAAA,CAAU,SAAV,CAAqB0D,KAAA1B,WAArB,CAAuC2B,KAAA3B,WAAvC,CAAyD0B,KAAzD,CAAgEC,KAAhE,CAXR,CAgBJ,OAAOe,gBA/FX,CA1rCkB,CA2yClBV,eAAgBA,QAAS,CAACN,KAAD,CAAQC,KAAR,CAAeC,WAAf,CAA4BiB,IAA5B,CACzB,CAEI3L,WAAA,CAAYwK,KAAZ,CAAmBC,KAAnB,CAA0B,CAAA,CAA1B,CAAiCkB,IAAjC,CACA1L,YAAA,CAAYuK,KAAZ,CAAmBC,KAAnB,CAA0B,CAAA,CAA1B,CAAiCkB,IAAjC,CAKIC,KAAAA,CAAiBN,IAAAO,MAAA,CAFZpB,KAAAS,OAAAjF,EAEY,CAFKuE,KAAAU,OAAAjF,EAEL,CAHZwE,KAAAS,OAAAlF,EAGY,CAHKwE,KAAAU,OAAAlF,EAGL,CAErB,KAAI8F,QAAU,CAEd,IAAItB,KAAAK,SAAJ,GAAuBJ,KAAAI,SAAvB,CACA,CAEW,IAAA,gCAACJ,KAAAI,SAAD,CAAmBL,KAAAuB,SAAA/F,EAAnB,CAAsCyE,KAAAsB,SAAA/F,EAAtC,CACA;AAACyE,KAAAI,SAAD,CAAmBL,KAAAuB,SAAA9F,EAAnB,CAAsCwE,KAAAsB,SAAA9F,EADtC,CAEI,oCAACwE,KAAAI,SAAD,CAAmBL,KAAApI,MAAnB,CAAiCqI,KAAArI,MAFrC,CAGK,qCAACqI,KAAAI,SAAD,CAAmBL,KAAAQ,OAAnB,CAAkCP,KAAAO,OAHvC,CAOA,gCAACR,KAAAK,SAAD,CAAmBL,KAAAU,OAAAlF,EAAnB,CAAoCyE,KAAAS,OAAAlF,EAPpC,CAQA,gCAACwE,KAAAK,SAAD,CAAmBL,KAAAU,OAAAjF,EAAnB,CAAoCwE,KAAAS,OAAAjF,EARpC,CASK,qCAACuE,KAAAK,SAAD,CAAmBL,KAAAwB,UAAnB,CAAqCvB,KAAAuB,UAG7C/F,gCAAJ,CAAeA,+BAAf;AAEQD,+BAAJ,CAAeA,+BAAf,CAEI8F,OAFJ,CAEcnM,eAAA,CAAgBqG,+BAAhB,CAA0BC,+BAA1B,CAAoCD,+BAApC,CAA4CC,+BAA5C,CAFd,CAEoEgG,oCAFpE,CAISjG,+BAJT,CAIoB5D,mCAJpB,GAMI0J,OANJ,CAMcnM,eAAA,CAAgBqG,+BAAhB,CAA0BC,+BAA1B,CAAoC7D,mCAApC,CAAgD6D,+BAAhD,CANd,CAMwEgG,oCANxE,CAFJ;AAWShG,+BAXT,CAWoB+E,oCAXpB,GAaQhF,+BAAJ,CAAeA,+BAAf,CAEI8F,OAFJ,CAEcnM,eAAA,CAAgBqG,+BAAhB,CAA0BC,+BAA1B,CAAoCD,+BAApC,CAA4CgF,oCAA5C,CAFd,CAEyEiB,oCAFzE,CAISjG,+BAJT,CAIoB5D,mCAJpB,GAMI0J,OANJ,CAMcnM,eAAA,CAAgBqG,+BAAhB,CAA0BC,+BAA1B,CAAoC7D,mCAApC;AAAgD4I,oCAAhD,CANd,CAM6EiB,oCAN7E,CAbJ,CAuBAH,QAAA,EAAW,EArCf,CADA,IA0CIA,QAAA,CAAWtB,KAAAwB,UAAX,CAA6BvB,KAAAuB,UAA7B,CAAgDrM,eAAA,CAAgB6K,KAAAU,OAAAlF,EAAhB,CAAgCwE,KAAAU,OAAAjF,EAAhC,CAAgDwE,KAAAS,OAAAlF,EAAhD,CAAgEyE,KAAAS,OAAAjF,EAAhE,CAIpD,IAAIyE,WAAJ,EAA+B,CAA/B,GAAmBoB,OAAnB,EAAqCtB,KAAA0B,UAArC,EAAwDzB,KAAAyB,UAAxD,EAA4E1B,KAAA2B,gBAA5E,EAAqG1B,KAAA0B,gBAArG,CAQI,MANgB,EAMR,GANJL,OAMI,GANctB,KAAAiB,UAMd,EANiChB,KAAAgB,UAMjC,GAJJ,IAAA3E,KAAA,CAAU,SAAV,CAAqB0D,KAAA1B,WAArB,CAAuC2B,KAAA3B,WAAvC,CAAyD0B,KAAzD,CAAgEC,KAAhE,CAII,CAAY,CAAZ,GAAAqB,OAMRM,YAAAA,CAAO5B,KAAArB,SAAAnD,EACPqG,gCAAAA;AAAO7B,KAAArB,SAAAlD,EACPqG,qCAAAA,CAAS9B,KAAA+B,KAETC,gCAAAA,CAAO/B,KAAAtB,SAAAnD,EACPyG,oCAAAA,CAAOhC,KAAAtB,SAAAlD,EACX,KAAIyG,OAASjC,KAAA8B,KAAb,CAGO,gCAAAH,WAAA,CAAOd,IAAAqB,IAAA,CAASf,IAAT,CAAP,CAAkCS,+BAAlC,CAAyCf,IAAAsB,IAAA,CAAShB,IAAT,CACzC,qCAAA,CAAAQ,WAAA,CAAOd,IAAAsB,IAAA,CAAShB,IAAT,CAAP,CAAkCS,+BAAlC,CAAyCf,IAAAqB,IAAA,CAASf,IAAT,CAIzC,KAAA,gCAAAY,+BAAA,CAAOlB,IAAAqB,IAAA,CAASf,IAAT,CAAP,CAAkCa,mCAAlC;AAAyCnB,IAAAsB,IAAA,CAAShB,IAAT,CACzC,gCAAA,CAAAY,+BAAA,CAAOlB,IAAAsB,IAAA,CAAShB,IAAT,CAAP,CAAkCa,mCAAlC,CAAyCnB,IAAAqB,IAAA,CAASf,IAAT,CAI5CiB,gCAAAA,GAAaP,oCAAbO,CAAsBH,MAAtBG,EAAgC7G,+BAAhC6G,CAAuC,CAAvCA,CAA2CH,MAA3CG,CAAoD7G,+BAApD6G,GAA6DP,oCAA7DO,CAAsEH,MAAtEG,CACAC,qCAAAA,EAAY,CAAZA,CAAgBR,oCAAhBQ,CAAyB9G,+BAAzB8G,EAAiCJ,MAAjCI,CAA0CR,oCAA1CQ,EAAoD9G,+BAApD8G;CAA6DR,oCAA7DQ,CAAsEJ,MAAtEI,CAGCtC,MAAA0B,UAAL,GAEI1B,KAAArB,SAAAnD,EAKA,EALoB6G,+BAKpB,CAL+BvB,IAAAqB,IAAA,CAASf,IAAT,CAK/B,CAL0D3F,oCAK1D,CALiEqF,IAAAsB,IAAA,CAAShB,IAAT,CAKjE,EAL6FpB,KAAAuC,OAAA/G,EAK7F,CAJAwE,KAAArB,SAAAlD,EAIA,EAJoBA,oCAIpB,CAJ2BqF,IAAAqB,IAAA,CAASf,IAAT,CAI3B,CAJsDiB,+BAItD,CAJiEvB,IAAAsB,IAAA,CAAShB,IAAT,CAIjE,EAJ6FpB,KAAAuC,OAAA9G,EAI7F,CADAmG,WACA,CADO5B,KAAArB,SAAAnD,EACP,CAAAqG,+BAAA,CAAO7B,KAAArB,SAAAlD,EAPX,CAUKwE,MAAAyB,UAAL,GAEIzB,KAAAtB,SAAAnD,EAKA,EALoB8G,oCAKpB,CAL+BxB,IAAAqB,IAAA,CAASf,IAAT,CAK/B,CAL0D3F,+BAK1D;AALiEqF,IAAAsB,IAAA,CAAShB,IAAT,CAKjE,EAL6FnB,KAAAsC,OAAA/G,EAK7F,CAJAyE,KAAAtB,SAAAlD,EAIA,EAJoBA,+BAIpB,CAJ2BqF,IAAAqB,IAAA,CAASf,IAAT,CAI3B,CAJsDkB,oCAItD,CAJiExB,IAAAsB,IAAA,CAAShB,IAAT,CAIjE,EAJ6FnB,KAAAsC,OAAA9G,EAI7F,CADAuG,+BACA,CADO/B,KAAAtB,SAAAnD,EACP,CAAAyG,mCAAA,CAAOhC,KAAAtB,SAAAlD,EAPX,CAcIqF,KAAAC,IAAA,CAASK,IAAT,CAAJ,CAA+BN,IAAA0B,GAA/B,CAAyC,CAAzC,CAEgB,CAAZ,CAAKZ,WAAL,EAAkB,CAAC5B,KAAA0B,UAAnB,EAAuCM,+BAAvC,CAA8CJ,WAA9C,CAEI5B,KAAArB,SAAAnD,EAFJ,EAEwB,EAFxB,CAIiB,CAAZ,CAAKwG,+BAAL,EAAkB,CAAC/B,KAAAyB,UAAnB,EAAuCE,WAAvC,CAA8CI,+BAA9C,CAED/B,KAAAtB,SAAAnD,EAFC;AAEmB,EAFnB,CAIY,CAAZ,CAAKqG,+BAAL,EAAkB,CAAC7B,KAAA0B,UAAnB,EAAuCO,mCAAvC,CAA8CJ,+BAA9C,CAED7B,KAAArB,SAAAlD,EAFC,EAEmB,EAFnB,CAIY,CAJZ,CAIKwG,mCAJL,EAIkB,CAAChC,KAAAyB,UAJnB,EAIuCG,+BAJvC,CAI8CI,mCAJ9C,GAMDhC,KAAAtB,SAAAlD,EANC,EAMmB,EANnB,CAVT,CAmBSqF,IAAAC,IAAA,CAASK,IAAT,CAnBT,CAmBoCN,IAAA0B,GAnBpC,CAmB8C,CAnB9C,GAqBgB,CAAZ,CAAKZ,WAAL,EAAkB,CAAC5B,KAAA0B,UAAnB,EAAuCM,+BAAvC,CAA8CJ,WAA9C,CAEI5B,KAAArB,SAAAnD,EAFJ,EAEwB,EAFxB,CAIiB,CAAZ,CAAKwG,+BAAL,EAAkB,CAAC/B,KAAAyB,UAAnB,EAAuCE,WAAvC,CAA8CI,+BAA9C;AAED/B,KAAAtB,SAAAnD,EAFC,EAEmB,EAFnB,CAIY,CAAZ,CAAKqG,+BAAL,EAAkB,CAAC7B,KAAA0B,UAAnB,EAAuCO,mCAAvC,CAA8CJ,+BAA9C,CAED7B,KAAArB,SAAAlD,EAFC,EAEmB,EAFnB,CAIY,CAJZ,CAIKwG,mCAJL,EAIkB,CAAChC,KAAAyB,UAJnB,EAIuCE,WAJvC,CAI8CK,mCAJ9C,GAMDhC,KAAAtB,SAAAlD,EANC,EAMmB,EANnB,CA7BT,CAuCI4B,YAAAA,CAAQ,IAAAtF,WAEPiI,MAAA0B,UAAL,GAEI1B,KAAAxE,EACA,EADYwE,KAAArB,SAAAnD,EACZ,CAD+B6B,WAC/B,CADwCiE,OACxC,CADkDR,IAAAqB,IAAA,CAASf,IAAT,CAClD,CAAApB,KAAAvE,EAAA,EAAYuE,KAAArB,SAAAlD,EAAZ,CAA+B4B,WAA/B,CAAwCiE,OAAxC,CAAkDR,IAAAsB,IAAA,CAAShB,IAAT,CAHtD,CAMKnB,MAAAyB,UAAL,GAEIzB,KAAAzE,EACA,EADYyE,KAAAtB,SAAAnD,EACZ;AAD+B6B,WAC/B,CADwCiE,OACxC,CADkDR,IAAAqB,IAAA,CAASf,IAAT,CAClD,CAAAnB,KAAAxE,EAAA,EAAYwE,KAAAtB,SAAAlD,EAAZ,CAA+B4B,WAA/B,CAAwCiE,OAAxC,CAAkDR,IAAAsB,IAAA,CAAShB,IAAT,CAHtD,CAMA,EAAIpB,KAAAkB,UAAJ,EAAuBjB,KAAAiB,UAAvB,GAEI,IAAA5E,KAAA,CAAU,SAAV,CAAqB0D,KAAA1B,WAArB,CAAuC2B,KAAA3B,WAAvC,CAAyD0B,KAAzD,CAAgEC,KAAhE,CAIJD,MAAAhC,WAAA,EACAiC,MAAAjC,WAAA,EAEA,OAAO,CAAA,CArLX,CA5yCkB,CA++ClBoC,WAAYA,QAAS,CAACJ,KAAD,CAAQC,KAAR,CACrB,CACI,MAAID,MAAJ,GAAcC,KAAd,CAEW,CAAA,CAFX,CAKKD,KAAAK,SAAL,EAAwBJ,KAAAI,SAAxB,CAUSL,KAAAK,SAAJ,CAEGJ,KAAAI,SAAJ,CAGWlL,eAAA,CAAgB6K,KAAAU,OAAAlF,EAAhB,CAAgCwE,KAAAU,OAAAjF,EAAhC,CAAgDwE,KAAAS,OAAAlF,EAAhD,CAAgEyE,KAAAS,OAAAjF,EAAhE,CAHX,EAG+FuE,KAAAwB,UAH/F,CAGiHvB,KAAAuB,UAHjH,CAQW,IAAAiB,qBAAA,CAA0BzC,KAA1B;AAAiCC,KAAjC,CAVV,CAgBM,IAAAwC,qBAAA,CAA0BxC,KAA1B,CAAiCD,KAAjC,CA1BX,CAGW,EACHA,KAAApI,MADG,EACYqI,KAAAsB,SAAA/F,EADZ,EAEHwE,KAAAQ,OAFG,EAEaP,KAAAsB,SAAA9F,EAFb,EAGHuE,KAAAuB,SAAA/F,EAHG,EAGiByE,KAAArI,MAHjB,EAIHoI,KAAAuB,SAAA9F,EAJG,EAIiBwE,KAAAO,OAJjB,CATf,CAh/CkB,CA+hDlBiC,qBAAsBA,QAAS,CAAChC,MAAD,CAAS7F,IAAT,CAC/B,CACI,IAAIY,EAAIzG,KAAA,CAAM0L,MAAAC,OAAAlF,EAAN,CAAuBZ,IAAAjD,KAAvB,CAAkCiD,IAAAhD,MAAlC,CACJ6D,KAAAA,CAAI1G,KAAA,CAAM0L,MAAAC,OAAAjF,EAAN,CAAuBb,IAAA8H,IAAvB,CAAiC9H,IAAA4F,OAAjC,CAKR,QAHUC,MAAAC,OAAAlF,EAGV,CAH4BA,CAG5B,GAHkCiF,MAAAC,OAAAlF,EAGlC,CAHoDA,CAGpD,GAFUiF,MAAAC,OAAAjF,EAEV,CAF4BA,IAE5B,GAFkCgF,MAAAC,OAAAjF,EAElC,CAFoDA,IAEpD,GAAqBgF,MAAAe,UAArB,CAAwCf,MAAAe,UAP5C,CAhiDkB,CAwjDlBF,QAASA,QAAS,CAAC7E,OAAD,CAAUC,OAAV,CAAmBiG,eAAnB,CAAoC/F,eAApC;AAAqDC,eAArD,CAClB,CAC4B9C,IAAAA,EAAxB,GAAI4I,eAAJ,GAAqCA,eAArC,CAAuD,IAAvD,CACwB5I,KAAAA,EAAxB,GAAI6C,eAAJ,GAAqCA,eAArC,CAAuD,IAAvD,CACwB7C,KAAAA,EAAxB,GAAI8C,eAAJ,GAAqCA,eAArC,CAAuD8F,eAAvD,CAEA,OAAO,KAAAC,eAAA,CAAoBnG,OAApB,CAA6BC,OAA7B,CAAsCiG,eAAtC,CAAuD/F,eAAvD,CAAwEC,eAAxE,CAAyF,CAAA,CAAzF,CALX,CAzjDkB,CA8lDlBgG,QAASA,QAAS,CAACpG,OAAD,CAAUC,OAAV,CAAmBC,eAAnB,CAAoCC,eAApC,CAAqDC,eAArD,CAClB,CAC4B9C,IAAAA,EAAxB,GAAI4C,eAAJ,GAAqCA,eAArC,CAAuD,IAAvD,CACwB5C,KAAAA,EAAxB,GAAI6C,eAAJ,GAAqCA,eAArC,CAAuD,IAAvD,CACwB7C,KAAAA,EAAxB,GAAI8C,eAAJ,GAAqCA,eAArC,CAAuDF,eAAvD,CAEA;MAAO,KAAAiG,eAAA,CAAoBnG,OAApB,CAA6BC,OAA7B,CAAsCC,eAAtC,CAAuDC,eAAvD,CAAwEC,eAAxE,CAAyF,CAAA,CAAzF,CALX,CA/lDkB,CAsnDlB+F,eAAgBA,QAAS,CAACnG,OAAD,CAAUC,OAAV,CAAmBC,eAAnB,CAAoCC,eAApC,CAAqDC,eAArD,CAAsEqD,WAAtE,CACzB,CAGQzD,OAAAnC,SAAJ,EAAgDP,IAAAA,EAAhD,GAAwB0C,OAAA1B,YAAxB,GAEI0B,OAFJ,CAEcA,OAAAlC,SAAAoD,QAFd,CAKIjB,QAAJ,EAAeA,OAAApC,SAAf,EAA2DP,IAAAA,EAA3D,GAAmC2C,OAAA3B,YAAnC,GAEI2B,OAFJ,CAEcA,OAAAnC,SAAAoD,QAFd,CAKImF,KAAAA,EAAiB7I,KAAAC,QAAA,CAAcuC,OAAd,CACrB,KAAIsG,eAAiB9I,KAAAC,QAAA,CAAcwC,OAAd,CAErB,KAAAnE,OAAA,CAAc,CAEd,IAAKuK,CAAL,EAAwBC,cAAxB,CAKK,GAAI,CAACD,CAAL,EAAuBC,cAAvB,CAGD,IAAK5I,CAAL;AAAS,CAAT,CAAYA,CAAZ,CAAgBuC,OAAAtC,OAAhB,CAAgCD,CAAA,EAAhC,CAEI,IAAA6I,eAAA,CAAoBvG,OAApB,CAA6BC,OAAA,CAAQvC,CAAR,CAA7B,CAAyCwC,eAAzC,CAA0DC,eAA1D,CAA2EC,eAA3E,CAA4FqD,WAA5F,CALH,KAQA,IAAI4C,CAAJ,EAAsB,CAACC,cAAvB,CAGD,IAAK5I,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBsC,OAAArC,OAAhB,CAAgCD,CAAA,EAAhC,CAEI,IAAA6I,eAAA,CAAoBvG,OAAA,CAAQtC,CAAR,CAApB,CAAgCuC,OAAhC,CAAyCC,eAAzC,CAA0DC,eAA1D,CAA2EC,eAA3E,CAA4FqD,WAA5F,CALH,KAWD,KAAK/F,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBsC,OAAArC,OAAhB,CAAgCD,CAAA,EAAhC,CAEI,IAAS8I,cAAT,CAAa,CAAb,CAAgBA,cAAhB,CAAoBvG,OAAAtC,OAApB,CAAoC6I,cAAA,EAApC,CAEI,IAAAD,eAAA,CAAoBvG,OAAA,CAAQtC,CAAR,CAApB,CAAgCuC,OAAA,CAAQuG,cAAR,CAAhC,CAA4CtG,eAA5C,CAA6DC,eAA7D,CAA8EC,eAA9E,CAA+FqD,WAA/F,CA5BZ,KAGI,KAAA8C,eAAA,CAAoBvG,OAApB;AAA6BC,OAA7B,CAAsCC,eAAtC,CAAuDC,eAAvD,CAAwEC,eAAxE,CAAyFqD,WAAzF,CA8BJ,OAAsB,EAAtB,CAAQ,IAAA3H,OAnDZ,CAvnDkB,CA4rDlByK,eAAgBA,QAAS,CAACvG,OAAD,CAAUC,OAAV,CAAmBC,eAAnB,CAAoCC,eAApC,CAAqDC,eAArD,CAAsEqD,WAAtE,CACzB,CAGI,GAAgBnG,IAAAA,EAAhB,GAAI2C,OAAJ,EAA6BD,OAAAnC,SAA7B,CAEI,MAAO,KAAA4I,oBAAA,CAAyBzG,OAAzB,CAAkCA,OAAlC,CAA2CE,eAA3C,CAA4DC,eAA5D,CAA6EC,eAA7E,CAA8FqD,WAA9F,CAIX,IAAI,CAACzD,OAAL,EAAgB,CAACC,OAAjB,CAEI,MAAO,CAAA,CAIX,IAAID,OAAA7B,KAAJ,CACA,CACI,GAAI8B,OAAA9B,KAAJ,CAEI,MAAO,KAAAuI,sBAAA,CAA2B1G,OAA3B,CAAoCC,OAApC,CAA6CC,eAA7C,CAA8DC,eAA9D,CAA+EC,eAA/E;AAAgGqD,WAAhG,CAEN,IAAIxD,OAAApC,SAAJ,CAED,MAAO,KAAA8I,qBAAA,CAA0B3G,OAA1B,CAAmCC,OAAnC,CAA4CC,eAA5C,CAA6DC,eAA7D,CAA8EC,eAA9E,CAA+FqD,WAA/F,CAEN,IAAIxD,OAAA2G,UAAJ,CAED,MAAO,KAAAC,4BAAA,CAAiC7G,OAAjC,CAA0CC,OAA1C,CAAmDC,eAAnD,CAAoEC,eAApE,CAAqFC,eAArF,CAAsGqD,WAAtG,CAXf,CADA,IAiBK,IAAIzD,OAAAnC,SAAJ,CACL,CACI,GAAIoC,OAAA9B,KAAJ,CAEI,MAAO,KAAAwI,qBAAA,CAA0B1G,OAA1B,CAAmCD,OAAnC,CAA4CE,eAA5C,CAA6DC,eAA7D,CAA8EC,eAA9E,CAA+FqD,WAA/F,CAEN,IAAIxD,OAAApC,SAAJ,CAED,MAAO,KAAA4I,oBAAA,CAAyBzG,OAAzB,CAAkCC,OAAlC;AAA2CC,eAA3C,CAA4DC,eAA5D,CAA6EC,eAA7E,CAA8FqD,WAA9F,CAEN,IAAIxD,OAAA2G,UAAJ,CAED,MAAO,KAAAE,2BAAA,CAAgC9G,OAAhC,CAAyCC,OAAzC,CAAkDC,eAAlD,CAAmEC,eAAnE,CAAoFC,eAApF,CAAqGqD,WAArG,CAXf,CADK,IAiBA,IAAIzD,OAAA4G,UAAJ,CACL,CACI,GAAI3G,OAAA9B,KAAJ,CAEI,MAAO,KAAA0I,4BAAA,CAAiC5G,OAAjC,CAA0CD,OAA1C,CAAmDE,eAAnD,CAAoEC,eAApE,CAAqFC,eAArF,CAAsGqD,WAAtG,CAEN,IAAIxD,OAAApC,SAAJ,CAED,MAAO,KAAAiJ,2BAAA,CAAgC7G,OAAhC,CAAyCD,OAAzC,CAAkDE,eAAlD,CAAmEC,eAAnE,CAAoFC,eAApF,CAAqGqD,WAArG,CAPf,CAlDJ,CA7rDkB,CA0wDlBiD,sBAAuBA,QAAS,CAACK,OAAD;AAAUC,OAAV,CAAmB9G,eAAnB,CAAoCC,eAApC,CAAqDC,eAArD,CAAsEqD,WAAtE,CAChC,CACI,GAAI,CAACsD,OAAA5I,KAAL,EAAqB,CAAC6I,OAAA7I,KAAtB,CAEI,MAAO,CAAA,CAGP,KAAAmF,SAAA,CAAcyD,OAAA5I,KAAd,CAA4B6I,OAAA7I,KAA5B,CAA0CgC,eAA1C,CAA2DC,eAA3D,CAA4EqD,WAA5E,CAAJ,GAEQvD,eAKJ,EAHIA,eAAA9F,KAAA,CAAqBgG,eAArB,CAAsC2G,OAAtC,CAA+CC,OAA/C,CAGJ,CAAA,IAAAlL,OAAA,EAPJ,CAUA,OAAO,CAAA,CAhBX,CA3wDkB,CA6yDlB6K,qBAAsBA,QAAS,CAACM,MAAD,CAASC,KAAT,CAAgBhH,eAAhB,CAAiCC,eAAjC,CAAkDC,eAAlD,CAAmEqD,WAAnE,CAC/B,CACI,IAAI0D,MAAQF,MAAA9I,KAEZ,IAAqB,CAArB,GAAI+I,KAAAvJ,OAAJ,EAA2BwJ,KAA3B,EAAqCA,KAAAhK,OAArC,CAWA,GAAI,IAAAX,QAAJ,CACA,CACQ4K,MAAAA,CAAS,IAAAzK,WAEbyK,OAAAxK,KAAA;AAAcuK,KAAAjM,KACdkM,OAAAvK,KAAA,CAAcsK,KAAAlB,IACdmB,OAAAtK,KAAA,CAAcqK,KAAAhM,MACdiM,OAAArK,KAAA,CAAcoK,KAAApD,OAEd,KAAIsD,QAAWH,KAAA5I,YAAD,GAAuB7F,KAAA8E,aAAvB,CAA6C,IAAAd,KAAA6K,OAAA,CAAiBF,MAAjB,CAA7C,CAAwE,IAAA1K,WAAA4K,OAAA,CAAuBF,MAAvB,CAEtF,KAAAjG,IAAMkG,OAAA1J,OAEN,KAAKD,MAAL,CAAS,CAAT,CAAYA,MAAZ,CAAgByD,GAAhB,CAAqBzD,MAAA,EAArB,CACA,CACI,IAAA6J,MAAQF,OAAA,CAAQ3J,MAAR,CAEJyJ,MAAJ,GAAcI,KAAd,EAAwBL,KAAAM,SAAA,CAAeD,KAAA1F,WAAf,CAAxB,EAMI,IAAAyB,SAAA,CAAc6D,KAAd,CAAqBI,KAArB,CAA4BpH,eAA5B,CAA6CC,eAA7C,CAA8DqD,WAA9D,CANJ,GAQQvD,eAKJ,EAHIA,eAAA9F,KAAA,CAAqBgG,eAArB,CAAsC+G,KAAAtF,WAAtC,CAAwD0F,KAAA1F,WAAxD,CAGJ,CAAA,IAAA/F,OAAA,EAbJ,CAHJ,CAbJ,CADA,IAyCI,KALIgC,OAKC;AALUoJ,KAAAnJ,YAAA,EAKV,CAJD0J,KAIC,CAJWP,KAAApJ,SAAAoD,QAAAwG,QAAA,CAA+BT,MAA/B,CAIX,CAFL9F,GAEK,CAFCrD,OAAAH,OAED,CAAAD,MAAA,CAAI,CAAT,CAAYA,MAAZ,CAAgByD,GAAhB,CAAqBzD,MAAA,EAArB,CAII,CAFA6J,KAEA,CAFQzJ,OAAA,CAASJ,MAAT,CAAAS,KAER,GAAcT,MAAd,GAAoB+J,KAApB,EAAkCF,KAAApK,OAAlC,EAKI,IAAAmG,SAAA,CAAc6D,KAAd,CAAqBI,KAArB,CAA4BpH,eAA5B,CAA6CC,eAA7C,CAA8DqD,WAA9D,CALJ,GAOQvD,eAKJ,EAHIA,eAAA9F,KAAA,CAAqBgG,eAArB,CAAsC+G,KAAAtF,WAAtC,CAAwD0F,KAAA1F,WAAxD,CAGJ,CAAA,IAAA/F,OAAA,EAZJ,CA3DZ,CA9yDkB,CA04DlBgL,2BAA4BA,QAAS,CAACI,KAAD,CAAQS,YAAR,CAAsBzH,eAAtB,CAAuCC,eAAvC,CAAwDC,eAAxD,CAAyEqD,WAAzE,CACrC,CACQ3F,KAAAA,CAAWoJ,KAAAnJ,YAAA,EAEf,IAAwB,CAAxB,GAAID,KAAAH,OAAJ,CAEI,MAAO,CAAA,CAKX;IAFA,IAAIiK,WAAa,CAAA,CAAjB,CAESlK,EAAI,CAAb,CAAgBA,CAAhB,CAAoBI,KAAAH,OAApB,CAAqCD,CAAA,EAArC,CAEQI,KAAA,CAASJ,CAAT,CAAAS,KAAJ,EAEQ,IAAA0I,4BAAA,CAAiC/I,KAAA,CAASJ,CAAT,CAAjC,CAA8CiK,YAA9C,CAA4DzH,eAA5D,CAA6EC,eAA7E,CAA8FC,eAA9F,CAA+GqD,WAA/G,CAFR,GAIQmE,UAJR,CAIqB,CAAA,CAJrB,CASJ,OAAOA,WArBX,CA34DkB,CAo7DlBf,4BAA6BA,QAAS,CAACI,MAAD,CAASU,YAAT,CAAuBzH,eAAvB,CAAwCC,eAAxC,CAAyDC,eAAzD,CAA0EqD,WAA1E,CACtC,CACI,IAAItF,KAAO8I,MAAA9I,KAEX,IAAI,CAACA,IAAAhB,OAAL,CAEI,MAAO,CAAA,CAGX,KAAI4B,EAAIZ,IAAA2G,SAAA/F,EAAR,CACIC,EAAIb,IAAA2G,SAAA9F,EADR,CAEI6I,EAAI1J,IAAAtD,MAFR,CAGIiN,EAAI3J,IAAArD,OAHR,CAQIiN,UAAYJ,YAAAK,MAEhB,IAAID,SAAAE,UAAJ,CAA0BF,SAAAG,cAA1B,CACA,CAEI,IAAIC;CAASJ,SAAAE,UAATE,CAA+BJ,SAAAG,cAA/BC,EAA0DR,YAAAS,OAC9DrJ,EAAA,EAAKoJ,KACLN,EAAA,EAAKM,KAJT,CAOIJ,SAAAM,WAAJ,CAA2BN,SAAAO,eAA3B,GAIIR,CAJJ,GAGiBC,SAAAM,WAHjB,CAGwCN,SAAAO,eAHxC,EAGoEX,YAAAY,OAHpE,CAOIC,EAAAA,CAAUb,YAAAc,sBAAA,CAAmC1J,CAAnC,CAAsCC,CAAtC,CAAyC6I,CAAzC,CAA4CC,CAA5C,CAEd,IAAuB,CAAvB,GAAIU,CAAA7K,OAAJ,CAEI,MAAO,CAAA,CAIP+K,EAAAA,CAAgB,CAAExN,KAAM,CAAR,CAAWC,MAAO,CAAlB,CAAqB8K,IAAK,CAA1B,CAA6BlC,OAAQ,CAArC,CAEpB,KAASrG,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoB8K,CAAA7K,OAApB,CAAoCD,CAAA,EAApC,CAEIiL,CAcA,CAdOH,CAAA,CAAQ9K,CAAR,CAcP,CAbAgL,CAAAxN,KAaA,CAbqByM,YAAAiB,aAAA,CAA0BD,CAAA5J,EAA1B,CAarB,CAZA2J,CAAAzC,IAYA,CAZoB0B,YAAAkB,aAAA,CAA0BF,CAAA3J,EAA1B,CAYpB,CARI2J,CAAAG,WAQJ,GARwBH,CAAA7N,OAQxB,GANI4N,CAAAzC,IAMJ,GAN0B0C,CAAA7N,OAM1B,CANwC6N,CAAAG,WAMxC,EAN2DnB,YAAAY,OAM3D,EAHAG,CAAAvN,MAGA,CAHsBuN,CAAAxN,KAGtB;AAH2CyN,CAAA9N,MAG3C,CAHwD8M,YAAAS,OAGxD,CAFAM,CAAA3E,OAEA,CAFuB2E,CAAAzC,IAEvB,CAF2C0C,CAAA7N,OAE3C,CAFyD6M,YAAAY,OAEzD,CAAI5O,kBAAA,CAAmB+O,CAAnB,CAAkCvK,IAAlC,CAAJ,GACQ,CAACgC,eADT,EAC4BA,eAAA/F,KAAA,CAAqBgG,eAArB,CAAsC6G,MAAtC,CAA8C0B,CAA9C,CAD5B,GAEOxP,oBAAA,CAAqBwP,CAArB,CAA2B1B,MAA3B,CAFP,GAGQxD,WAHR,EAGuBnK,YAAA,CAAaoE,CAAb,CAAgBS,IAAhB,CAAsBwK,CAAtB,CAA4BD,CAA5B,CAA2Cf,YAA3C,CAAyD,IAAAhM,UAAzD,CAHvB,IAKI,IAAAG,OAAA,EAiBA,CAfIoE,eAeJ,EAbIA,eAAA9F,KAAA,CAAqBgG,eAArB,CAAsC6G,MAAtC,CAA8C0B,CAA9C,CAaJ,CAVIlF,WAAJ,EAAmBtF,IAAAqG,UAAnB,CAEIyC,MAAApH,KAAA,CAAY,SAAZ,CAAuB1B,IAAA0D,WAAvB,CAAwC8G,CAAxC,CAA8CxK,IAA9C,CAAoD,IAApD,CAFJ,CAISA,IAAAsG,UAJT,EAMIwC,MAAApH,KAAA,CAAY,SAAZ,CAAuB1B,IAAA0D,WAAvB,CAAwC8G,CAAxC,CAA8CxK,IAA9C,CAAoD,IAApD,CAIJ,CAAAA,IAAAoD,WAAA,EAtBJ,CA3DR,CAr7DkB;AA0hElBkF,oBAAqBA,QAAS,CAACsC,MAAD,CAASC,MAAT,CAAiB9I,eAAjB,CAAkCC,eAAlC,CAAmDC,eAAnD,CAAoEqD,WAApE,CAC9B,CACI,GAAsB,CAAtB,GAAIsF,MAAApL,OAAJ,EAA6C,CAA7C,GAA2BqL,MAAArL,OAA3B,CAAA,CAKIG,MAAAA,CAAWiL,MAAAhL,YAAA,EAEf,KAAK,IAAIL,EAAI,CAAb,CAAgBA,CAAhB,CAAoBI,MAAAH,OAApB,CAAqCD,CAAA,EAArC,CAEI,IAAAiJ,qBAAA,CAA0B7I,MAAA,CAASJ,CAAT,CAA1B,CAAuCsL,MAAvC,CAA+C9I,eAA/C,CAAgEC,eAAhE,CAAiFC,eAAjF,CAAkGqD,WAAlG,CATJ,CADJ,CA3hEkB,CAojElBwF,KAAMA,QAAS,CAAC7L,MAAD,CAAS8L,OAAT,CACf,CACQ9L,MAAAe,KAAJ,CAEI,IAAAgL,WAAA,CAAgB/L,MAAhB,CAAwB8L,OAAxB,CAFJ,CAIS9L,MAAAW,YAAJ,CAED,IAAAqL,UAAA,CAAehM,MAAAW,YAAA,EAAf,CAAqCmL,OAArC,CAFC,CAII1L,KAAAC,QAAA,CAAcL,MAAd,CAAJ,CAED,IAAAgM,UAAA,CAAehM,MAAf,CAAuB8L,OAAvB,CAFC;AAMD,IAAAC,WAAA,CAAgB/L,MAAhB,CAAwB8L,OAAxB,CAfR,CArjEkB,CAklElBE,UAAWA,QAAS,CAACC,OAAD,CAAUH,OAAV,CACpB,CACI,IAAK,IAAIxL,EAAI,CAAb,CAAgBA,CAAhB,CAAoB2L,OAAA1L,OAApB,CAAoCD,CAAA,EAApC,CAEI,IAAAyL,WAAA,CAAgBE,OAAA,CAAQ3L,CAAR,CAAhB,CAA4BwL,OAA5B,CAHR,CAnlEkB,CAmmElBC,WAAYA,QAAS,CAAC/L,MAAD,CAAS8L,OAAT,CACrB,CACoB5L,IAAAA,EAAhB,GAAI4L,OAAJ,GAA6BA,OAA7B,CAAuC,CAAvC,CAEA9L,OAAA2B,EAAA,CAAWjF,IAAA,CAAKsD,MAAA2B,EAAL,CAAe,IAAArE,OAAAQ,KAAf,CAAkCgO,OAAlC,CAA2C,IAAAxO,OAAAS,MAA3C,CAA+D+N,OAA/D,CACX9L,OAAA4B,EAAA,CAAWlF,IAAA,CAAKsD,MAAA4B,EAAL,CAAe,IAAAtE,OAAAuL,IAAf,CAAiCiD,OAAjC,CAA0C,IAAAxO,OAAAqJ,OAA1C,CAA+DmF,OAA/D,CAJf,CApmEkB,CAinElBI,SAAUA,QAAS,EACnB,CACI,IAAA7M,KAAA2E,MAAA,EACA,KAAA1E,WAAA0E,MAAA,EACA,KAAA/G,OAAA+G,MAAA,EACA,KAAA9G,aAAA8G,MAAA,EACA,KAAA5G,UAAA+O,QAAA,EAEA,KAAAC,mBAAA,EAPJ,CAlnEkB;AAkoElBD,QAASA,QAAS,EAClB,CACI,IAAAD,SAAA,EAEA,KAAApP,MAAA,CAAa,IAHjB,CAnoEkB,CAAV,CA2oEZ/B,OAAAC,QAAA,CAAiB2B,OAlzE+F;",
"sources":["node_modules/Phaser/src/physics/arcade/World.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$arcade$World\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Body = require('./Body');\r\nvar Clamp = require('../../math/Clamp');\r\nvar Class = require('../../utils/Class');\r\nvar Collider = require('./Collider');\r\nvar CONST = require('./const');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\nvar EventEmitter = require('eventemitter3');\r\nvar FuzzyEqual = require('../../math/fuzzy/Equal');\r\nvar FuzzyGreaterThan = require('../../math/fuzzy/GreaterThan');\r\nvar FuzzyLessThan = require('../../math/fuzzy/LessThan');\r\nvar GetOverlapX = require('./GetOverlapX');\r\nvar GetOverlapY = require('./GetOverlapY');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar ProcessQueue = require('../../structs/ProcessQueue');\r\nvar ProcessTileCallbacks = require('./tilemap/ProcessTileCallbacks');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar RTree = require('../../structs/RTree');\r\nvar SeparateTile = require('./tilemap/SeparateTile');\r\nvar SeparateX = require('./SeparateX');\r\nvar SeparateY = require('./SeparateY');\r\nvar Set = require('../../structs/Set');\r\nvar StaticBody = require('./StaticBody');\r\nvar TileIntersectsBody = require('./tilemap/TileIntersectsBody');\r\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar Wrap = require('../../math/Wrap');\r\n\r\n/**\r\n * @event Phaser.Physics.Arcade.World#pause\r\n */\r\n\r\n/**\r\n * @event Phaser.Physics.Arcade.World#resume\r\n */\r\n\r\n/**\r\n * @event Phaser.Physics.Arcade.World#collide\r\n * @param {Phaser.GameObjects.GameObject} gameObject1\r\n * @param {Phaser.GameObjects.GameObject} gameObject2\r\n * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body1\r\n * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body2\r\n */\r\n\r\n/**\r\n * @event Phaser.Physics.Arcade.World#overlap\r\n * @param {Phaser.GameObjects.GameObject} gameObject1\r\n * @param {Phaser.GameObjects.GameObject} gameObject2\r\n * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body1\r\n * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body2\r\n */\r\n\r\n/**\r\n * @event Phaser.Physics.Arcade.World#worldbounds\r\n * @param {Phaser.Physics.Arcade.Body} body\r\n * @param {boolean} up\r\n * @param {boolean} down\r\n * @param {boolean} left\r\n * @param {boolean} right\r\n */\r\n\r\n/**\r\n * @typedef {object} ArcadeWorldConfig\r\n *\r\n * @property {number} [fps=60] - Sets {@link Phaser.Physics.Arcade.World#fps}.\r\n * @property {number} [timeScale=1] - Sets {@link Phaser.Physics.Arcade.World#timeScale}.\r\n * @property {object} [gravity] - Sets {@link Phaser.Physics.Arcade.World#gravity}.\r\n * @property {number} [gravity.x=0] - The horizontal world gravity value.\r\n * @property {number} [gravity.y=0] - The vertical world gravity value.\r\n * @property {number} [x=0] - Sets {@link Phaser.Physics.Arcade.World#bounds bounds.x}.\r\n * @property {number} [y=0] - Sets {@link Phaser.Physics.Arcade.World#bounds bounds.y}.\r\n * @property {number} [width=0] - Sets {@link Phaser.Physics.Arcade.World#bounds bounds.width}.\r\n * @property {number} [height=0] - Sets {@link Phaser.Physics.Arcade.World#bounds bounds.height}.\r\n * @property {object} [checkCollision] - Sets {@link Phaser.Physics.Arcade.World#checkCollision}.\r\n * @property {boolean} [checkCollision.up=true] - Should bodies collide with the top of the world bounds?\r\n * @property {boolean} [checkCollision.down=true] - Should bodies collide with the bottom of the world bounds?\r\n * @property {boolean} [checkCollision.left=true] - Should bodies collide with the left of the world bounds?\r\n * @property {boolean} [checkCollision.right=true] - Should bodies collide with the right of the world bounds?\r\n * @property {number} [overlapBias=4] - Sets {@link Phaser.Physics.Arcade.World#OVERLAP_BIAS}.\r\n * @property {number} [tileBias=16] - Sets {@link Phaser.Physics.Arcade.World#TILE_BIAS}.\r\n * @property {boolean} [forceX=false] - Sets {@link Phaser.Physics.Arcade.World#forceX}.\r\n * @property {boolean} [isPaused=false] - Sets {@link Phaser.Physics.Arcade.World#isPaused}.\r\n * @property {boolean} [debug=false] - Sets {@link Phaser.Physics.Arcade.World#debug}.\r\n * @property {boolean} [debugShowBody=true] - Sets {@link Phaser.Physics.Arcade.World#defaults debugShowBody}.\r\n * @property {boolean} [debugShowStaticBody=true] - Sets {@link Phaser.Physics.Arcade.World#defaults debugShowStaticBody}.\r\n * @property {boolean} [debugShowVelocity=true] - Sets {@link Phaser.Physics.Arcade.World#defaults debugShowStaticBody}.\r\n * @property {number} [debugBodyColor=0xff00ff] - Sets {@link Phaser.Physics.Arcade.World#defaults debugBodyColor}.\r\n * @property {number} [debugStaticBodyColor=0x0000ff] - Sets {@link Phaser.Physics.Arcade.World#defaults debugStaticBodyColor}.\r\n * @property {number} [debugVelocityColor=0x00ff00] - Sets {@link Phaser.Physics.Arcade.World#defaults debugVelocityColor}.\r\n * @property {number} [maxEntries=16] - Sets {@link Phaser.Physics.Arcade.World#maxEntries}.\r\n * @property {boolean} [useTree=true] - Sets {@link Phaser.Physics.Arcade.World#useTree}.\r\n */\r\n\r\n/**\r\n * @typedef {object} CheckCollisionObject\r\n *\r\n * @property {boolean} up - [description]\r\n * @property {boolean} down - [description]\r\n * @property {boolean} left - [description]\r\n * @property {boolean} right - [description]\r\n */\r\n\r\n/**\r\n * @typedef {object} ArcadeWorldDefaults\r\n *\r\n * @property {boolean} debugShowBody - [description]\r\n * @property {boolean} debugShowStaticBody - [description]\r\n * @property {boolean} debugShowVelocity - [description]\r\n * @property {number} bodyDebugColor - [description]\r\n * @property {number} staticBodyDebugColor - [description]\r\n * @property {number} velocityDebugColor - [description]\r\n */\r\n\r\n/**\r\n * @typedef {object} ArcadeWorldTreeMinMax\r\n *\r\n * @property {number} minX - [description]\r\n * @property {number} minY - [description]\r\n * @property {number} maxX - [description]\r\n * @property {number} maxY - [description]\r\n */\r\n\r\n/**\r\n * An Arcade Physics Collider Type.\r\n *\r\n * @typedef {(\r\n * Phaser.GameObjects.GameObject|\r\n * Phaser.GameObjects.Group|\r\n * Phaser.Physics.Arcade.Sprite|\r\n * Phaser.Physics.Arcade.Image|\r\n * Phaser.Physics.Arcade.StaticGroup|\r\n * Phaser.Physics.Arcade.Group|\r\n * Phaser.Tilemaps.DynamicTilemapLayer|\r\n * Phaser.Tilemaps.StaticTilemapLayer|\r\n * Phaser.GameObjects.GameObject[]|\r\n * Phaser.Physics.Arcade.Sprite[]|\r\n * Phaser.Physics.Arcade.Image[]|\r\n * Phaser.Physics.Arcade.StaticGroup[]|\r\n * Phaser.Physics.Arcade.Group[]|\r\n * Phaser.Tilemaps.DynamicTilemapLayer[]|\r\n * Phaser.Tilemaps.StaticTilemapLayer[]\r\n * )} ArcadeColliderType\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * The Arcade Physics World.\r\n *\r\n * The World is responsible for creating, managing, colliding and updating all of the bodies within it.\r\n *\r\n * An instance of the World belongs to a Phaser.Scene and is accessed via the property `physics.world`.\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this World instance belongs.\r\n * @param {ArcadeWorldConfig} config - An Arcade Physics Configuration object.\r\n */\r\nvar World = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function World (scene, config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Scene this simulation belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Dynamic Bodies in this simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#bodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.Body>}\r\n         * @since 3.0.0\r\n         */\r\n        this.bodies = new Set();\r\n\r\n        /**\r\n         * Static Bodies in this simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#staticBodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.StaticBody>}\r\n         * @since 3.0.0\r\n         */\r\n        this.staticBodies = new Set();\r\n\r\n        /**\r\n         * Static Bodies marked for deletion.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#pendingDestroy\r\n         * @type {Phaser.Structs.Set.<(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)>}\r\n         * @since 3.1.0\r\n         */\r\n        this.pendingDestroy = new Set();\r\n\r\n        /**\r\n         * This simulation's collision processors.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#colliders\r\n         * @type {Phaser.Structs.ProcessQueue.<Phaser.Physics.Arcade.Collider>}\r\n         * @since 3.0.0\r\n         */\r\n        this.colliders = new ProcessQueue();\r\n\r\n        /**\r\n         * Acceleration of Bodies due to gravity, in pixels per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.gravity = new Vector2(GetValue(config, 'gravity.x', 0), GetValue(config, 'gravity.y', 0));\r\n\r\n        /**\r\n         * A boundary constraining Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.0.0\r\n         */\r\n        this.bounds = new Rectangle(\r\n            GetValue(config, 'x', 0),\r\n            GetValue(config, 'y', 0),\r\n            GetValue(config, 'width', scene.sys.game.config.width),\r\n            GetValue(config, 'height', scene.sys.game.config.height)\r\n        );\r\n\r\n        /**\r\n         * The boundary edges that Bodies can collide with.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#checkCollision\r\n         * @type {CheckCollisionObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.checkCollision = {\r\n            up: GetValue(config, 'checkCollision.up', true),\r\n            down: GetValue(config, 'checkCollision.down', true),\r\n            left: GetValue(config, 'checkCollision.left', true),\r\n            right: GetValue(config, 'checkCollision.right', true)\r\n        };\r\n\r\n        /**\r\n         * The number of physics steps to be taken per second.\r\n         *\r\n         * This property is read-only. Use the `setFPS` method to modify it at run-time.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#fps\r\n         * @readOnly\r\n         * @type {number}\r\n         * @default 60\r\n         * @since 3.10.0\r\n         */\r\n        this.fps = GetValue(config, 'fps', 60);\r\n\r\n        /**\r\n         * The amount of elapsed ms since the last frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_elapsed\r\n         * @private\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * Internal frame time value.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_frameTime\r\n         * @private\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this._frameTime = 1 / this.fps;\r\n\r\n        /**\r\n         * Internal frame time ms value.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_frameTimeMS\r\n         * @private\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this._frameTimeMS = 1000 * this._frameTime;\r\n\r\n        /**\r\n         * The number of steps that took place in the last frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#stepsLastFrame\r\n         * @readOnly\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this.stepsLastFrame = 0;\r\n\r\n        /**\r\n         * Scaling factor applied to the frame rate.\r\n         *\r\n         * - 1.0 = normal speed\r\n         * - 2.0 = half speed\r\n         * - 0.5 = double speed\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#timeScale\r\n         * @property {number}\r\n         * @default 1\r\n         * @since 3.10.0\r\n         */\r\n        this.timeScale = GetValue(config, 'timeScale', 1);\r\n\r\n        /**\r\n         * The maximum absolute difference of a Body's per-step velocity and its overlap with another Body that will result in separation on *each axis*.\r\n         * Larger values favor separation.\r\n         * Smaller values favor no separation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#OVERLAP_BIAS\r\n         * @type {number}\r\n         * @default 4\r\n         * @since 3.0.0\r\n         */\r\n        this.OVERLAP_BIAS = GetValue(config, 'overlapBias', 4);\r\n\r\n        /**\r\n         * The maximum absolute value of a Body's overlap with a tile that will result in separation on *each axis*.\r\n         * Larger values favor separation.\r\n         * Smaller values favor no separation.\r\n         * The optimum value may be similar to the tile size.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#TILE_BIAS\r\n         * @type {number}\r\n         * @default 16\r\n         * @since 3.0.0\r\n         */\r\n        this.TILE_BIAS = GetValue(config, 'tileBias', 16);\r\n\r\n        /**\r\n         * Always separate overlapping Bodies horizontally before vertically.\r\n         * False (the default) means Bodies are first separated on the axis of greater gravity, or the vertical axis if neither is greater.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#forceX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.forceX = GetValue(config, 'forceX', false);\r\n\r\n        /**\r\n         * Whether the simulation advances with the game loop.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#isPaused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isPaused = GetValue(config, 'isPaused', false);\r\n\r\n        /**\r\n         * Temporary total of colliding Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_total\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._total = 0;\r\n\r\n        /**\r\n         * Enables the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#drawDebug\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.drawDebug = GetValue(config, 'debug', false);\r\n\r\n        /**\r\n         * The graphics object drawing the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugGraphic;\r\n\r\n        /**\r\n         * Default debug display settings for new Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#defaults\r\n         * @type {ArcadeWorldDefaults}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaults = {\r\n            debugShowBody: GetValue(config, 'debugShowBody', true),\r\n            debugShowStaticBody: GetValue(config, 'debugShowStaticBody', true),\r\n            debugShowVelocity: GetValue(config, 'debugShowVelocity', true),\r\n            bodyDebugColor: GetValue(config, 'debugBodyColor', 0xff00ff),\r\n            staticBodyDebugColor: GetValue(config, 'debugStaticBodyColor', 0x0000ff),\r\n            velocityDebugColor: GetValue(config, 'debugVelocityColor', 0x00ff00)\r\n        };\r\n\r\n        /**\r\n         * The maximum number of items per node on the RTree.\r\n         *\r\n         * This is ignored if `useTree` is `false`. If you have a large number of bodies in\r\n         * your world then you may find search performance improves by increasing this value,\r\n         * to allow more items per node and less node division.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#maxEntries\r\n         * @type {integer}\r\n         * @default 16\r\n         * @since 3.0.0\r\n         */\r\n        this.maxEntries = GetValue(config, 'maxEntries', 16);\r\n\r\n        /**\r\n         * Should this Arcade Physics World use an RTree for Dynamic Physics bodies or not?\r\n         *\r\n         * An RTree is a fast way of spatially sorting of all the moving bodies in the world.\r\n         * However, at certain limits, the cost of clearing and inserting the bodies into the\r\n         * tree every frame becomes more expensive than the search speed gains it provides.\r\n         *\r\n         * If you have a large number of dynamic bodies in your world then it may be best to\r\n         * disable the use of the RTree by setting this property to `true`.\r\n         * The number it can cope with depends on browser and device, but a conservative estimate\r\n         * of around 5,000 bodies should be considered the max before disabling it.\r\n         *\r\n         * Note this only applies to dynamic bodies. Static bodies are always kept in an RTree,\r\n         * because they don't have to be cleared every frame, so you benefit from the\r\n         * massive search speeds all the time.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#useTree\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.useTree = GetValue(config, 'useTree', true);\r\n\r\n        /**\r\n         * The spatial index of Dynamic Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#tree\r\n         * @type {Phaser.Structs.RTree}\r\n         * @since 3.0.0\r\n         */\r\n        this.tree = new RTree(this.maxEntries);\r\n\r\n        /**\r\n         * The spatial index of Static Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#staticTree\r\n         * @type {Phaser.Structs.RTree}\r\n         * @since 3.0.0\r\n         */\r\n        this.staticTree = new RTree(this.maxEntries);\r\n\r\n        /**\r\n         * Recycled input for tree searches.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#treeMinMax\r\n         * @type {ArcadeWorldTreeMinMax}\r\n         * @since 3.0.0\r\n         */\r\n        this.treeMinMax = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\r\n\r\n        /**\r\n         * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_tempMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_tempMatrix2\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            this.createDebugGraphic();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an Arcade Physics Body to a Game Object, an array of Game Objects, or the children of a Group.\r\n     *\r\n     * The difference between this and the `enableBody` method is that you can pass arrays or Groups\r\n     * to this method.\r\n     *\r\n     * You can specify if the bodies are to be Dynamic or Static. A dynamic body can move via velocity and\r\n     * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n     * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n     * with static bodies.\r\n     *\r\n     * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n     * Arcade Physics Factory, such as:\r\n     *\r\n     * ```javascript\r\n     * this.physics.add.image(x, y, textureKey);\r\n     * this.physics.add.sprite(x, y, textureKey);\r\n     * ```\r\n     *\r\n     * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n     * body at the same time. If you are creating custom classes then you can pass them to this\r\n     * method to have their bodies created.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to create the bodies.\r\n     * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n     */\r\n    enable: function (object, bodyType)\r\n    {\r\n        if (bodyType === undefined) { bodyType = CONST.DYNAMIC_BODY; }\r\n\r\n        if (!Array.isArray(object))\r\n        {\r\n            object = [ object ];\r\n        }\r\n\r\n        for (var i = 0; i < object.length; i++)\r\n        {\r\n            var entry = object[i];\r\n\r\n            if (entry.isParent)\r\n            {\r\n                var children = entry.getChildren();\r\n\r\n                for (var c = 0; c < children.length; c++)\r\n                {\r\n                    var child = children[c];\r\n\r\n                    if (child.isParent)\r\n                    {\r\n                        //  Handle Groups nested inside of Groups\r\n                        this.enable(child, bodyType);\r\n                    }\r\n                    else\r\n                    {\r\n                        this.enableBody(child, bodyType);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.enableBody(entry, bodyType);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates an Arcade Physics Body on a single Game Object.\r\n     *\r\n     * If the Game Object already has a body, this method will simply add it back into the simulation.\r\n     *\r\n     * You can specify if the body is Dynamic or Static. A dynamic body can move via velocity and\r\n     * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n     * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n     * with static bodies.\r\n     *\r\n     * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n     * Arcade Physics Factory, such as:\r\n     *\r\n     * ```javascript\r\n     * this.physics.add.image(x, y, textureKey);\r\n     * this.physics.add.sprite(x, y, textureKey);\r\n     * ```\r\n     *\r\n     * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n     * body at the same time. If you are creating custom classes then you can pass them to this\r\n     * method to have their bodies created.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#enableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} object - The Game Object on which to create the body.\r\n     * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object on which the body was created.\r\n     */\r\n    enableBody: function (object, bodyType)\r\n    {\r\n        if (bodyType === undefined) { bodyType = CONST.DYNAMIC_BODY; }\r\n\r\n        if (!object.body)\r\n        {\r\n            if (bodyType === CONST.DYNAMIC_BODY)\r\n            {\r\n                object.body = new Body(this, object);\r\n            }\r\n            else if (bodyType === CONST.STATIC_BODY)\r\n            {\r\n                object.body = new StaticBody(this, object);\r\n            }\r\n        }\r\n\r\n        this.add(object.body);\r\n\r\n        return object;\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Arcade Physics Body or StaticBody to the simulation.\r\n     *\r\n     * The body is enabled and added to the local search trees.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#add\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be added to the simulation.\r\n     *\r\n     * @return {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} The Body that was added to the simulation.\r\n     */\r\n    add: function (body)\r\n    {\r\n        if (body.physicsType === CONST.DYNAMIC_BODY)\r\n        {\r\n            this.bodies.set(body);\r\n        }\r\n        else if (body.physicsType === CONST.STATIC_BODY)\r\n        {\r\n            this.staticBodies.set(body);\r\n\r\n            this.staticTree.insert(body);\r\n        }\r\n\r\n        body.enable = true;\r\n\r\n        return body;\r\n    },\r\n\r\n    /**\r\n     * Disables the Arcade Physics Body of a Game Object, an array of Game Objects, or the children of a Group.\r\n     *\r\n     * The difference between this and the `disableBody` method is that you can pass arrays or Groups\r\n     * to this method.\r\n     *\r\n     * The body itself is not deleted, it just has its `enable` property set to false, which\r\n     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to disable the bodies.\r\n     */\r\n    disable: function (object)\r\n    {\r\n        if (!Array.isArray(object))\r\n        {\r\n            object = [ object ];\r\n        }\r\n\r\n        for (var i = 0; i < object.length; i++)\r\n        {\r\n            var entry = object[i];\r\n\r\n            if (entry.isParent)\r\n            {\r\n                var children = entry.getChildren();\r\n\r\n                for (var c = 0; c < children.length; c++)\r\n                {\r\n                    var child = children[c];\r\n\r\n                    if (child.isParent)\r\n                    {\r\n                        //  Handle Groups nested inside of Groups\r\n                        this.disable(child);\r\n                    }\r\n                    else\r\n                    {\r\n                        this.disableBody(child.body);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.disableBody(entry.body);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Disables an existing Arcade Physics Body or StaticBody and removes it from the simulation.\r\n     *\r\n     * The body is disabled and removed from the local search trees.\r\n     *\r\n     * The body itself is not deleted, it just has its `enable` property set to false, which\r\n     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#disableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be disabled.\r\n     */\r\n    disableBody: function (body)\r\n    {\r\n        this.remove(body);\r\n\r\n        body.enable = false;\r\n    },\r\n\r\n    /**\r\n     * Removes an existing Arcade Physics Body or StaticBody from the simulation.\r\n     *\r\n     * The body is disabled and removed from the local search trees.\r\n     *\r\n     * The body itself is not deleted, it just has its `enabled` property set to false, which\r\n     * means you can re-enable it again at any point by passing it to enable `enable` or `add`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The body to be removed from the simulation.\r\n     */\r\n    remove: function (body)\r\n    {\r\n        if (body.physicsType === CONST.DYNAMIC_BODY)\r\n        {\r\n            this.tree.remove(body);\r\n            this.bodies.delete(body);\r\n        }\r\n        else if (body.physicsType === CONST.STATIC_BODY)\r\n        {\r\n            this.staticBodies.delete(body);\r\n            this.staticTree.remove(body);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a Graphics Game Object that the world will use to render the debug display to.\r\n     *\r\n     * This is called automatically when the World is instantiated if the `debug` config property\r\n     * was set to `true`. However, you can call it at any point should you need to display the\r\n     * debug Graphic from a fixed point.\r\n     *\r\n     * You can control which objects are drawn to the Graphics object, and the colors they use,\r\n     * by setting the debug properties in the physics config.\r\n     *\r\n     * You should not typically use this in a production game. Use it to aid during debugging.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object that was created for use by the World.\r\n     */\r\n    createDebugGraphic: function ()\r\n    {\r\n        var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });\r\n\r\n        graphic.setDepth(Number.MAX_VALUE);\r\n\r\n        this.debugGraphic = graphic;\r\n\r\n        this.drawDebug = true;\r\n\r\n        return graphic;\r\n    },\r\n\r\n    /**\r\n     * Sets the position, size and properties of the World boundary.\r\n     *\r\n     * The World boundary is an invisible rectangle that defines the edges of the World.\r\n     * If a Body is set to collide with the world bounds then it will automatically stop\r\n     * when it reaches any of the edges. You can optionally set which edges of the boundary\r\n     * should be checked against.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The top-left x coordinate of the boundary.\r\n     * @param {number} y - The top-left y coordinate of the boundary.\r\n     * @param {number} width - The width of the boundary.\r\n     * @param {number} height - The height of the boundary.\r\n     * @param {boolean} [checkLeft] - Should bodies check against the left edge of the boundary?\r\n     * @param {boolean} [checkRight] - Should bodies check against the right edge of the boundary?\r\n     * @param {boolean} [checkUp] - Should bodies check against the top edge of the boundary?\r\n     * @param {boolean} [checkDown] - Should bodies check against the bottom edge of the boundary?\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    setBounds: function (x, y, width, height, checkLeft, checkRight, checkUp, checkDown)\r\n    {\r\n        this.bounds.setTo(x, y, width, height);\r\n\r\n        if (checkLeft !== undefined)\r\n        {\r\n            this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables collisions on each edge of the World boundary.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setBoundsCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [left=true] - Should bodies check against the left edge of the boundary?\r\n     * @param {boolean} [right=true] - Should bodies check against the right edge of the boundary?\r\n     * @param {boolean} [up=true] - Should bodies check against the top edge of the boundary?\r\n     * @param {boolean} [down=true] - Should bodies check against the bottom edge of the boundary?\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    setBoundsCollision: function (left, right, up, down)\r\n    {\r\n        if (left === undefined) { left = true; }\r\n        if (right === undefined) { right = true; }\r\n        if (up === undefined) { up = true; }\r\n        if (down === undefined) { down = true; }\r\n\r\n        this.checkCollision.left = left;\r\n        this.checkCollision.right = right;\r\n        this.checkCollision.up = up;\r\n        this.checkCollision.down = down;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pauses the simulation.\r\n     *\r\n     * A paused simulation does not update any existing bodies, or run any Colliders.\r\n     *\r\n     * However, you can still enable and disable bodies within it, or manually run collide or overlap\r\n     * checks.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#pause\r\n     * @fires Phaser.Physics.Arcade.World#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.isPaused = true;\r\n\r\n        this.emit('pause');\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes the simulation, if paused.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#resume\r\n     * @fires Phaser.Physics.Arcade.World#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.isPaused = false;\r\n\r\n        this.emit('resume');\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Collider object and adds it to the simulation.\r\n     *\r\n     * A Collider is a way to automatically perform collision checks between two objects,\r\n     * calling the collide and process callbacks if they occur.\r\n     *\r\n     * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n     *\r\n     * By creating a Collider you don't need then call `World.collide` in your `update` loop,\r\n     * as it will be handled for you automatically.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#addCollider\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#collide\r\n     *\r\n     * @param {ArcadeColliderType} object1 - The first object to check for collision.\r\n     * @param {ArcadeColliderType} object2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */\r\n    addCollider: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);\r\n\r\n        this.colliders.add(collider);\r\n\r\n        return collider;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Overlap Collider object and adds it to the simulation.\r\n     *\r\n     * A Collider is a way to automatically perform overlap checks between two objects,\r\n     * calling the collide and process callbacks if they occur.\r\n     *\r\n     * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n     *\r\n     * By creating a Collider you don't need then call `World.overlap` in your `update` loop,\r\n     * as it will be handled for you automatically.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#addOverlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeColliderType} object1 - The first object to check for overlap.\r\n     * @param {ArcadeColliderType} object2 - The second object to check for overlap.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects overlap. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */\r\n    addOverlap: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);\r\n\r\n        this.colliders.add(collider);\r\n\r\n        return collider;\r\n    },\r\n\r\n    /**\r\n     * Removes a Collider from the simulation so it is no longer processed.\r\n     *\r\n     * This method does not destroy the Collider. If you wish to add it back at a later stage you can call\r\n     * `World.colliders.add(Collider)`.\r\n     *\r\n     * If you no longer need the Collider you can call the `Collider.destroy` method instead, which will\r\n     * automatically clear all of its references and then remove it from the World. If you call destroy on\r\n     * a Collider you _don't_ need to pass it to this method too.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#removeCollider\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Collider} collider - The Collider to remove from the simulation.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    removeCollider: function (collider)\r\n    {\r\n        this.colliders.remove(collider);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the frame rate to run the simulation at.\r\n     *\r\n     * The frame rate value is used to simulate a fixed update time step. This fixed\r\n     * time step allows for a straightforward implementation of a deterministic game state.\r\n     *\r\n     * This frame rate is independent of the frequency at which the game is rendering. The\r\n     * higher you set the fps, the more physics simulation steps will occur per game step.\r\n     * Conversely, the lower you set it, the less will take place.\r\n     *\r\n     * You can optionally advance the simulation directly yourself by calling the `step` method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setFPS\r\n     * @since 3.10.0\r\n     *\r\n     * @param {integer} framerate - The frame rate to advance the simulation at.\r\n     *\r\n     * @return {this} This World object.\r\n     */\r\n    setFPS: function (framerate)\r\n    {\r\n        this.fps = framerate;\r\n        this._frameTime = 1 / this.fps;\r\n        this._frameTimeMS = 1000 * this._frameTime;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Advances the simulation based on the elapsed time and fps rate.\r\n     *\r\n     * This is called automatically by your Scene and does not need to be invoked directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#update\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (this.isPaused || this.bodies.size === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var stepsThisFrame = 0;\r\n        var fixedDelta = this._frameTime;\r\n        var msPerFrame = this._frameTimeMS * this.timeScale;\r\n\r\n        this._elapsed += delta;\r\n\r\n        while (this._elapsed >= msPerFrame)\r\n        {\r\n            this._elapsed -= msPerFrame;\r\n\r\n            stepsThisFrame++;\r\n\r\n            this.step(fixedDelta);\r\n        }\r\n\r\n        this.stepsLastFrame = stepsThisFrame;\r\n    },\r\n\r\n    /**\r\n     * Advances the simulation by one step.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#step\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} delta - The delta time amount, in ms, by which to advance the simulation.\r\n     */\r\n    step: function (delta)\r\n    {\r\n        //  Update all active bodies\r\n        var i;\r\n        var body;\r\n        var bodies = this.bodies.entries;\r\n        var len = bodies.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body.enable)\r\n            {\r\n                body.update(delta);\r\n            }\r\n        }\r\n\r\n        //  Optionally populate our dynamic collision tree\r\n        if (this.useTree)\r\n        {\r\n            this.tree.clear();\r\n            this.tree.load(bodies);\r\n        }\r\n\r\n        //  Process any colliders\r\n        var colliders = this.colliders.update();\r\n\r\n        for (i = 0; i < colliders.length; i++)\r\n        {\r\n            var collider = colliders[i];\r\n\r\n            if (collider.active)\r\n            {\r\n                collider.update();\r\n            }\r\n        }\r\n\r\n        len = bodies.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body.enable)\r\n            {\r\n                body.postUpdate();\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Updates bodies, draws the debug display, and handles pending queue operations.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#postUpdate\r\n     * @since 3.0.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n        var i;\r\n        var body;\r\n\r\n        var dynamic = this.bodies;\r\n        var staticBodies = this.staticBodies;\r\n        var pending = this.pendingDestroy;\r\n\r\n        var bodies = dynamic.entries;\r\n        var len = bodies.length;\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            var graphics = this.debugGraphic;\r\n\r\n            graphics.clear();\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.willDrawDebug())\r\n                {\r\n                    body.drawDebug(graphics);\r\n                }\r\n            }\r\n\r\n            bodies = staticBodies.entries;\r\n            len = bodies.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.willDrawDebug())\r\n                {\r\n                    body.drawDebug(graphics);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (pending.size > 0)\r\n        {\r\n            var dynamicTree = this.tree;\r\n            var staticTree = this.staticTree;\r\n\r\n            bodies = pending.entries;\r\n            len = bodies.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.physicsType === CONST.DYNAMIC_BODY)\r\n                {\r\n                    dynamicTree.remove(body);\r\n                    dynamic.delete(body);\r\n                }\r\n                else if (body.physicsType === CONST.STATIC_BODY)\r\n                {\r\n                    staticTree.remove(body);\r\n                    staticBodies.delete(body);\r\n                }\r\n\r\n                body.world = undefined;\r\n                body.gameObject = undefined;\r\n            }\r\n\r\n            pending.clear();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calculates a Body's velocity and updates its position.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#updateMotion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to be updated.\r\n     * @param {number} delta - The delta value to be used in the motion calculations.\r\n     */\r\n    updateMotion: function (body, delta)\r\n    {\r\n        if (body.allowRotation)\r\n        {\r\n            this.computeAngularVelocity(body, delta);\r\n        }\r\n\r\n        this.computeVelocity(body, delta);\r\n    },\r\n\r\n    /**\r\n     * Calculates a Body's angular velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#computeAngularVelocity\r\n     * @since 3.10.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n     * @param {number} delta - The delta value to be used in the calculation.\r\n     */\r\n    computeAngularVelocity: function (body, delta)\r\n    {\r\n        var velocity = body.angularVelocity;\r\n        var acceleration = body.angularAcceleration;\r\n        var drag = body.angularDrag;\r\n        var max = body.maxAngular;\r\n\r\n        if (acceleration)\r\n        {\r\n            velocity += acceleration * delta;\r\n        }\r\n        else if (body.allowDrag && drag)\r\n        {\r\n            drag *= delta;\r\n\r\n            if (FuzzyGreaterThan(velocity - drag, 0, 0.1))\r\n            {\r\n                velocity -= drag;\r\n            }\r\n            else if (FuzzyLessThan(velocity + drag, 0, 0.1))\r\n            {\r\n                velocity += drag;\r\n            }\r\n            else\r\n            {\r\n                velocity = 0;\r\n            }\r\n        }\r\n\r\n        velocity = Clamp(velocity, -max, max);\r\n\r\n        var velocityDelta = velocity - body.angularVelocity;\r\n\r\n        body.angularVelocity += velocityDelta;\r\n        body.rotation += (body.angularVelocity * delta);\r\n    },\r\n\r\n    /**\r\n     * Calculates a Body's per-axis velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#computeVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n     * @param {number} delta - The delta value to be used in the calculation.\r\n     */\r\n    computeVelocity: function (body, delta)\r\n    {\r\n        var velocityX = body.velocity.x;\r\n        var accelerationX = body.acceleration.x;\r\n        var dragX = body.drag.x;\r\n        var maxX = body.maxVelocity.x;\r\n\r\n        var velocityY = body.velocity.y;\r\n        var accelerationY = body.acceleration.y;\r\n        var dragY = body.drag.y;\r\n        var maxY = body.maxVelocity.y;\r\n\r\n        var speed = body.speed;\r\n        var allowDrag = body.allowDrag;\r\n        var useDamping = body.useDamping;\r\n\r\n        if (body.allowGravity)\r\n        {\r\n            velocityX += (this.gravity.x + body.gravity.x) * delta;\r\n            velocityY += (this.gravity.y + body.gravity.y) * delta;\r\n        }\r\n\r\n        if (accelerationX)\r\n        {\r\n            velocityX += accelerationX * delta;\r\n        }\r\n        else if (allowDrag && dragX)\r\n        {\r\n            if (useDamping)\r\n            {\r\n                //  Damping based deceleration\r\n                velocityX *= dragX;\r\n\r\n                if (FuzzyEqual(speed, 0, 0.001))\r\n                {\r\n                    velocityX = 0;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Linear deceleration\r\n                dragX *= delta;\r\n\r\n                if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01))\r\n                {\r\n                    velocityX -= dragX;\r\n                }\r\n                else if (FuzzyLessThan(velocityX + dragX, 0, 0.01))\r\n                {\r\n                    velocityX += dragX;\r\n                }\r\n                else\r\n                {\r\n                    velocityX = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (accelerationY)\r\n        {\r\n            velocityY += accelerationY * delta;\r\n        }\r\n        else if (allowDrag && dragY)\r\n        {\r\n            if (useDamping)\r\n            {\r\n                //  Damping based deceleration\r\n                velocityY *= dragY;\r\n\r\n                if (FuzzyEqual(speed, 0, 0.001))\r\n                {\r\n                    velocityY = 0;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Linear deceleration\r\n                dragY *= delta;\r\n\r\n                if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01))\r\n                {\r\n                    velocityY -= dragY;\r\n                }\r\n                else if (FuzzyLessThan(velocityY + dragY, 0, 0.01))\r\n                {\r\n                    velocityY += dragY;\r\n                }\r\n                else\r\n                {\r\n                    velocityY = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        velocityX = Clamp(velocityX, -maxX, maxX);\r\n        velocityY = Clamp(velocityY, -maxY, maxY);\r\n\r\n        body.velocity.set(velocityX, velocityY);\r\n    },\r\n\r\n    /**\r\n     * Separates two Bodies.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#separate\r\n     * @fires Phaser.Physics.Arcade.World#collide\r\n     * @fires Phaser.Physics.Arcade.World#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The process callback.\r\n     * @param {*} [callbackContext] - The context in which to invoke the callback.\r\n     * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n     *\r\n     * @return {boolean} True if separation occurred, otherwise false.\r\n     */\r\n    separate: function (body1, body2, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        if (\r\n            !body1.enable ||\r\n            !body2.enable ||\r\n            body1.checkCollision.none ||\r\n            body2.checkCollision.none ||\r\n            !this.intersects(body1, body2))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  They overlap. Is there a custom process callback? If it returns true then we can carry on, otherwise we should abort.\r\n        if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  Circle vs. Circle quick bail out\r\n        if (body1.isCircle && body2.isCircle)\r\n        {\r\n            return this.separateCircle(body1, body2, overlapOnly);\r\n        }\r\n\r\n        // We define the behavior of bodies in a collision circle and rectangle\r\n        // If a collision occurs in the corner points of the rectangle, the body behave like circles\r\n\r\n        //  Either body1 or body2 is a circle\r\n        if (body1.isCircle !== body2.isCircle)\r\n        {\r\n            var bodyRect = (body1.isCircle) ? body2 : body1;\r\n            var bodyCircle = (body1.isCircle) ? body1 : body2;\r\n\r\n            var rect = {\r\n                x: bodyRect.x,\r\n                y: bodyRect.y,\r\n                right: bodyRect.right,\r\n                bottom: bodyRect.bottom\r\n            };\r\n\r\n            var circle = bodyCircle.center;\r\n\r\n            if (circle.y < rect.y || circle.y > rect.bottom)\r\n            {\r\n                if (circle.x < rect.x || circle.x > rect.right)\r\n                {\r\n                    return this.separateCircle(body1, body2, overlapOnly);\r\n                }\r\n            }\r\n        }\r\n\r\n        var resultX = false;\r\n        var resultY = false;\r\n\r\n        //  Do we separate on x or y first?\r\n        if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x))\r\n        {\r\n            resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n\r\n            //  Are they still intersecting? Let's do the other axis then\r\n            if (this.intersects(body1, body2))\r\n            {\r\n                resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n\r\n            //  Are they still intersecting? Let's do the other axis then\r\n            if (this.intersects(body1, body2))\r\n            {\r\n                resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n            }\r\n        }\r\n\r\n        var result = (resultX || resultY);\r\n\r\n        if (result)\r\n        {\r\n            if (overlapOnly && (body1.onOverlap || body2.onOverlap))\r\n            {\r\n                this.emit('overlap', body1.gameObject, body2.gameObject, body1, body2);\r\n            }\r\n            else\r\n            {\r\n                body1.postUpdate();\r\n                body2.postUpdate();\r\n\r\n                if (body1.onCollide || body2.onCollide)\r\n                {\r\n                    this.emit('collide', body1.gameObject, body2.gameObject, body1, body2);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Separates two Bodies, when both are circular.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#separateCircle\r\n     * @fires Phaser.Physics.Arcade.World#collide\r\n     * @fires Phaser.Physics.Arcade.World#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n     * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n     * @param {number} bias - A small value added to the calculations.\r\n     *\r\n     * @return {boolean} True if separation occurred, otherwise false.\r\n     */\r\n    separateCircle: function (body1, body2, overlapOnly, bias)\r\n    {\r\n        //  Set the bounding box overlap values into the bodies themselves (hence we don't use the return values here)\r\n        GetOverlapX(body1, body2, false, bias);\r\n        GetOverlapY(body1, body2, false, bias);\r\n\r\n        var dx = body2.center.x - body1.center.x;\r\n        var dy = body2.center.y - body1.center.y;\r\n\r\n        var angleCollision = Math.atan2(dy, dx);\r\n\r\n        var overlap = 0;\r\n\r\n        if (body1.isCircle !== body2.isCircle)\r\n        {\r\n            var rect = {\r\n                x: (body2.isCircle) ? body1.position.x : body2.position.x,\r\n                y: (body2.isCircle) ? body1.position.y : body2.position.y,\r\n                right: (body2.isCircle) ? body1.right : body2.right,\r\n                bottom: (body2.isCircle) ? body1.bottom : body2.bottom\r\n            };\r\n\r\n            var circle = {\r\n                x: (body1.isCircle) ? body1.center.x : body2.center.x,\r\n                y: (body1.isCircle) ? body1.center.y : body2.center.y,\r\n                radius: (body1.isCircle) ? body1.halfWidth : body2.halfWidth\r\n            };\r\n\r\n            if (circle.y < rect.y)\r\n            {\r\n                if (circle.x < rect.x)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.y) - circle.radius;\r\n                }\r\n                else if (circle.x > rect.right)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.y) - circle.radius;\r\n                }\r\n            }\r\n            else if (circle.y > rect.bottom)\r\n            {\r\n                if (circle.x < rect.x)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;\r\n                }\r\n                else if (circle.x > rect.right)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;\r\n                }\r\n            }\r\n\r\n            overlap *= -1;\r\n        }\r\n        else\r\n        {\r\n            overlap = (body1.halfWidth + body2.halfWidth) - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y);\r\n        }\r\n\r\n        //  Can't separate two immovable bodies, or a body with its own custom separation logic\r\n        if (overlapOnly || overlap === 0 || (body1.immovable && body2.immovable) || body1.customSeparateX || body2.customSeparateX)\r\n        {\r\n            if (overlap !== 0 && (body1.onOverlap || body2.onOverlap))\r\n            {\r\n                this.emit('overlap', body1.gameObject, body2.gameObject, body1, body2);\r\n            }\r\n\r\n            //  return true if there was some overlap, otherwise false\r\n            return (overlap !== 0);\r\n        }\r\n\r\n        // Transform the velocity vector to the coordinate system oriented along the direction of impact.\r\n        // This is done to eliminate the vertical component of the velocity\r\n\r\n        var b1vx = body1.velocity.x;\r\n        var b1vy = body1.velocity.y;\r\n        var b1mass = body1.mass;\r\n\r\n        var b2vx = body2.velocity.x;\r\n        var b2vy = body2.velocity.y;\r\n        var b2mass = body2.mass;\r\n\r\n        var v1 = {\r\n            x: b1vx * Math.cos(angleCollision) + b1vy * Math.sin(angleCollision),\r\n            y: b1vx * Math.sin(angleCollision) - b1vy * Math.cos(angleCollision)\r\n        };\r\n\r\n        var v2 = {\r\n            x: b2vx * Math.cos(angleCollision) + b2vy * Math.sin(angleCollision),\r\n            y: b2vx * Math.sin(angleCollision) - b2vy * Math.cos(angleCollision)\r\n        };\r\n\r\n        // We expect the new velocity after impact\r\n        var tempVel1 = ((b1mass - b2mass) * v1.x + 2 * b2mass * v2.x) / (b1mass + b2mass);\r\n        var tempVel2 = (2 * b1mass * v1.x + (b2mass - b1mass) * v2.x) / (b1mass + b2mass);\r\n\r\n        // We convert the vector to the original coordinate system and multiplied by factor of rebound\r\n        if (!body1.immovable)\r\n        {\r\n            body1.velocity.x = (tempVel1 * Math.cos(angleCollision) - v1.y * Math.sin(angleCollision)) * body1.bounce.x;\r\n            body1.velocity.y = (v1.y * Math.cos(angleCollision) + tempVel1 * Math.sin(angleCollision)) * body1.bounce.y;\r\n\r\n            //  Reset local var\r\n            b1vx = body1.velocity.x;\r\n            b1vy = body1.velocity.y;\r\n        }\r\n\r\n        if (!body2.immovable)\r\n        {\r\n            body2.velocity.x = (tempVel2 * Math.cos(angleCollision) - v2.y * Math.sin(angleCollision)) * body2.bounce.x;\r\n            body2.velocity.y = (v2.y * Math.cos(angleCollision) + tempVel2 * Math.sin(angleCollision)) * body2.bounce.y;\r\n\r\n            //  Reset local var\r\n            b2vx = body2.velocity.x;\r\n            b2vy = body2.velocity.y;\r\n        }\r\n\r\n        // When the collision angle is almost perpendicular to the total initial velocity vector\r\n        // (collision on a tangent) vector direction can be determined incorrectly.\r\n        // This code fixes the problem\r\n\r\n        if (Math.abs(angleCollision) < Math.PI / 2)\r\n        {\r\n            if ((b1vx > 0) && !body1.immovable && (b2vx > b1vx))\r\n            {\r\n                body1.velocity.x *= -1;\r\n            }\r\n            else if ((b2vx < 0) && !body2.immovable && (b1vx < b2vx))\r\n            {\r\n                body2.velocity.x *= -1;\r\n            }\r\n            else if ((b1vy > 0) && !body1.immovable && (b2vy > b1vy))\r\n            {\r\n                body1.velocity.y *= -1;\r\n            }\r\n            else if ((b2vy < 0) && !body2.immovable && (b1vy < b2vy))\r\n            {\r\n                body2.velocity.y *= -1;\r\n            }\r\n        }\r\n        else if (Math.abs(angleCollision) > Math.PI / 2)\r\n        {\r\n            if ((b1vx < 0) && !body1.immovable && (b2vx < b1vx))\r\n            {\r\n                body1.velocity.x *= -1;\r\n            }\r\n            else if ((b2vx > 0) && !body2.immovable && (b1vx > b2vx))\r\n            {\r\n                body2.velocity.x *= -1;\r\n            }\r\n            else if ((b1vy < 0) && !body1.immovable && (b2vy < b1vy))\r\n            {\r\n                body1.velocity.y *= -1;\r\n            }\r\n            else if ((b2vy > 0) && !body2.immovable && (b1vx > b2vy))\r\n            {\r\n                body2.velocity.y *= -1;\r\n            }\r\n        }\r\n\r\n        var delta = this._frameTime;\r\n\r\n        if (!body1.immovable)\r\n        {\r\n            body1.x += (body1.velocity.x * delta) - overlap * Math.cos(angleCollision);\r\n            body1.y += (body1.velocity.y * delta) - overlap * Math.sin(angleCollision);\r\n        }\r\n\r\n        if (!body2.immovable)\r\n        {\r\n            body2.x += (body2.velocity.x * delta) + overlap * Math.cos(angleCollision);\r\n            body2.y += (body2.velocity.y * delta) + overlap * Math.sin(angleCollision);\r\n        }\r\n\r\n        if (body1.onCollide || body2.onCollide)\r\n        {\r\n            this.emit('collide', body1.gameObject, body2.gameObject, body1, body2);\r\n        }\r\n\r\n        //  sync changes back to the bodies\r\n        body1.postUpdate();\r\n        body2.postUpdate();\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if two Bodies intersect at all.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first body to check.\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second body to check.\r\n     *\r\n     * @return {boolean} True if the two bodies intersect, otherwise false.\r\n     */\r\n    intersects: function (body1, body2)\r\n    {\r\n        if (body1 === body2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (!body1.isCircle && !body2.isCircle)\r\n        {\r\n            //  Rect vs. Rect\r\n            return !(\r\n                body1.right <= body2.position.x ||\r\n                body1.bottom <= body2.position.y ||\r\n                body1.position.x >= body2.right ||\r\n                body1.position.y >= body2.bottom\r\n            );\r\n        }\r\n        else if (body1.isCircle)\r\n        {\r\n            if (body2.isCircle)\r\n            {\r\n                //  Circle vs. Circle\r\n                return DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= (body1.halfWidth + body2.halfWidth);\r\n            }\r\n            else\r\n            {\r\n                //  Circle vs. Rect\r\n                return this.circleBodyIntersects(body1, body2);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  Rect vs. Circle\r\n            return this.circleBodyIntersects(body2, body1);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Tests if a circular Body intersects with another Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#circleBodyIntersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} circle - The circular body to test.\r\n     * @param {Phaser.Physics.Arcade.Body} body - The rectangular body to test.\r\n     *\r\n     * @return {boolean} True if the two bodies intersect, otherwise false.\r\n     */\r\n    circleBodyIntersects: function (circle, body)\r\n    {\r\n        var x = Clamp(circle.center.x, body.left, body.right);\r\n        var y = Clamp(circle.center.y, body.top, body.bottom);\r\n\r\n        var dx = (circle.center.x - x) * (circle.center.x - x);\r\n        var dy = (circle.center.y - y) * (circle.center.y - y);\r\n\r\n        return (dx + dy) <= (circle.halfWidth * circle.halfWidth);\r\n    },\r\n\r\n    /**\r\n     * Tests if Game Objects overlap.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [overlapCallback] - An optional callback function that is called if the objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `overlapCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if at least one Game Object overlaps another.\r\n     */\r\n    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext)\r\n    {\r\n        if (overlapCallback === undefined) { overlapCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = overlapCallback; }\r\n\r\n        return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\r\n    },\r\n\r\n    /**\r\n     * Performs a collision check and separation between the two physics enabled objects given, which can be single\r\n     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\r\n     *\r\n     * If you don't require separation then use {@link #overlap} instead.\r\n     *\r\n     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\r\n     *\r\n     * If one Group **only** is passed (as `object1`), each member of the Group will be collided against the other members.\r\n     *\r\n     * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\r\n     * objects are passed to it.\r\n     *\r\n     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n     * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n     * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.\r\n     */\r\n    collide: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\r\n    },\r\n\r\n    /**\r\n     * Helper for Phaser.Physics.Arcade.World#collide.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeColliderType} object1 - [description]\r\n     * @param {ArcadeColliderType} [object2] - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideObjects: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var i;\r\n\r\n        if (object1.isParent && object1.physicsType === undefined)\r\n        {\r\n            object1 = object1.children.entries;\r\n        }\r\n\r\n        if (object2 && object2.isParent && object2.physicsType === undefined)\r\n        {\r\n            object2 = object2.children.entries;\r\n        }\r\n\r\n        var object1isArray = Array.isArray(object1);\r\n        var object2isArray = Array.isArray(object2);\r\n\r\n        this._total = 0;\r\n\r\n        if (!object1isArray && !object2isArray)\r\n        {\r\n            //  Neither of them are arrays - do this first as it's the most common use-case\r\n            this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n        else if (!object1isArray && object2isArray)\r\n        {\r\n            //  Object 2 is an Array\r\n            for (i = 0; i < object2.length; i++)\r\n            {\r\n                this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n        else if (object1isArray && !object2isArray)\r\n        {\r\n            //  Object 1 is an Array\r\n            for (i = 0; i < object1.length; i++)\r\n            {\r\n                this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  They're both arrays\r\n            for (i = 0; i < object1.length; i++)\r\n            {\r\n                for (var j = 0; j < object2.length; j++)\r\n                {\r\n                    this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);\r\n                }\r\n            }\r\n        }\r\n\r\n        return (this._total > 0);\r\n    },\r\n\r\n    /**\r\n     * Helper for Phaser.Physics.Arcade.World#collide and Phaser.Physics.Arcade.World#overlap.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideHandler\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeColliderType} object1 - [description]\r\n     * @param {ArcadeColliderType} [object2] - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideHandler: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        //  Collide Group with Self\r\n        //  Only collide valid objects\r\n        if (object2 === undefined && object1.isParent)\r\n        {\r\n            return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n\r\n        //  If neither of the objects are set then bail out\r\n        if (!object1 || !object2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  A Body\r\n        if (object1.body)\r\n        {\r\n            if (object2.body)\r\n            {\r\n                return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isParent)\r\n            {\r\n                return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isTilemap)\r\n            {\r\n                return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n\r\n        //  GROUPS\r\n        else if (object1.isParent)\r\n        {\r\n            if (object2.body)\r\n            {\r\n                return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isParent)\r\n            {\r\n                return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isTilemap)\r\n            {\r\n                return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n\r\n        //  TILEMAP LAYERS\r\n        else if (object1.isTilemap)\r\n        {\r\n            if (object2.body)\r\n            {\r\n                return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isParent)\r\n            {\r\n                return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handler for Sprite vs. Sprite collisions.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite1 - [description]\r\n     * @param {Phaser.GameObjects.GameObject} sprite2 - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    collideSpriteVsSprite: function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        if (!sprite1.body || !sprite2.body)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly))\r\n        {\r\n            if (collideCallback)\r\n            {\r\n                collideCallback.call(callbackContext, sprite1, sprite2);\r\n            }\r\n\r\n            this._total++;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Handler for Sprite vs. Group collisions.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - [description]\r\n     * @param {Phaser.GameObjects.Group} group - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    collideSpriteVsGroup: function (sprite, group, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var bodyA = sprite.body;\r\n\r\n        if (group.length === 0 || !bodyA || !bodyA.enable)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Does sprite collide with anything?\r\n\r\n        var i;\r\n        var len;\r\n        var bodyB;\r\n\r\n        if (this.useTree)\r\n        {\r\n            var minMax = this.treeMinMax;\r\n\r\n            minMax.minX = bodyA.left;\r\n            minMax.minY = bodyA.top;\r\n            minMax.maxX = bodyA.right;\r\n            minMax.maxY = bodyA.bottom;\r\n\r\n            var results = (group.physicsType === CONST.DYNAMIC_BODY) ? this.tree.search(minMax) : this.staticTree.search(minMax);\r\n\r\n            len = results.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                bodyB = results[i];\r\n\r\n                if (bodyA === bodyB || !group.contains(bodyB.gameObject))\r\n                {\r\n                    //  Skip if comparing against itself, or if bodyB isn't actually part of the Group\r\n                    continue;\r\n                }\r\n\r\n                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly))\r\n                {\r\n                    if (collideCallback)\r\n                    {\r\n                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\r\n                    }\r\n\r\n                    this._total++;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var children = group.getChildren();\r\n            var skipIndex = group.children.entries.indexOf(sprite);\r\n\r\n            len = children.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                bodyB = children[i].body;\r\n\r\n                if (!bodyB || i === skipIndex || !bodyB.enable)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly))\r\n                {\r\n                    if (collideCallback)\r\n                    {\r\n                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\r\n                    }\r\n\r\n                    this._total++;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Helper for Group vs. Tilemap collisions.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideGroupVsTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Group} group - [description]\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    collideGroupVsTilemapLayer: function (group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var children = group.getChildren();\r\n\r\n        if (children.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var didCollide = false;\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            if (children[i].body)\r\n            {\r\n                if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly))\r\n                {\r\n                    didCollide = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return didCollide;\r\n    },\r\n\r\n    /**\r\n     * Helper for Sprite vs. Tilemap collisions.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilemapLayer\r\n     * @fires Phaser.Physics.Arcade.World#collide\r\n     * @fires Phaser.Physics.Arcade.World#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - [description]\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    collideSpriteVsTilemapLayer: function (sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var body = sprite.body;\r\n\r\n        if (!body.enable)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var x = body.position.x;\r\n        var y = body.position.y;\r\n        var w = body.width;\r\n        var h = body.height;\r\n\r\n        // TODO: this logic should be encapsulated within the Tilemap API at some point.\r\n        // If the maps base tile size differs from the layer's tile size, we need to adjust the\r\n        // selection area by the difference between the two.\r\n        var layerData = tilemapLayer.layer;\r\n\r\n        if (layerData.tileWidth > layerData.baseTileWidth)\r\n        {\r\n            // The x origin of a tile is the left side, so x and width need to be adjusted.\r\n            var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;\r\n            x -= xDiff;\r\n            w += xDiff;\r\n        }\r\n\r\n        if (layerData.tileHeight > layerData.baseTileHeight)\r\n        {\r\n            // The y origin of a tile is the bottom side, so just the height needs to be adjusted.\r\n            var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;\r\n            h += yDiff;\r\n        }\r\n\r\n        var mapData = tilemapLayer.getTilesWithinWorldXY(x, y, w, h);\r\n\r\n        if (mapData.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var tile;\r\n        var tileWorldRect = { left: 0, right: 0, top: 0, bottom: 0 };\r\n\r\n        for (var i = 0; i < mapData.length; i++)\r\n        {\r\n            tile = mapData[i];\r\n            tileWorldRect.left = tilemapLayer.tileToWorldX(tile.x);\r\n            tileWorldRect.top = tilemapLayer.tileToWorldY(tile.y);\r\n\r\n            // If the map's base tile size differs from the layer's tile size, only the top of the rect\r\n            // needs to be adjusted since its origin is (0, 1).\r\n            if (tile.baseHeight !== tile.height)\r\n            {\r\n                tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;\r\n            }\r\n\r\n            tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;\r\n            tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;\r\n\r\n            if (TileIntersectsBody(tileWorldRect, body)\r\n                && (!processCallback || processCallback.call(callbackContext, sprite, tile))\r\n                && ProcessTileCallbacks(tile, sprite)\r\n                && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS)))\r\n            {\r\n                this._total++;\r\n\r\n                if (collideCallback)\r\n                {\r\n                    collideCallback.call(callbackContext, sprite, tile);\r\n                }\r\n\r\n                if (overlapOnly && body.onOverlap)\r\n                {\r\n                    sprite.emit('overlap', body.gameObject, tile, body, null);\r\n                }\r\n                else if (body.onCollide)\r\n                {\r\n                    sprite.emit('collide', body.gameObject, tile, body, null);\r\n                }\r\n\r\n                //  sync changes back to the body\r\n                body.postUpdate();\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Helper for Group vs. Group collisions.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideGroupVsGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Group} group1 - [description]\r\n     * @param {Phaser.GameObjects.Group} group2 - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    collideGroupVsGroup: function (group1, group2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        if (group1.length === 0 || group2.length === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var children = group1.getChildren();\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.\r\n     *\r\n     * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#wrap\r\n     * @since 3.3.0\r\n     *\r\n     * @param {*} object - A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.\r\n     * @param {number} [padding=0] - An amount added to each boundary edge during the operation.\r\n     */\r\n    wrap: function (object, padding)\r\n    {\r\n        if (object.body)\r\n        {\r\n            this.wrapObject(object, padding);\r\n        }\r\n        else if (object.getChildren)\r\n        {\r\n            this.wrapArray(object.getChildren(), padding);\r\n        }\r\n        else if (Array.isArray(object))\r\n        {\r\n            this.wrapArray(object, padding);\r\n        }\r\n        else\r\n        {\r\n            this.wrapObject(object, padding);\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#wrapArray\r\n     * @since 3.3.0\r\n     *\r\n     * @param {Array.<*>} objects - An array of objects to be wrapped.\r\n     * @param {number} [padding=0] - An amount added to the boundary.\r\n     */\r\n    wrapArray: function (objects, padding)\r\n    {\r\n        for (var i = 0; i < objects.length; i++)\r\n        {\r\n            this.wrapObject(objects[i], padding);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#wrapObject\r\n     * @since 3.3.0\r\n     *\r\n     * @param {*} object - A Game Object, a Physics Body, or any object with `x` and `y` coordinates\r\n     * @param {number} [padding=0] - An amount added to the boundary.\r\n     */\r\n    wrapObject: function (object, padding)\r\n    {\r\n        if (padding === undefined) { padding = 0; }\r\n\r\n        object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);\r\n        object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);\r\n    },\r\n\r\n    /**\r\n     * Shuts down the simulation, clearing physics data and removing listeners.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.tree.clear();\r\n        this.staticTree.clear();\r\n        this.bodies.clear();\r\n        this.staticBodies.clear();\r\n        this.colliders.destroy();\r\n\r\n        this.removeAllListeners();\r\n    },\r\n\r\n    /**\r\n     * Shuts down the simulation and disconnects it from the current scene.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = World;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Body","Clamp","Class","Collider","CONST","DistanceBetween","EventEmitter","FuzzyEqual","FuzzyGreaterThan","FuzzyLessThan","GetOverlapX","GetOverlapY","GetValue","ProcessQueue","ProcessTileCallbacks","Rectangle","RTree","SeparateTile","SeparateX","SeparateY","Set","StaticBody","TileIntersectsBody","TransformMatrix","Vector2","Wrap","World","Extends","initialize","scene","config","call","bodies","staticBodies","pendingDestroy","colliders","gravity","bounds","sys","game","width","height","checkCollision","up","down","left","right","fps","_elapsed","_frameTime","_frameTimeMS","stepsLastFrame","timeScale","OVERLAP_BIAS","TILE_BIAS","forceX","isPaused","_total","drawDebug","defaults","debugShowBody","debugShowStaticBody","debugShowVelocity","bodyDebugColor","staticBodyDebugColor","velocityDebugColor","maxEntries","useTree","tree","staticTree","treeMinMax","minX","minY","maxX","maxY","_tempMatrix","_tempMatrix2","createDebugGraphic","enable","object","bodyType","undefined","DYNAMIC_BODY","Array","isArray","i","length","entry","isParent","children","getChildren","c","child","enableBody","body","STATIC_BODY","add","physicsType","set","insert","disable","disableBody","remove","delete","graphic","graphics","x","y","setDepth","Number","MAX_VALUE","debugGraphic","setBounds","checkLeft","checkRight","checkUp","checkDown","setTo","setBoundsCollision","pause","emit","resume","addCollider","object1","object2","collideCallback","processCallback","callbackContext","collider","addOverlap","removeCollider","setFPS","framerate","update","time","delta","size","stepsThisFrame","fixedDelta","msPerFrame","step","entries","len","clear","load","active","postUpdate","dynamic","pending","willDrawDebug","dynamicTree","world","gameObject","updateMotion","allowRotation","computeAngularVelocity","computeVelocity","velocity","angularVelocity","acceleration","angularAcceleration","drag","angularDrag","max","maxAngular","allowDrag","rotation","velocityX","accelerationX","dragX","maxVelocity","velocityY","accelerationY","dragY","speed","useDamping","allowGravity","separate","body1","body2","overlapOnly","none","intersects","isCircle","separateCircle","bodyRect","bottom","circle","center","bodyCircle","resultY","resultX","Math","abs","result","onOverlap","onCollide","bias","angleCollision","atan2","overlap","position","halfWidth","radius","immovable","customSeparateX","b1vx","b1vy","b1mass","mass","b2vx","b2vy","b2mass","cos","sin","tempVel1","tempVel2","bounce","PI","circleBodyIntersects","top","overlapCallback","collideObjects","collide","object1isArray","object2isArray","collideHandler","j","collideGroupVsGroup","collideSpriteVsSprite","collideSpriteVsGroup","isTilemap","collideSpriteVsTilemapLayer","collideGroupVsTilemapLayer","sprite1","sprite2","sprite","group","bodyA","minMax","results","search","bodyB","contains","skipIndex","indexOf","tilemapLayer","didCollide","w","h","layerData","layer","tileWidth","baseTileWidth","xDiff","scaleX","tileHeight","baseTileHeight","scaleY","mapData","getTilesWithinWorldXY","tileWorldRect","tile","tileToWorldX","tileToWorldY","baseHeight","group1","group2","wrap","padding","wrapObject","wrapArray","objects","shutdown","destroy","removeAllListeners"]
}
