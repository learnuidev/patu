{
"version":3,
"file":"module$node_modules$Phaser$src$physics$arcade$Body.js",
"lineCount":24,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/arcade/Body.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$arcade$Body\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar CircleContains = require('../../geom/circle/Contains');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('./const');\r\nvar RadToDeg = require('../../math/RadToDeg');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar RectangleContains = require('../../geom/rectangle/Contains');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @typedef {object} ArcadeBodyBounds\r\n *\r\n * @property {number} x - The left edge.\r\n * @property {number} y - The upper edge.\r\n * @property {number} right - The right edge.\r\n * @property {number} bottom - The lower edge.\r\n */\r\n\r\n/**\r\n * @typedef {object} ArcadeBodyCollision\r\n *\r\n * @property {boolean} none - True if the Body is not colliding.\r\n * @property {boolean} up - True if the Body is colliding on its upper edge.\r\n * @property {boolean} down - True if the Body is colliding on its lower edge.\r\n * @property {boolean} left - True if the Body is colliding on its left edge.\r\n * @property {boolean} right - True if the Body is colliding on its right edge.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Dynamic Arcade Body.\r\n *\r\n * Its static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.\r\n *\r\n * @class Body\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics simulation this Body belongs to.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object this Body belongs to.\r\n */\r\nvar Body = new Class({\r\n\r\n    initialize:\r\n\r\n    function Body (world, gameObject)\r\n    {\r\n        var width = (gameObject.width) ? gameObject.width : 64;\r\n        var height = (gameObject.height) ? gameObject.height : 64;\r\n\r\n        /**\r\n         * The Arcade Physics simulation this Body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The Game Object this Body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameObject = gameObject;\r\n\r\n        /**\r\n         * Transformations applied to this Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#transform\r\n         * @type {object}\r\n         * @since 3.4.0\r\n         */\r\n        this.transform = {\r\n            x: gameObject.x,\r\n            y: gameObject.y,\r\n            rotation: gameObject.angle,\r\n            scaleX: gameObject.scaleX,\r\n            scaleY: gameObject.scaleY,\r\n            displayOriginX: gameObject.displayOriginX,\r\n            displayOriginY: gameObject.displayOriginY\r\n        };\r\n\r\n        /**\r\n         * Whether the Body's boundary is drawn to the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugShowBody\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugShowBody = world.defaults.debugShowBody;\r\n\r\n        /**\r\n         * Whether the Body's velocity is drawn to the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugShowVelocity\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugShowVelocity = world.defaults.debugShowVelocity;\r\n\r\n        /**\r\n         * The color of this Body on the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugBodyColor\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugBodyColor = world.defaults.bodyDebugColor;\r\n\r\n        /**\r\n         * Whether this Body is updated by the physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#enable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enable = true;\r\n\r\n        /**\r\n         * Whether this Body's boundary is circular (true) or rectangular (false).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#isCircle\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setCircle\r\n         */\r\n        this.isCircle = false;\r\n\r\n        /**\r\n         * If this Body is circular, this is the unscaled radius of the Body's boundary, as set by setCircle(), in source pixels.\r\n         * The true radius is equal to `halfWidth`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#radius\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setCircle\r\n         */\r\n        this.radius = 0;\r\n\r\n        /**\r\n         * The offset of this Body's position from its Game Object's position, in source pixels.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#offset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setOffset\r\n         */\r\n        this.offset = new Vector2();\r\n\r\n        /**\r\n         * The position of this Body within the simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.position = new Vector2(gameObject.x, gameObject.y);\r\n\r\n        /**\r\n         * The position of this Body during the previous step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#prev\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.prev = new Vector2(gameObject.x, gameObject.y);\r\n\r\n        /**\r\n         * Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowRotation\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.allowRotation = true;\r\n\r\n        /**\r\n         * This body's rotation, in degrees, based on its angular acceleration and angular velocity.\r\n         * The Body's rotation controls the `angle` of its Game Object.\r\n         * It doesn't rotate the Body's boundary, which is always an axis-aligned rectangle or a circle.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = gameObject.angle;\r\n\r\n        /**\r\n         * The Body's rotation, in degrees, during the previous step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#preRotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.preRotation = gameObject.angle;\r\n\r\n        /**\r\n         * The width of the Body's boundary, in pixels.\r\n         * If the Body is circular, this is also the Body's diameter.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#width\r\n         * @type {number}\r\n         * @default 64\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the Body's boundary, in pixels.\r\n         * If the Body is circular, this is also the Body's diameter.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#height\r\n         * @type {number}\r\n         * @default 64\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The unscaled width of the Body, in source pixels, as set by setSize().\r\n         * The default is the width of the Body's Game Object's texture frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#sourceWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setSize\r\n         */\r\n        this.sourceWidth = width;\r\n\r\n        /**\r\n         * The unscaled height of the Body, in source pixels, as set by setSize().\r\n         * The default is the height of the Body's Game Object's texture frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#sourceHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setSize\r\n         */\r\n        this.sourceHeight = height;\r\n\r\n        if (gameObject.frame)\r\n        {\r\n            this.sourceWidth = gameObject.frame.realWidth;\r\n            this.sourceHeight = gameObject.frame.realHeight;\r\n        }\r\n\r\n        /**\r\n         * Half the Body's width, in pixels.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#halfWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfWidth = Math.abs(width / 2);\r\n\r\n        /**\r\n         * Half the Body's height, in pixels.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#halfHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfHeight = Math.abs(height / 2);\r\n\r\n        /**\r\n         * The center of the Body's boundary.\r\n         * The midpoint of its `position` (top-left corner) and its bottom-right corner.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#center\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.center = new Vector2(gameObject.x + this.halfWidth, gameObject.y + this.halfHeight);\r\n\r\n        /**\r\n         * The Body's velocity, in pixels per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#velocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.velocity = new Vector2();\r\n\r\n        /**\r\n         * The Body's calculated velocity, in pixels per second, at the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#newVelocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */\r\n        this.newVelocity = new Vector2();\r\n\r\n        /**\r\n         * The Body's absolute maximum change in position, in pixels per step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#deltaMax\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.deltaMax = new Vector2();\r\n\r\n        /**\r\n         * The Body's change in velocity, in pixels per second squared.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#acceleration\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.acceleration = new Vector2();\r\n\r\n        /**\r\n         * Whether this Body's velocity is affected by its `drag`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowDrag\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.allowDrag = true;\r\n\r\n        /**\r\n         * Absolute loss of velocity due to movement, in pixels per second squared.\r\n         * The x and y components are applied separately.\r\n         *\r\n         * When `useDamping` is true, this is 1 minus the damping factor.\r\n         * A value of 1 means the Body loses no velocity.\r\n         * A value of 0.95 means the Body loses 5% of its velocity per step.\r\n         * A value of 0.5 means the Body loses 50% of its velocity per step.\r\n         *\r\n         * Drag is applied only when `acceleration` is zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#drag\r\n         * @type {(Phaser.Math.Vector2|number)}\r\n         * @since 3.0.0\r\n         */\r\n        this.drag = new Vector2();\r\n\r\n        /**\r\n         * Whether this Body's position is affected by gravity (local or world).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowGravity\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#gravity\r\n         * @see Phaser.Physics.Arcade.World#gravity\r\n         */\r\n        this.allowGravity = true;\r\n\r\n        /**\r\n         * Acceleration due to gravity (specific to this Body), in pixels per second squared.\r\n         * Total gravity is the sum of this vector and the simulation's `gravity`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#gravity\r\n         */\r\n        this.gravity = new Vector2();\r\n\r\n        /**\r\n         * Rebound following a collision, relative to 1.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#bounce\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.bounce = new Vector2();\r\n\r\n        /**\r\n         * Rebound following a collision with the world boundary, relative to 1.\r\n         * If null, `bounce` is used instead.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#worldBounce\r\n         * @type {?Phaser.Math.Vector2}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.worldBounce = null;\r\n\r\n        //  If true this Body will dispatch events\r\n\r\n        /**\r\n         * Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#event:worldbounds\r\n         */\r\n        this.onWorldBounds = false;\r\n\r\n        /**\r\n         * Whether the simulation emits a `collide` event when this Body collides with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onCollide\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#event:collide\r\n         */\r\n        this.onCollide = false;\r\n\r\n        /**\r\n         * Whether the simulation emits an `overlap` event when this Body overlaps with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onOverlap\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#event:overlap\r\n         */\r\n        this.onOverlap = false;\r\n\r\n        /**\r\n         * The Body's absolute maximum velocity, in pixels per second.\r\n         * The horizontal and vertical components are applied separately.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxVelocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocity = new Vector2(10000, 10000);\r\n\r\n        /**\r\n         * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\r\n         * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.\r\n         * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.\r\n         * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#friction\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.friction = new Vector2(1, 0);\r\n\r\n        /**\r\n         * If this Body is using `drag` for deceleration this property controls how the drag is applied.\r\n         * If set to `true` drag will use a damping effect rather than a linear approach. If you are\r\n         * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\r\n         * the game Asteroids) then you will get a far smoother and more visually correct deceleration\r\n         * by using damping, avoiding the axis-drift that is prone with linear deceleration.\r\n         *\r\n         * If you enable this property then you should use far smaller `drag` values than with linear, as\r\n         * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow\r\n         * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#useDamping\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.10.0\r\n         */\r\n        this.useDamping = false;\r\n\r\n        /**\r\n         * The rate of change of this Body's `rotation`, in degrees per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularVelocity\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angularVelocity = 0;\r\n\r\n        /**\r\n         * The Body's angular acceleration (change in angular velocity), in degrees per second squared.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularAcceleration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angularAcceleration = 0;\r\n\r\n        /**\r\n         * Loss of angular velocity due to angular movement, in degrees per second.\r\n         *\r\n         * Angular drag is applied only when angular acceleration is zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularDrag\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angularDrag = 0;\r\n\r\n        /**\r\n         * The Body's maximum angular velocity, in degrees per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxAngular\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxAngular = 1000;\r\n\r\n        /**\r\n         * The Body's inertia, relative to a default unit (1).\r\n         * With `bounce`, this affects the exchange of momentum (velocities) during collisions.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#mass\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.mass = 1;\r\n\r\n        /**\r\n         * The calculated angle of this Body's velocity vector, in degrees, during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angle\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angle = 0;\r\n\r\n        /**\r\n         * The calculated magnitude of the Body's velocity, in pixels per second, during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#speed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.speed = 0;\r\n\r\n        /**\r\n         * The direction of the Body's velocity, as calculated during the last step.\r\n         * If the Body is moving on both axes (diagonally), this describes motion on the vertical axis only.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#facing\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.facing = CONST.FACING_NONE;\r\n\r\n        /**\r\n         * Whether this Body can be moved by collisions with another Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#immovable\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.immovable = false;\r\n\r\n        /**\r\n         * Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#moves\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.moves = true;\r\n\r\n        /**\r\n         * A flag disabling the default horizontal separation of colliding bodies.\r\n         * Pass your own `collideCallback` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customSeparateX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateX = false;\r\n\r\n        /**\r\n         * A flag disabling the default vertical separation of colliding bodies.\r\n         * Pass your own `collideCallback` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customSeparateY\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateY = false;\r\n\r\n        /**\r\n         * The amount of horizontal overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapX = 0;\r\n\r\n        /**\r\n         * The amount of vertical overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapY = 0;\r\n\r\n        /**\r\n         * The amount of overlap (before separation), if this Body is circular and colliding with another circular body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapR\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapR = 0;\r\n\r\n        /**\r\n         * Whether this Body is overlapped with another and both have zero velocity.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#embedded\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.embedded = false;\r\n\r\n        /**\r\n         * Whether this Body interacts with the world boundary.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#collideWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.collideWorldBounds = false;\r\n\r\n        /**\r\n         * Whether this Body is checked for collisions and for which directions.\r\n         * You can set `checkCollision.none = false` to disable collision checks.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#checkCollision\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.checkCollision = { none: false, up: true, down: true, left: true, right: true };\r\n\r\n        /**\r\n         * Whether this Body is colliding with another and in which direction.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#touching\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.touching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * Whether this Body was colliding with another during the last step, and in which direction.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#wasTouching\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.wasTouching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * Whether this Body is colliding with a tile or the world boundary.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#blocked\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.blocked = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * Whether to automatically synchronize this Body's dimensions to the dimensions of its Game Object's visual bounds.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#syncBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Components.GetBounds#getBounds\r\n         */\r\n        this.syncBounds = false;\r\n\r\n        /**\r\n         * Whether this Body is being moved by the `moveTo` or `moveFrom` methods.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#isMoving\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isMoving = false;\r\n\r\n        /**\r\n         * Whether this Body's movement by `moveTo` or `moveFrom` will be stopped by collisions with other bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#stopVelocityOnCollide\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.stopVelocityOnCollide = true;\r\n\r\n        //  read-only\r\n\r\n        /**\r\n         * The Body's physics type (dynamic or static).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#physicsType\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */\r\n        this.physicsType = CONST.DYNAMIC_BODY;\r\n\r\n        /**\r\n         * Whether the Body's position needs updating from its Game Object.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_reset\r\n         * @type {boolean}\r\n         * @private\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this._reset = true;\r\n\r\n        /**\r\n         * Cached horizontal scale of the Body's Game Object.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_sx\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._sx = gameObject.scaleX;\r\n\r\n        /**\r\n         * Cached vertical scale of the Body's Game Object.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_sy\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._sy = gameObject.scaleY;\r\n\r\n        /**\r\n         * The calculated change in the Body's horizontal position during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_dx\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._dx = 0;\r\n\r\n        /**\r\n         * The calculated change in the Body's vertical position during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_dy\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._dy = 0;\r\n\r\n        /**\r\n         * Stores the Game Object's bounds.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._bounds = new Rectangle();\r\n    },\r\n\r\n    /**\r\n     * Updates this Body's transform, dimensions, and position from its Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#updateBounds\r\n     * @since 3.0.0\r\n     */\r\n    updateBounds: function ()\r\n    {\r\n        var sprite = this.gameObject;\r\n\r\n        //  Container?\r\n\r\n        var transform = this.transform;\r\n\r\n        if (sprite.parentContainer)\r\n        {\r\n            var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);\r\n\r\n            transform.x = matrix.tx;\r\n            transform.y = matrix.ty;\r\n            transform.rotation = RadToDeg(matrix.rotation);\r\n            transform.scaleX = matrix.scaleX;\r\n            transform.scaleY = matrix.scaleY;\r\n            transform.displayOriginX = sprite.displayOriginX;\r\n            transform.displayOriginY = sprite.displayOriginY;\r\n        }\r\n        else\r\n        {\r\n            transform.x = sprite.x;\r\n            transform.y = sprite.y;\r\n            transform.rotation = sprite.angle;\r\n            transform.scaleX = sprite.scaleX;\r\n            transform.scaleY = sprite.scaleY;\r\n            transform.displayOriginX = sprite.displayOriginX;\r\n            transform.displayOriginY = sprite.displayOriginY;\r\n        }\r\n\r\n        var recalc = false;\r\n\r\n        if (this.syncBounds)\r\n        {\r\n            var b = sprite.getBounds(this._bounds);\r\n\r\n            this.width = b.width;\r\n            this.height = b.height;\r\n            recalc = true;\r\n        }\r\n        else\r\n        {\r\n            var asx = Math.abs(transform.scaleX);\r\n            var asy = Math.abs(transform.scaleY);\r\n\r\n            if (this._sx !== asx || this._sy !== asy)\r\n            {\r\n                this.width = this.sourceWidth * asx;\r\n                this.height = this.sourceHeight * asy;\r\n                this._sx = asx;\r\n                this._sy = asy;\r\n                recalc = true;\r\n            }\r\n        }\r\n\r\n        if (recalc)\r\n        {\r\n            this.halfWidth = Math.floor(this.width / 2);\r\n            this.halfHeight = Math.floor(this.height / 2);\r\n            this.updateCenter();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Updates the Body's `center` from its `position`, `width`, and `height`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#updateCenter\r\n     * @since 3.0.0\r\n     */\r\n    updateCenter: function ()\r\n    {\r\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\r\n    },\r\n\r\n    /**\r\n     * Updates the Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#update\r\n     * @fires Phaser.Physics.Arcade.World#worldbounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (delta)\r\n    {\r\n        //  Store and reset collision flags\r\n        this.wasTouching.none = this.touching.none;\r\n        this.wasTouching.up = this.touching.up;\r\n        this.wasTouching.down = this.touching.down;\r\n        this.wasTouching.left = this.touching.left;\r\n        this.wasTouching.right = this.touching.right;\r\n\r\n        this.touching.none = true;\r\n        this.touching.up = false;\r\n        this.touching.down = false;\r\n        this.touching.left = false;\r\n        this.touching.right = false;\r\n\r\n        this.blocked.none = true;\r\n        this.blocked.up = false;\r\n        this.blocked.down = false;\r\n        this.blocked.left = false;\r\n        this.blocked.right = false;\r\n\r\n        this.overlapR = 0;\r\n        this.overlapX = 0;\r\n        this.overlapY = 0;\r\n\r\n        this.embedded = false;\r\n\r\n        //  Updates the transform values\r\n        this.updateBounds();\r\n\r\n        var sprite = this.transform;\r\n\r\n        this.position.x = sprite.x + sprite.scaleX * (this.offset.x - sprite.displayOriginX);\r\n        this.position.y = sprite.y + sprite.scaleY * (this.offset.y - sprite.displayOriginY);\r\n\r\n        this.updateCenter();\r\n\r\n        this.rotation = sprite.rotation;\r\n\r\n        this.preRotation = this.rotation;\r\n\r\n        if (this._reset)\r\n        {\r\n            this.prev.x = this.position.x;\r\n            this.prev.y = this.position.y;\r\n        }\r\n\r\n        if (this.moves)\r\n        {\r\n            this.world.updateMotion(this, delta);\r\n\r\n            var vx = this.velocity.x;\r\n            var vy = this.velocity.y;\r\n\r\n            this.newVelocity.set(vx * delta, vy * delta);\r\n\r\n            this.position.add(this.newVelocity);\r\n\r\n            this.updateCenter();\r\n\r\n            this.angle = Math.atan2(vy, vx);\r\n            this.speed = Math.sqrt(vx * vx + vy * vy);\r\n\r\n            //  Now the State update will throw collision checks at the Body\r\n            //  And finally we'll integrate the new position back to the Sprite in postUpdate\r\n\r\n            if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds)\r\n            {\r\n                this.world.emit('worldbounds', this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);\r\n            }\r\n        }\r\n\r\n        this._dx = this.position.x - this.prev.x;\r\n        this._dy = this.position.y - this.prev.y;\r\n    },\r\n\r\n    /**\r\n     * Feeds the Body results back into the parent Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#postUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} resetDelta - Reset the delta properties?\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n        this._dx = this.position.x - this.prev.x;\r\n        this._dy = this.position.y - this.prev.y;\r\n\r\n        if (this.moves)\r\n        {\r\n            if (this.deltaMax.x !== 0 && this._dx !== 0)\r\n            {\r\n                if (this._dx < 0 && this._dx < -this.deltaMax.x)\r\n                {\r\n                    this._dx = -this.deltaMax.x;\r\n                }\r\n                else if (this._dx > 0 && this._dx > this.deltaMax.x)\r\n                {\r\n                    this._dx = this.deltaMax.x;\r\n                }\r\n            }\r\n\r\n            if (this.deltaMax.y !== 0 && this._dy !== 0)\r\n            {\r\n                if (this._dy < 0 && this._dy < -this.deltaMax.y)\r\n                {\r\n                    this._dy = -this.deltaMax.y;\r\n                }\r\n                else if (this._dy > 0 && this._dy > this.deltaMax.y)\r\n                {\r\n                    this._dy = this.deltaMax.y;\r\n                }\r\n            }\r\n\r\n            this.gameObject.x += this._dx;\r\n            this.gameObject.y += this._dy;\r\n\r\n            this._reset = true;\r\n        }\r\n\r\n        if (this._dx < 0)\r\n        {\r\n            this.facing = CONST.FACING_LEFT;\r\n        }\r\n        else if (this._dx > 0)\r\n        {\r\n            this.facing = CONST.FACING_RIGHT;\r\n        }\r\n\r\n        if (this._dy < 0)\r\n        {\r\n            this.facing = CONST.FACING_UP;\r\n        }\r\n        else if (this._dy > 0)\r\n        {\r\n            this.facing = CONST.FACING_DOWN;\r\n        }\r\n\r\n        if (this.allowRotation)\r\n        {\r\n            this.gameObject.angle += this.deltaZ();\r\n        }\r\n\r\n        this.prev.x = this.position.x;\r\n        this.prev.y = this.position.y;\r\n    },\r\n\r\n    /**\r\n     * Checks for collisions between this Body and the world boundary and separates them.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#checkWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if this Body is colliding with the world boundary.\r\n     */\r\n    checkWorldBounds: function ()\r\n    {\r\n        var pos = this.position;\r\n        var bounds = this.world.bounds;\r\n        var check = this.world.checkCollision;\r\n\r\n        var bx = (this.worldBounce) ? -this.worldBounce.x : -this.bounce.x;\r\n        var by = (this.worldBounce) ? -this.worldBounce.y : -this.bounce.y;\r\n\r\n        if (pos.x < bounds.x && check.left)\r\n        {\r\n            pos.x = bounds.x;\r\n            this.velocity.x *= bx;\r\n            this.blocked.left = true;\r\n            this.blocked.none = false;\r\n        }\r\n        else if (this.right > bounds.right && check.right)\r\n        {\r\n            pos.x = bounds.right - this.width;\r\n            this.velocity.x *= bx;\r\n            this.blocked.right = true;\r\n            this.blocked.none = false;\r\n        }\r\n\r\n        if (pos.y < bounds.y && check.up)\r\n        {\r\n            pos.y = bounds.y;\r\n            this.velocity.y *= by;\r\n            this.blocked.up = true;\r\n            this.blocked.none = false;\r\n        }\r\n        else if (this.bottom > bounds.bottom && check.down)\r\n        {\r\n            pos.y = bounds.bottom - this.height;\r\n            this.velocity.y *= by;\r\n            this.blocked.down = true;\r\n            this.blocked.none = false;\r\n        }\r\n\r\n        return !this.blocked.none;\r\n    },\r\n\r\n    /**\r\n     * Sets the offset of the Body's position from its Game Object's position.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal offset, in source pixels.\r\n     * @param {number} [y=x] - The vertical offset, in source pixels.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setOffset: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.offset.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sizes and positions this Body's boundary, as a rectangle.\r\n     * Modifies the Body `offset` if `center` is true (the default).\r\n     * Resets the width and height to match current frame, if no width and height provided and a frame is found.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [width] - The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\r\n     * @param {integer} [height] - The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\r\n     * @param {boolean} [center=true] - Modify the Body's `offset`, placing the Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setSize: function (width, height, center)\r\n    {\r\n        if (center === undefined) { center = true; }\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        if (!width && gameObject.frame)\r\n        {\r\n            width = gameObject.frame.realWidth;\r\n        }\r\n\r\n        if (!height && gameObject.frame)\r\n        {\r\n            height = gameObject.frame.realHeight;\r\n        }\r\n\r\n        this.sourceWidth = width;\r\n        this.sourceHeight = height;\r\n\r\n        this.width = this.sourceWidth * this._sx;\r\n        this.height = this.sourceHeight * this._sy;\r\n\r\n        this.halfWidth = Math.floor(this.width / 2);\r\n        this.halfHeight = Math.floor(this.height / 2);\r\n\r\n        this.updateCenter();\r\n\r\n        if (center && gameObject.getCenter)\r\n        {\r\n            var ox = gameObject.displayWidth / 2;\r\n            var oy = gameObject.displayHeight / 2;\r\n\r\n            this.offset.set(ox - this.halfWidth, oy - this.halfHeight);\r\n        }\r\n\r\n        this.isCircle = false;\r\n        this.radius = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sizes and positions this Body's boundary, as a circle.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The radius of the Body, in source pixels.\r\n     * @param {number} [offsetX] - The horizontal offset of the Body from its Game Object, in source pixels.\r\n     * @param {number} [offsetY] - The vertical offset of the Body from its Game Object, in source pixels.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setCircle: function (radius, offsetX, offsetY)\r\n    {\r\n        if (offsetX === undefined) { offsetX = this.offset.x; }\r\n        if (offsetY === undefined) { offsetY = this.offset.y; }\r\n\r\n        if (radius > 0)\r\n        {\r\n            this.isCircle = true;\r\n            this.radius = radius;\r\n\r\n            this.sourceWidth = radius * 2;\r\n            this.sourceHeight = radius * 2;\r\n\r\n            this.width = this.sourceWidth * this._sx;\r\n            this.height = this.sourceHeight * this._sy;\r\n\r\n            this.halfWidth = Math.floor(this.width / 2);\r\n            this.halfHeight = Math.floor(this.height / 2);\r\n\r\n            this.offset.set(offsetX, offsetY);\r\n\r\n            this.updateCenter();\r\n        }\r\n        else\r\n        {\r\n            this.isCircle = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.\r\n     * If the Body had any velocity or acceleration it is lost as a result of calling this.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position to place the Game Object and Body.\r\n     * @param {number} y - The vertical position to place the Game Object and Body.\r\n     */\r\n    reset: function (x, y)\r\n    {\r\n        this.stop();\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        gameObject.setPosition(x, y);\r\n\r\n        gameObject.getTopLeft(this.position);\r\n\r\n        this.prev.copy(this.position);\r\n\r\n        this.rotation = gameObject.angle;\r\n        this.preRotation = gameObject.angle;\r\n\r\n        this.updateBounds();\r\n        this.updateCenter();\r\n    },\r\n\r\n    /**\r\n     * Sets acceleration, velocity, and speed to zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    stop: function ()\r\n    {\r\n        this.velocity.set(0);\r\n        this.acceleration.set(0);\r\n        this.speed = 0;\r\n        this.angularVelocity = 0;\r\n        this.angularAcceleration = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copies the coordinates of this Body's edges into an object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeBodyBounds} obj - An object to copy the values into.\r\n     *\r\n     * @return {ArcadeBodyBounds} - An object with {x, y, right, bottom}.\r\n     */\r\n    getBounds: function (obj)\r\n    {\r\n        obj.x = this.x;\r\n        obj.y = this.y;\r\n        obj.right = this.right;\r\n        obj.bottom = this.bottom;\r\n\r\n        return obj;\r\n    },\r\n\r\n    /**\r\n     * Tests if the coordinates are within this Body's boundary.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate.\r\n     * @param {number} y - The vertical coordinate.\r\n     *\r\n     * @return {boolean} True if (x, y) is within this Body.\r\n     */\r\n    hitTest: function (x, y)\r\n    {\r\n        return (this.isCircle) ? CircleContains(this, x, y) : RectangleContains(this, x, y);\r\n    },\r\n\r\n    /**\r\n     * Whether this Body is touching a tile or the world boundary while moving down.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onFloor\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     *\r\n     * @return {boolean} True if touching.\r\n     */\r\n    onFloor: function ()\r\n    {\r\n        return this.blocked.down;\r\n    },\r\n\r\n    /**\r\n     * Whether this Body is touching a tile or the world boundary while moving up.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onCeiling\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     *\r\n     * @return {boolean} True if touching.\r\n     */\r\n    onCeiling: function ()\r\n    {\r\n        return this.blocked.up;\r\n    },\r\n\r\n    /**\r\n     * Whether this Body is touching a tile or the world boundary while moving left or right.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onWall\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     *\r\n     * @return {boolean} True if touching.\r\n     */\r\n    onWall: function ()\r\n    {\r\n        return (this.blocked.left || this.blocked.right);\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this Body's horizontal position from the previous step.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaAbsX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaAbsX: function ()\r\n    {\r\n        return (this._dx > 0) ? this._dx : -this._dx;\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this Body's vertical position from the previous step.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaAbsY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaAbsY: function ()\r\n    {\r\n        return (this._dy > 0) ? this._dy : -this._dy;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's horizontal position from the previous step.\r\n     * This value is set during the Body's update phase.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaX: function ()\r\n    {\r\n        return this._dx;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's vertical position from the previous step.\r\n     * This value is set during the Body's update phase.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaY: function ()\r\n    {\r\n        return this._dy;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's rotation from the previous step, in degrees.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaZ\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaZ: function ()\r\n    {\r\n        return this.rotation - this.preRotation;\r\n    },\r\n\r\n    /**\r\n     * Disables this Body and marks it for deletion by the simulation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.enable = false;\r\n\r\n        this.world.pendingDestroy.set(this);\r\n    },\r\n\r\n    /**\r\n     * Draws this Body's boundary and velocity, if enabled.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#drawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to draw on.\r\n     */\r\n    drawDebug: function (graphic)\r\n    {\r\n        var pos = this.position;\r\n\r\n        var x = pos.x + this.halfWidth;\r\n        var y = pos.y + this.halfHeight;\r\n\r\n        if (this.debugShowBody)\r\n        {\r\n            graphic.lineStyle(1, this.debugBodyColor);\r\n\r\n            if (this.isCircle)\r\n            {\r\n                graphic.strokeCircle(x, y, this.width / 2);\r\n            }\r\n            else\r\n            {\r\n                graphic.strokeRect(pos.x, pos.y, this.width, this.height);\r\n            }\r\n        }\r\n\r\n        if (this.debugShowVelocity)\r\n        {\r\n            graphic.lineStyle(1, this.world.defaults.velocityDebugColor, 1);\r\n            graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Whether this Body will be drawn to the debug display.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#willDrawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if either `debugShowBody` or `debugShowVelocity` are enabled.\r\n     */\r\n    willDrawDebug: function ()\r\n    {\r\n        return (this.debugShowBody || this.debugShowVelocity);\r\n    },\r\n\r\n    /**\r\n     * Sets whether this Body collides with the world boundary.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - True (collisions) or false (no collisions).\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setCollideWorldBounds: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.collideWorldBounds = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal velocity, in pixels per second.\r\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setVelocity: function (x, y)\r\n    {\r\n        this.velocity.set(x, y);\r\n\r\n        this.speed = Math.sqrt(x * x + y * y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setVelocityX: function (value)\r\n    {\r\n        this.velocity.x = value;\r\n\r\n        var vx = value;\r\n        var vy = this.velocity.y;\r\n\r\n        this.speed = Math.sqrt(vx * vx + vy * vy);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setVelocityY: function (value)\r\n    {\r\n        this.velocity.y = value;\r\n\r\n        var vx = this.velocity.x;\r\n        var vy = value;\r\n\r\n        this.speed = Math.sqrt(vx * vx + vy * vy);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's maximum velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMaxVelocity\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} x - The horizontal velocity, in pixels per second.\r\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMaxVelocity: function (x, y)\r\n    {\r\n        this.maxVelocity.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's bounce.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal bounce, relative to 1.\r\n     * @param {number} y - The vertical bounce, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setBounce: function (x, y)\r\n    {\r\n        this.bounce.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal bounce.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounceX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The bounce, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setBounceX: function (value)\r\n    {\r\n        this.bounce.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical bounce.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounceY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The bounce, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setBounceY: function (value)\r\n    {\r\n        this.bounce.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, in pixels per second squared.\r\n     * @param {number} y - The vertical component, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAcceleration: function (x, y)\r\n    {\r\n        this.acceleration.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAccelerationX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The acceleration, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAccelerationX: function (value)\r\n    {\r\n        this.acceleration.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAccelerationY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The acceleration, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAccelerationY: function (value)\r\n    {\r\n        this.acceleration.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAllowDrag\r\n     * @since 3.9.0\r\n     * @see Phaser.Physics.Arcade.Body#allowDrag\r\n     *\r\n     * @param {boolean} [value=true] - `true` to allow drag on this body, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAllowDrag: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.allowDrag = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables gravity's effect on this Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAllowGravity\r\n     * @since 3.9.0\r\n     * @see Phaser.Physics.Arcade.Body#allowGravity\r\n     *\r\n     * @param {boolean} [value=true] - `true` to allow gravity on this body, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAllowGravity: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.allowGravity = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables rotation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAllowRotation\r\n     * @since 3.9.0\r\n     * @see Phaser.Physics.Arcade.Body#allowRotation\r\n     *\r\n     * @param {boolean} [value=true] - `true` to allow rotation on this body, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAllowRotation: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.allowRotation = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, in pixels per second squared.\r\n     * @param {number} y - The vertical component, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDrag: function (x, y)\r\n    {\r\n        this.drag.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDragX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The drag, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDragX: function (value)\r\n    {\r\n        this.drag.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDragY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The drag, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDragY: function (value)\r\n    {\r\n        this.drag.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's gravity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, in pixels per second squared.\r\n     * @param {number} y - The vertical component, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setGravity: function (x, y)\r\n    {\r\n        this.gravity.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal gravity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The gravity, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setGravityX: function (value)\r\n    {\r\n        this.gravity.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical gravity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The gravity, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setGravityY: function (value)\r\n    {\r\n        this.gravity.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's friction.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFriction\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, relative to 1.\r\n     * @param {number} y - The vertical component, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setFriction: function (x, y)\r\n    {\r\n        this.friction.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal friction.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFrictionX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The friction value, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setFrictionX: function (value)\r\n    {\r\n        this.friction.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical friction.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFrictionY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The friction value, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setFrictionY: function (value)\r\n    {\r\n        this.friction.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's angular velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity, in degrees per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAngularVelocity: function (value)\r\n    {\r\n        this.angularVelocity = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's angular acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The acceleration, in degrees per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAngularAcceleration: function (value)\r\n    {\r\n        this.angularAcceleration = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's angular drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The drag, in degrees per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAngularDrag: function (value)\r\n    {\r\n        this.angularDrag = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's mass.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The mass value, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMass: function (value)\r\n    {\r\n        this.mass = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's `immovable` property.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setImmovable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - The value to assign to `immovable`.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setImmovable: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.immovable = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The Body's horizontal position (left edge).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.position.x = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Body's vertical position (top edge).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.position.y = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The left edge of the Body's boundary. Identical to x.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#left\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The right edge of the Body's boundary.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#right\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x + this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The top edge of the Body's boundary. Identical to y.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#top\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    top: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The bottom edge of this Body's boundary.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#bottom\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */\r\n    bottom: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y + this.height;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Body;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","CircleContains","Class","CONST","RadToDeg","Rectangle","RectangleContains","Vector2","Body","initialize","world","gameObject","width","height","transform","x","y","rotation","angle","scaleX","scaleY","displayOriginX","displayOriginY","debugShowBody","defaults","debugShowVelocity","debugBodyColor","bodyDebugColor","enable","isCircle","radius","offset","position","prev","allowRotation","preRotation","sourceWidth","sourceHeight","frame","realWidth","realHeight","halfWidth","Math","abs","halfHeight","center","velocity","newVelocity","deltaMax","acceleration","allowDrag","drag","allowGravity","gravity","bounce","worldBounce","onOverlap","onCollide","onWorldBounds","maxVelocity","friction","useDamping","angularDrag","angularAcceleration","angularVelocity","maxAngular","mass","speed","facing","FACING_NONE","immovable","moves","customSeparateY","customSeparateX","overlapR","overlapY","overlapX","collideWorldBounds","embedded","checkCollision","none","up","down","left","right","touching","wasTouching","blocked","isMoving","syncBounds","stopVelocityOnCollide","physicsType","DYNAMIC_BODY","_reset","_sx","_sy","_dy","_dx","_bounds","updateBounds","sprite","parentContainer","matrix","getWorldTransformMatrix","_tempMatrix","_tempMatrix2","tx","ty","recalc","b","getBounds","asx","asy","floor","updateCenter","set","update","delta","updateMotion","vx","vy","add","atan2","sqrt","checkWorldBounds","emit","postUpdate","FACING_LEFT","FACING_RIGHT","FACING_UP","FACING_DOWN","deltaZ","pos","bounds","check","bx","by","bottom","setOffset","undefined","setSize","getCenter","displayWidth","displayHeight","setCircle","offsetX","offsetY","reset","stop","setPosition","getTopLeft","copy","obj","hitTest","onFloor","onCeiling","onWall","deltaAbsX","deltaAbsY","deltaX","deltaY","destroy","pendingDestroy","drawDebug","graphic","lineStyle","strokeCircle","strokeRect","velocityDebugColor","lineBetween","willDrawDebug","setCollideWorldBounds","value","setVelocity","setVelocityX","setVelocityY","setMaxVelocity","setBounce","setBounceX","setBounceY","setAcceleration","setAccelerationX","setAccelerationY","setAllowDrag","setAllowGravity","setAllowRotation","setDrag","setDragX","setDragY","setGravity","setGravityX","setGravityY","setFriction","setFrictionX","setFrictionY","setAngularVelocity","setAngularAcceleration","setAngularDrag","setMass","setImmovable","get","top"]
}
