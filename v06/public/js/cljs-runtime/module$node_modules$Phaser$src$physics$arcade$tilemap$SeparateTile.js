shadow$provide.module$node_modules$Phaser$src$physics$arcade$tilemap$SeparateTile=function(global,require,module,exports){var TileCheckX=require("module$node_modules$Phaser$src$physics$arcade$tilemap$TileCheckX"),TileCheckY=require("module$node_modules$Phaser$src$physics$arcade$tilemap$TileCheckY"),TileIntersectsBody=require("module$node_modules$Phaser$src$physics$arcade$tilemap$TileIntersectsBody");module.exports=function(i,body,tile,tileWorldRect,tilemapLayer,tileBias){i=tileWorldRect.left;tilemapLayer=
tileWorldRect.top;var tileRight=tileWorldRect.right,tileBottom=tileWorldRect.bottom,faceHorizontal=tile.faceLeft||tile.faceRight,faceVertical=tile.faceTop||tile.faceBottom;if(!faceHorizontal&&!faceVertical)return!1;var ox=0,oy=0,minX=0,minY=1;body.deltaAbsX()>body.deltaAbsY()?minX=-1:body.deltaAbsX()<body.deltaAbsY()&&(minY=-1);0!==body.deltaX()&&0!==body.deltaY()&&faceHorizontal&&faceVertical&&(minX=Math.min(Math.abs(body.position.x-tileRight),Math.abs(body.right-i)),minY=Math.min(Math.abs(body.position.y-
tileBottom),Math.abs(body.bottom-tilemapLayer)));if(minX<minY){if(faceHorizontal&&(ox=TileCheckX(body,tile,i,tileRight,tileBias),0!==ox&&!TileIntersectsBody(tileWorldRect,body)))return!0;faceVertical&&(oy=TileCheckY(body,tile,tilemapLayer,tileBottom,tileBias))}else{if(faceVertical&&(oy=TileCheckY(body,tile,tilemapLayer,tileBottom,tileBias),0!==oy&&!TileIntersectsBody(tileWorldRect,body)))return!0;faceHorizontal&&(ox=TileCheckX(body,tile,i,tileRight,tileBias))}return 0!==ox||0!==oy}}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$arcade$tilemap$SeparateTile.js.map
