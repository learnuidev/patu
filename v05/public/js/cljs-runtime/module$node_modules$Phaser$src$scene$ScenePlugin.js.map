{
"version":3,
"file":"module$node_modules$Phaser$src$scene$ScenePlugin.js",
"lineCount":12,
"mappings":"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",
"sources":["node_modules/Phaser/src/scene/ScenePlugin.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$scene$ScenePlugin\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Clamp = require('../math/Clamp');\r\nvar Class = require('../utils/Class');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar PluginCache = require('../plugins/PluginCache');\r\n\r\n/**\r\n * @classdesc\r\n * A proxy class to the Global Scene Manager.\r\n *\r\n * @class ScenePlugin\r\n * @memberOf Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this ScenePlugin belongs to.\r\n */\r\nvar ScenePlugin = new Class({\r\n\r\n    initialize:\r\n\r\n    function ScenePlugin (scene)\r\n    {\r\n        /**\r\n         * The Scene that this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene Systems instance of the Scene that this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The settings of the Scene this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#settings\r\n         * @type {Phaser.Scenes.Settings.Object}\r\n         * @since 3.0.0\r\n         */\r\n        this.settings = scene.sys.settings;\r\n\r\n        /**\r\n         * The key of the Scene this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = scene.sys.settings.key;\r\n\r\n        /**\r\n         * The Game's SceneManager.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#manager\r\n         * @type {Phaser.Scenes.SceneManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = scene.sys.game.scene;\r\n\r\n        /**\r\n         * If this Scene is currently transitioning to another, this holds\r\n         * the current percentage of the transition progress, between 0 and 1.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#transitionProgress\r\n         * @type {number}\r\n         * @since 3.5.0\r\n         */\r\n        this.transitionProgress = 0;\r\n\r\n        /**\r\n         * Transition elapsed timer.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_elapsed\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * Transition elapsed timer.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_target\r\n         * @type {?Phaser.Scenes.Scene}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._target = null;\r\n\r\n        /**\r\n         * Transition duration.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_duration\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._duration = 0;\r\n\r\n        /**\r\n         * Transition callback.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_onUpdate\r\n         * @type {function}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdate;\r\n\r\n        /**\r\n         * Transition callback scope.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_onUpdateScope\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdateScope;\r\n\r\n        /**\r\n         * Will this Scene sleep (true) after the transition, or stop (false)\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_willSleep\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._willSleep = false;\r\n\r\n        /**\r\n         * Will this Scene be removed from the Scene Manager after the transition completes?\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_willRemove\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._willRemove = false;\r\n\r\n        scene.sys.events.once('boot', this.boot, this);\r\n        scene.sys.events.on('start', this.pluginStart, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#boot\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once('destroy', this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#pluginStart\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    pluginStart: function ()\r\n    {\r\n        this._target = null;\r\n\r\n        this.systems.events.once('shutdown', this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Shutdown this Scene and run the given one.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to start.\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    start: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('stop', this.key);\r\n        this.manager.queueOp('start', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Restarts this Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#restart\r\n     * @since 3.4.0\r\n     * \r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    restart: function (data)\r\n    {\r\n        var key = this.key;\r\n\r\n        this.manager.queueOp('stop', key);\r\n        this.manager.queueOp('start', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * @typedef {object} Phaser.Scenes.ScenePlugin.SceneTransitionConfig\r\n     * \r\n     * @property {string} target - The Scene key to transition to.\r\n     * @property {integer} [duration=1000] - The duration, in ms, for the transition to last.\r\n     * @property {boolean} [sleep=false] - Will the Scene responsible for the transition be sent to sleep on completion (`true`), or stopped? (`false`)\r\n     * @property {boolean} [allowInput=false] - Will the Scenes Input system be able to process events while it is transitioning in or out?\r\n     * @property {boolean} [moveAbove] - Move the target Scene to be above this one before the transition starts.\r\n     * @property {boolean} [moveBelow] - Move the target Scene to be below this one before the transition starts.\r\n     * @property {function} [onUpdate] - This callback is invoked every frame for the duration of the transition.\r\n     * @property {any} [onUpdateScope] - The context in which the callback is invoked.\r\n     * @property {any} [data] - An object containing any data you wish to be passed to the target Scenes init / create methods.\r\n     */\r\n\r\n    /**\r\n     * This will start a transition from the current Scene to the target Scene given.\r\n     * \r\n     * The transition will last for the duration specified in milliseconds.\r\n     * \r\n     * You can have the target Scene moved above or below this one in the display list.\r\n     * \r\n     * You can specify an update callback. This callback will be invoked _every frame_ for the duration\r\n     * of the transition.\r\n     *\r\n     * This Scene can either be sent to sleep at the end of the transition, or stopped. The default is to stop.\r\n     * \r\n     * There are also 5 transition related events: This scene will emit the event `transitionto` when\r\n     * the transition begins, which is typically the frame after calling this method.\r\n     * \r\n     * The target Scene will emit the event `transitioninit` when that Scene's `init` method is called.\r\n     * It will then emit the event `transitionstart` when its `create` method is called.\r\n     * If the Scene was sleeping and has been woken up, it will emit the event `transitionwake` instead of these two,\r\n     * as the Scenes `init` and `create` methods are not invoked when a sleep wakes up.\r\n     * \r\n     * When the duration of the transition has elapsed it will emit the event `transitioncomplete`.\r\n     * These events are all cleared of listeners when the Scene shuts down, but not if it is sent to sleep.\r\n     *\r\n     * It's important to understand that the duration of the transition begins the moment you call this method.\r\n     * If the Scene you are transitioning to includes delayed processes, such as waiting for files to load, the\r\n     * time still counts down even while that is happening. If the game itself pauses, or something else causes\r\n     * this Scenes update loop to stop, then the transition will also pause for that duration. There are\r\n     * checks in place to prevent you accidentally stopping a transitioning Scene but if you've got code to\r\n     * override this understand that until the target Scene completes it might never be unlocked for input events.\r\n     * \r\n     * @method Phaser.Scenes.ScenePlugin#transition\r\n     * @since 3.5.0\r\n     *\r\n     * @param {Phaser.Scenes.ScenePlugin.SceneTransitionConfig} config - The transition configuration object.\r\n     *\r\n     * @return {boolean} `true` is the transition was started, otherwise `false`.\r\n     */\r\n    transition: function (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        var key = GetFastValue(config, 'target', false);\r\n\r\n        var target = this.manager.getScene(key);\r\n\r\n        if (!key || !this.checkValidTransition(target))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var duration = GetFastValue(config, 'duration', 1000);\r\n\r\n        this._elapsed = 0;\r\n        this._target = target;\r\n        this._duration = duration;\r\n        this._willSleep = GetFastValue(config, 'sleep', false);\r\n        this._willRemove = GetFastValue(config, 'remove', false);\r\n\r\n        var callback = GetFastValue(config, 'onUpdate', null);\r\n\r\n        if (callback)\r\n        {\r\n            this._onUpdate = callback;\r\n            this._onUpdateScope = GetFastValue(config, 'onUpdateScope', this.scene);\r\n        }\r\n\r\n        var allowInput = GetFastValue(config, 'allowInput', false);\r\n\r\n        this.settings.transitionAllowInput = allowInput;\r\n\r\n        var targetSettings = target.sys.settings;\r\n\r\n        targetSettings.isTransition = true;\r\n        targetSettings.transitionFrom = this.scene;\r\n        targetSettings.transitionDuration = duration;\r\n        targetSettings.transitionAllowInput = allowInput;\r\n\r\n        if (GetFastValue(config, 'moveAbove', false))\r\n        {\r\n            this.manager.moveAbove(this.key, key);\r\n        }\r\n        else if (GetFastValue(config, 'moveBelow', false))\r\n        {\r\n            this.manager.moveBelow(this.key, key);\r\n        }\r\n\r\n        if (target.sys.isSleeping())\r\n        {\r\n            target.sys.wake();\r\n        }\r\n        else\r\n        {\r\n            this.manager.start(key, GetFastValue(config, 'data'));\r\n        }\r\n\r\n        this.systems.events.emit('transitionout', target, duration);\r\n\r\n        this.systems.events.on('update', this.step, this);\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if this Scene can transition to the target Scene or not.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#checkValidTransition\r\n     * @private\r\n     * @since 3.5.0\r\n     *\r\n     * @param {Phaser.Scene} target - The Scene to test against.\r\n     *\r\n     * @return {boolean} `true` if this Scene can transition, otherwise `false`.\r\n     */\r\n    checkValidTransition: function (target)\r\n    {\r\n        //  Not a valid target if it doesn't exist, isn't active or is already transitioning in or out\r\n        if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * A single game step. This is only called if the parent Scene is transitioning\r\n     * out to another Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#step\r\n     * @private\r\n     * @since 3.5.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    step: function (time, delta)\r\n    {\r\n        this._elapsed += delta;\r\n\r\n        this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);\r\n\r\n        if (this._onUpdate)\r\n        {\r\n            this._onUpdate.call(this._onUpdateScope, this.transitionProgress);\r\n        }\r\n\r\n        if (this._elapsed >= this._duration)\r\n        {\r\n            this.transitionComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by `step` when the transition out of this scene to another is over.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#transitionComplete\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionComplete: function ()\r\n    {\r\n        var targetSys = this._target.sys;\r\n        var targetSettings = this._target.sys.settings;\r\n\r\n        //  Stop the step\r\n        this.systems.events.off('update', this.step, this);\r\n\r\n        //  Notify target scene\r\n        targetSys.events.emit('transitioncomplete', this.scene);\r\n\r\n        //  Clear target scene settings\r\n        targetSettings.isTransition = false;\r\n        targetSettings.transitionFrom = null;\r\n\r\n        //  Clear local settings\r\n        this._duration = 0;\r\n        this._target = null;\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n\r\n        //  Now everything is clear we can handle what happens to this Scene\r\n        if (this._willRemove)\r\n        {\r\n            this.manager.remove(this.key);\r\n        }\r\n        else if (this._willSleep)\r\n        {\r\n            this.systems.sleep();\r\n        }\r\n        else\r\n        {\r\n            this.manager.stop(this.key);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene key.\r\n     * @param {(Phaser.Scene|Phaser.Scenes.Settings.Config|function)} sceneConfig - The config for the Scene.\r\n     * @param {boolean} autoStart - Whether to start the Scene after it's added.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    add: function (key, sceneConfig, autoStart)\r\n    {\r\n        this.manager.add(key, sceneConfig, autoStart);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Launch the given Scene and run it in parallel with this one.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#launch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to launch.\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    launch: function (key, data)\r\n    {\r\n        if (key && key !== this.key)\r\n        {\r\n            this.manager.queueOp('start', key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Runs the given Scene, but does not change the state of this Scene.\r\n     * \r\n     * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n     * If not running at all, it will be started.\r\n     *\r\n     * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n     * Scene, then `run` on the modal Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#run\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The Scene to run.\r\n     * @param {object} [data] - A data object that will be passed to the Scene and emitted in its ready, wake, or resume events.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    run: function (key, data)\r\n    {\r\n        if (key && key !== this.key)\r\n        {\r\n            this.manager.queueOp('run', key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pause the Scene - this stops the update step from happening but it still renders.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to pause.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its pause event.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    pause: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('pause', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resume the Scene - starts the update loop again.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to resume.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its resume event.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    resume: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('resume', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Makes the Scene sleep (no update, no render) but doesn't shutdown.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to put to sleep.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its sleep event.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    sleep: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('sleep', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Makes the Scene wake-up (starts update and render)\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to wake up.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its wake event.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    wake: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('wake', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Makes this Scene sleep then starts the Scene given.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#switch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to start.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    switch: function (key)\r\n    {\r\n        if (key !== this.key)\r\n        {\r\n            this.manager.queueOp('switch', this.key, key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shutdown the Scene, clearing display list, timers, etc.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to stop.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    stop: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('stop', key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the active state of the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - If `true` the Scene will be resumed. If `false` it will be paused.\r\n     * @param {string} [key] - The Scene to set the active state of.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted with its events.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    setActive: function (value, key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        var scene = this.manager.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.setActive(value, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the visible state of the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible value.\r\n     * @param {string} [key] - The Scene to set the visible state for.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    setVisible: function (value, key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        var scene = this.manager.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.setVisible(value);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is sleeping or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is sleeping.\r\n     */\r\n    isSleeping: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isSleeping(key);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is active or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is active.\r\n     */\r\n    isActive: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isActive(key);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is visible or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is visible.\r\n     */\r\n    isVisible: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isVisible(key);\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two scenes in the Scenes list.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#swapPosition\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} keyA - The first Scene to swap.\r\n     * @param {string} [keyB] - The second Scene to swap. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    swapPosition: function (keyA, keyB)\r\n    {\r\n        if (keyB === undefined) { keyB = this.key; }\r\n\r\n        if (keyA !== keyB)\r\n        {\r\n            this.manager.swapPosition(keyA, keyB);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly above Scene A.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveAbove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} keyA - The Scene that Scene B will be moved to be above.\r\n     * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    moveAbove: function (keyA, keyB)\r\n    {\r\n        if (keyB === undefined) { keyB = this.key; }\r\n\r\n        if (keyA !== keyB)\r\n        {\r\n            this.manager.moveAbove(keyA, keyB);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly below Scene A.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveBelow\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} keyA - The Scene that Scene B will be moved to be below.\r\n     * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    moveBelow: function (keyA, keyB)\r\n    {\r\n        if (keyB === undefined) { keyB = this.key; }\r\n\r\n        if (keyA !== keyB)\r\n        {\r\n            this.manager.moveBelow(keyA, keyB);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a Scene from the SceneManager.\r\n     *\r\n     * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n     * cache and Scene.Systems.destroy is then called on it.\r\n     *\r\n     * If the SceneManager is processing the Scenes when this method is called it wil\r\n     * queue the operation for the next update sequence.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#remove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to be removed.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.remove(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene up one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    moveUp: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.moveUp(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene down one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    moveDown: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.moveDown(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Brings a Scene to the top of the Scenes list.\r\n     *\r\n     * This means it will render above all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    bringToTop: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.bringToTop(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends a Scene to the back of the Scenes list.\r\n     *\r\n     * This means it will render below all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    sendToBack: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.sendToBack(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieve a Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to retrieve.\r\n     *\r\n     * @return {Phaser.Scene} The Scene.\r\n     */\r\n    get: function (key)\r\n    {\r\n        return this.manager.getScene(key);\r\n    },\r\n\r\n    /**\r\n     * Retrieves the numeric index of a Scene in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#getIndex\r\n     * @since 3.7.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to get the index of.\r\n     *\r\n     * @return {integer} The index of the Scene.\r\n     */\r\n    getIndex: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.getIndex(key);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off('shutdown', this.shutdown, this);\r\n        eventEmitter.off('postupdate', this.step, this);\r\n        eventEmitter.off('transitionout');\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene.sys.events.off('start', this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.settings = null;\r\n        this.manager = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('ScenePlugin', ScenePlugin, 'scenePlugin');\r\n\r\nmodule.exports = ScenePlugin;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Clamp","Class","GetFastValue","PluginCache","ScenePlugin","initialize","scene","systems","sys","settings","key","manager","game","_elapsed","transitionProgress","_target","_duration","_willRemove","_willSleep","events","once","boot","on","pluginStart","destroy","shutdown","start","data","undefined","queueOp","restart","transition","config","target","getScene","checkValidTransition","duration","callback","_onUpdate","_onUpdateScope","allowInput","transitionAllowInput","targetSettings","isTransition","transitionFrom","transitionDuration","moveAbove","moveBelow","isSleeping","wake","emit","step","isActive","isTransitioning","time","delta","call","transitionComplete","targetSys","off","remove","sleep","stop","add","sceneConfig","autoStart","launch","run","pause","resume","switch","setActive","value","setVisible","isVisible","swapPosition","keyA","keyB","moveUp","moveDown","bringToTop","sendToBack","get","getIndex","eventEmitter","register"]
}
