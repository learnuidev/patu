{
"version":3,
"file":"module$node_modules$Phaser$src$physics$arcade$ArcadePhysics.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/arcade/ArcadePhysics.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$arcade$ArcadePhysics\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar DegToRad = require('../../math/DegToRad');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\nvar DistanceSquared = require('../../math/distance/DistanceSquared');\r\nvar Factory = require('./Factory');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Merge = require('../../utils/object/Merge');\r\nvar PluginCache = require('../../plugins/PluginCache');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar World = require('./World');\r\n\r\n/**\r\n * @classdesc\r\n * The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation.\r\n * It also holds some useful methods for moving and rotating Arcade Physics Bodies.\r\n *\r\n * You can access it from within a Scene using `this.physics`.\r\n *\r\n * @class ArcadePhysics\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this Plugin belongs to.\r\n */\r\nvar ArcadePhysics = new Class({\r\n\r\n    initialize:\r\n\r\n    function ArcadePhysics (scene)\r\n    {\r\n        /**\r\n         * The Scene that this Plugin belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene's Systems.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = this.getConfig();\r\n\r\n        /**\r\n         * The physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world;\r\n\r\n        /**\r\n         * An object holding the Arcade Physics factory methods.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#add\r\n         * @type {Phaser.Physics.Arcade.Factory}\r\n         * @since 3.0.0\r\n         */\r\n        this.add;\r\n\r\n        scene.sys.events.once('boot', this.boot, this);\r\n        scene.sys.events.on('start', this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.world = new World(this.scene, this.config);\r\n        this.add = new Factory(this.world);\r\n\r\n        this.systems.events.once('destroy', this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (!this.world)\r\n        {\r\n            this.world = new World(this.scene, this.config);\r\n            this.add = new Factory(this.world);\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on('update', this.world.update, this.world);\r\n        eventEmitter.on('postupdate', this.world.postUpdate, this.world);\r\n        eventEmitter.once('shutdown', this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Creates the physics configuration for the current Scene.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} The physics configuration.\r\n     */\r\n    getConfig: function ()\r\n    {\r\n        var gameConfig = this.systems.game.config.physics;\r\n        var sceneConfig = this.systems.settings.physics;\r\n\r\n        var config = Merge(\r\n            GetFastValue(sceneConfig, 'arcade', {}),\r\n            GetFastValue(gameConfig, 'arcade', {})\r\n        );\r\n\r\n        return config;\r\n    },\r\n\r\n    /**\r\n     * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if at least one Game Object overlaps another.\r\n     *\r\n     * @see Phaser.Physics.Arcade.World#overlap\r\n     */\r\n    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext)\r\n    {\r\n        if (overlapCallback === undefined) { overlapCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = overlapCallback; }\r\n\r\n        return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\r\n    },\r\n\r\n    /**\r\n     * Tests if Game Objects overlap and separates them (if possible). See {@link Phaser.Physics.Arcade.World#collide}.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.\r\n     *\r\n     * @see Phaser.Physics.Arcade.World#collide\r\n     */\r\n    collide: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\r\n    },\r\n\r\n    /**\r\n     * Pauses the simulation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} The simulation.\r\n     */\r\n    pause: function ()\r\n    {\r\n        return this.world.pause();\r\n    },\r\n\r\n    /**\r\n     * Resumes the simulation (if paused).\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} The simulation.\r\n     */\r\n    resume: function ()\r\n    {\r\n        return this.world.resume();\r\n    },\r\n\r\n    /**\r\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n     *\r\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n     *\r\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {number} x - The x coordinate to accelerate towards.\r\n     * @param {number} y - The y coordinate to accelerate towards.\r\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    accelerateTo: function (gameObject, x, y, speed, xSpeedMax, ySpeedMax)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n\r\n        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\r\n\r\n        gameObject.body.acceleration.setToPolar(angle, speed);\r\n\r\n        if (xSpeedMax !== undefined && ySpeedMax !== undefined)\r\n        {\r\n            gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);\r\n        }\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n     *\r\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n     *\r\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.\r\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    accelerateToObject: function (gameObject, destination, speed, xSpeedMax, ySpeedMax)\r\n    {\r\n        return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);\r\n    },\r\n\r\n    /**\r\n     * Finds the Body closest to a source point or object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#closest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} The closest Body to the given source point.\r\n     */\r\n    closest: function (source)\r\n    {\r\n        var bodies = this.world.tree.all();\r\n\r\n        var min = Number.MAX_VALUE;\r\n        var closest = null;\r\n        var x = source.x;\r\n        var y = source.y;\r\n\r\n        for (var i = bodies.length - 1; i >= 0; i--)\r\n        {\r\n            var target = bodies[i];\r\n            var distance = DistanceSquared(x, y, target.x, target.y);\r\n\r\n            if (distance < min)\r\n            {\r\n                closest = target;\r\n                min = distance;\r\n            }\r\n        }\r\n\r\n        return closest;\r\n    },\r\n\r\n    /**\r\n     * Finds the Body farthest from a source point or object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#furthest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} The Body furthest from the given source point.\r\n     */\r\n    furthest: function (source)\r\n    {\r\n        var bodies = this.world.tree.all();\r\n\r\n        var max = -1;\r\n        var farthest = null;\r\n        var x = source.x;\r\n        var y = source.y;\r\n\r\n        for (var i = bodies.length - 1; i >= 0; i--)\r\n        {\r\n            var target = bodies[i];\r\n            var distance = DistanceSquared(x, y, target.x, target.y);\r\n\r\n            if (distance > max)\r\n            {\r\n                farthest = target;\r\n                max = distance;\r\n            }\r\n        }\r\n\r\n        return farthest;\r\n    },\r\n\r\n    /**\r\n     * Move the given display object towards the x/y coordinates at a steady velocity.\r\n     * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\r\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {number} x - The x coordinate to move towards.\r\n     * @param {number} y - The y coordinate to move towards.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    moveTo: function (gameObject, x, y, speed, maxTime)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n        if (maxTime === undefined) { maxTime = 0; }\r\n\r\n        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\r\n\r\n        if (maxTime > 0)\r\n        {\r\n            //  We know how many pixels we need to move, but how fast?\r\n            speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1000);\r\n        }\r\n\r\n        gameObject.body.velocity.setToPolar(angle, speed);\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Move the given display object towards the destination object at a steady velocity.\r\n     * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\r\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    moveToObject: function (gameObject, destination, speed, maxTime)\r\n    {\r\n        return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);\r\n    },\r\n\r\n    /**\r\n     * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n     * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared.\r\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n     */\r\n    velocityFromAngle: function (angle, speed, vec2)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n        if (vec2 === undefined) { vec2 = new Vector2(); }\r\n\r\n        return vec2.setToPolar(DegToRad(angle), speed);\r\n    },\r\n\r\n    /**\r\n     * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n     * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rotation - The angle in radians.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared\r\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n     */\r\n    velocityFromRotation: function (rotation, speed, vec2)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n        if (vec2 === undefined) { vec2 = new Vector2(); }\r\n\r\n        return vec2.setToPolar(rotation, speed);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        if (!this.world)\r\n        {\r\n            //  Already destroyed\r\n            return;\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off('update', this.world.update, this.world);\r\n        eventEmitter.off('postupdate', this.world.postUpdate, this.world);\r\n        eventEmitter.off('shutdown', this.shutdown, this);\r\n\r\n        this.add.destroy();\r\n        this.world.destroy();\r\n\r\n        this.add = null;\r\n        this.world = null;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene.sys.events.off('start', this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('ArcadePhysics', ArcadePhysics, 'arcadePhysics');\r\n\r\nmodule.exports = ArcadePhysics;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Class","DegToRad","DistanceBetween","DistanceSquared","Factory","GetFastValue","Merge","PluginCache","Vector2","World","ArcadePhysics","initialize","scene","systems","sys","config","getConfig","events","once","boot","on","start","world","add","destroy","eventEmitter","update","postUpdate","shutdown","gameConfig","game","physics","settings","overlap","object1","object2","overlapCallback","processCallback","callbackContext","undefined","collideObjects","collide","collideCallback","pause","resume","accelerateTo","gameObject","x","y","speed","xSpeedMax","ySpeedMax","angle","Math","atan2","body","acceleration","setToPolar","maxVelocity","set","accelerateToObject","destination","closest","source","bodies","tree","all","min","Number","MAX_VALUE","i","length","target","distance","furthest","max","farthest","moveTo","maxTime","velocity","moveToObject","velocityFromAngle","vec2","velocityFromRotation","rotation","off","register"]
}
