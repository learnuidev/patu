{"version":3,"sources":["re_frame/core.cljc"],"mappings":"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","names":["re-frame.core/dispatch","event","re-frame.router/dispatch","re-frame.core/dispatch-sync","event-v","re-frame.router/dispatch-sync","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","re-frame.core/reg-sub","seq28541","G__28542","cljs.core/first","cljs.core/next","self__4723__auto__","query-id","args","cljs.core.apply","re-frame.subs/reg-sub","cljs.core.into","G__28554","re-frame.core/subscribe","js/Error","query","re_frame.subs.subscribe","dynv","G__28564","re-frame.core/clear-sub","re_frame.registrar.clear_handlers","re-frame.subs/kind","re-frame.core/clear-subscription-cache!","re-frame.subs/clear-subscription-cache!","re-frame.core/reg-sub-raw","handler-fn","re-frame.registrar/register-handler","re-frame.core/reg-fx","id","handler","re-frame.fx/reg-fx","G__28590","re-frame.core/clear-fx","re-frame.fx/kind","re-frame.core/reg-cofx","re-frame.cofx/reg-cofx","G__28592","re-frame.core/inject-cofx","re_frame.cofx.inject_cofx","value","G__28594","re-frame.core/clear-cofx","re-frame.cofx/kind","G__28596","re-frame.core/reg-event-db","re_frame.core.reg_event_db","interceptors","re-frame.events/register","re-frame.cofx/inject-db","re-frame.fx/do-fx","re-frame.std-interceptors/inject-global-interceptors","re-frame.std-interceptors/db-handler->interceptor","G__28598","re-frame.core/reg-event-fx","re_frame.core.reg_event_fx","re-frame.std-interceptors/fx-handler->interceptor","G__28600","re-frame.core/reg-event-ctx","re_frame.core.reg_event_ctx","re-frame.std-interceptors/ctx-handler->interceptor","G__28602","re-frame.core/clear-event","re-frame.events/kind","re-frame.core/debug","re-frame.std-interceptors/debug","re-frame.core/path","re-frame.std-interceptors/path","re-frame.core/enrich","re-frame.std-interceptors/enrich","re-frame.core/trim-v","re-frame.std-interceptors/trim-v","re-frame.core/after","re-frame.std-interceptors/after","re-frame.core/on-changes","re-frame.std-interceptors/on-changes","re-frame.core/reg-global-interceptor","interceptor","re-frame.settings/reg-global-interceptor","G__28604","re-frame.core/clear-global-interceptor","re_frame.settings.clear_global_interceptors","re-frame.core/->interceptor","p__28606","map__28607","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","cljs.core.get","seq28605","self__4724__auto__","cljs.core/seq","m","before","after","re_frame.utils.apply_kw","re-frame.interceptor/->interceptor","G__28610","re-frame.core/get-coeffect","context","re_frame.interceptor.get_coeffect","key","not-found","re-frame.core/assoc-coeffect","re-frame.interceptor/assoc-coeffect","G__28612","re-frame.core/get-effect","re_frame.interceptor.get_effect","re-frame.core/assoc-effect","re-frame.interceptor/assoc-effect","re-frame.core/enqueue","re-frame.interceptor/enqueue","re-frame.core/set-loggers!","new-loggers","re-frame.loggers/set-loggers!","re-frame.core/console","seq28613","G__28614","level","re-frame.loggers/console","re-frame.core/make-restore-fn","cljs.core/deref","handlers","re-frame.registrar/kind->id->handler","app-db","re-frame.db/app-db","subs-cache","re-frame.subs/query->reaction","original-subs","cljs.core/set","cljs.core/vals","current-subs","seq__28615","chunk__28616","count__28617","i__28618","temp__5735__auto__","cljs.core/chunked-seq?","c__4556__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","sub","clojure.set.difference","re-frame.interop/dispose!","cljs.core/reset!","re-frame.core/purge-event-queue","re-frame.router/event-queue","G__28620","re-frame.core/add-post-event-callback","f","re_frame.core.add_post_event_callback","re-frame.core/remove-post-event-callback","re-frame.core/register-handler","seq28621","re_frame.core.console","re-frame.core/register-sub","seq28622"],"sourcesContent":["(ns re-frame.core\n  (:require\n    [re-frame.events           :as events]\n    [re-frame.subs             :as subs]\n    [re-frame.interop          :as interop]\n    [re-frame.db               :as db]\n    [re-frame.fx               :as fx]\n    [re-frame.cofx             :as cofx]\n    [re-frame.router           :as router]\n    [re-frame.settings         :as settings]\n    [re-frame.loggers          :as loggers]\n    [re-frame.registrar        :as registrar]\n    [re-frame.interceptor      :as interceptor]\n    [re-frame.std-interceptors :as std-interceptors :refer [db-handler->interceptor\n                                                             fx-handler->interceptor\n                                                             ctx-handler->interceptor]]\n    [re-frame.utils            :as utils]\n    [clojure.set               :as set]))\n\n\n;; -- API ---------------------------------------------------------------------\n;;\n;; This namespace represents the re-frame API\n\n;; -- dispatch ----------------------------------------------------------------\n(defn dispatch\n  \"Enqueue `event` for processing by event handling machinery.\n\n  `event` is a vector of length >= 1. The 1st element identifies the kind of event.\n\n  Note: the event handler is not run immediately - it is not run\n  synchronously. It will likely be run 'very soon', although it may be\n  added to the end of a FIFO queue which already contain events.\n\n  Usage:\n     (dispatch [:order-pizza {:supreme 2 :meatlovers 1 :veg 1}])\"\n  [event]\n  (router/dispatch event))\n\n(defn dispatch-sync\n  \"Synchronously (immediately) process `event`. Do not queue.\n\n  Generally, don't use this. Instead use `dispatch`. It is an error\n  to use `dispatch-sync` within an event handler.\n\n  Useful when any delay in processing is a problem:\n     1. the `:on-change` handler of a text field where we are expecting fast typing.\n     2  when initialising your app - see 'main' in todomvc examples\n     3. in a unit test where we don't want the action 'later'\n\n  Usage:\n     (dispatch-sync [:sing :falsetto 634])\"\n  [event-v]\n  (router/dispatch-sync event-v))\n\n\n;; -- subscriptions -----------------------------------------------------------\n(defn reg-sub\n  \"For a given `query-id`, register two functions: a `computation` function and an `input signals` function.\n\n  During program execution, a call to `subscribe`, such as `(subscribe [:sub-id 3 \\\"blue\\\"])`,\n  will create a new `:sub-id` node in the Signal Graph. And, at that time, re-frame\n  needs to know how to create the node.   By calling `reg-sub`, you are registering\n  'the template' or 'the mechanism' by which nodes in the Signal Graph can be created.\n\n  Repeating: calling `reg-sub` does not create a node. It only creates the template\n  from which nodes can be created later.\n\n  `reg-sub` arguments are:\n    - a `query-id` (typically a namespaced keyword)\n    - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways)\n    - a function which computes the value of this kind of node\n\n  The `computation function` is always the last argument supplied and it is expected to have the signature:\n    `(input-values, query-vector) -> a-value`\n\n  When `computation function` is called, the `query-vector` argument will be the vector supplied to the\n  the `subscribe` which caused the node to be created. So, if the call was `(subscribe [:sub-id 3 \\\"blue\\\"])`,\n  then the `query-vector` supplied to the computaton function will be `[:sub-id 3 \\\"blue\\\"]`.\n\n  The arguments supplied between the `query-id` and the `computation-function` can vary in 3 ways,\n  but whatever is there defines the `input signals` part of the template, controlling what input\n values \\\"flow into\\\" the `computation function` gets when it is called.\n\n  `reg-sub` can be called in one of three ways, because there are three ways to define the input signals part.\n  But note, the 2nd method, in which a `signal-fn` is explicitly supplied, is the most canonical and instructive. The other\n  two are really just sugary variations.\n\n  1. No input signals given:\n      ```clj\n     (reg-sub\n       :query-id\n       a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n     ```\n\n     In the absence of an explicit `input-fn`, the node's input signal defaults to `app-db`\n     and, as a result, the value within `app-db` (a map) is\n     is given as the 1st argument when `a-computation-fn` is called.\n\n\n  2. A signal function is explicitly supplied:\n     ```clj\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here\n       computation-fn)\n     ```\n\n     This is the most canonical and instructive of the three variations.\n\n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many, or a map with the signals as the values.\n\n     The values from returned nominated signals will be supplied as the 1st argument to\n     the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns,\n     this value will be either a singleton, sequence or map of them (paralleling\n     the structure returned by the `signal-fn`).\n\n     This example `signal-fn` returns a vector of input signals.\n       ```clj\n       (fn [query-vec dynamic-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n       ```\n     The associated computation function must be written\n     to expect a vector of values for its first argument:\n       ```clj\n       (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n         ....)\n        ```\n\n     If, on the other hand, the signal function was simpler and returned a singleton, like this:\n        ```clj\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n        ```\n     then the associated computation function must be written to expect a single value\n     as the 1st argument:\n        ```clj\n        (fn [a query-vec]       ;; 1st argument is a single value\n          ...)\n        ```\n\n     Further Note: variation #1 above, in which an `input-fn` was not supplied, like this:\n       ```clj\n     (reg-sub\n       :query-id\n       a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n     ```\n     is the equivalent of using this\n     2nd variation and explicitly suppling a `signal-fn` which returns `app-db`:\n     ```clj\n     (reg-sub\n       :query-id\n       (fn [_ _]  re-frame/app-db)   ;; <--- explicit input-fn\n       a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n     ```\n\n  3. Syntax Sugar\n\n     ```clj\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n         {:a a :b b}))\n     ```\n\n     This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n     `signals-fn` you provide one or more pairs of `:<-` and a subscription vector.\n\n     If you supply only one pair a singleton will be supplied to the computation function,\n     as if you had supplied a `signal-fn` returning only a single value:\n\n     ```clj\n     (reg-sub\n       :a-sub\n       :<- [:a-sub]\n       (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n         ...))\n     ```\n\n  For further understanding, read `/docs`, and look at the detailed comments in\n  /examples/todomvc/src/subs.cljs\n  \"\n  [query-id & args]\n  (apply subs/reg-sub (into [query-id] args)))\n\n(defn subscribe\n  \"Given a `query` vector, returns a Reagent `reaction` which, over\n  time, reactively delivers a stream of values. So in FRP-ish terms,\n  it returns a `Signal`.\n\n  To obtain the returned Signal/Stream's current value, it must be `deref`ed.\n\n  `query` is a vector of at least one element. The first element is the\n  `query-id`, typically a namespaced keyword. The rest of the vector's\n  elements are optional, additional values which parameterise the query\n  performed.\n\n  `dynv` is an optional 3rd argument, which is a vector of further input\n  signals (atoms, reactions, etc), NOT values. This argument exists for\n  historical reasons and is borderline deprecated these days.\n\n  Example Usage:\n  --------------\n\n    (subscribe [:items])\n    (subscribe [:items \\\"blue\\\" :small])\n    (subscribe [:items {:colour \\\"blue\\\"  :size :small}])\n\n  Note: for any given call to `subscribe` there must have been a previous call\n  to `reg-sub`, registering the query handler (function) for the `query-id` given.\n\n  Hint\n  ----\n\n  When used in a view function BE SURE to `deref` the returned value.\n  In fact, to avoid any mistakes, some prefer to define:\n\n     (def <sub  (comp deref re-frame.core/subscribe))\n\n  And then, within their views, they call  `(<sub [:items :small])` rather\n  than using `subscribe` directly.\n\n  De-duplication\n  --------------\n\n  Two, or more, concurrent subscriptions for the same query will source reactive\n  updates from the one executing handler.\n  \"\n  ([query]\n   (subs/subscribe query))\n  ([query dynv]\n   (subs/subscribe query dynv)))\n\n(defn clear-sub ;; think unreg-sub\n  \"When called with no args, unregisters all subscription handlers. When given\n   one arg, assumed to be a `query-id` of a registered subscription handler,\n   unregisters the associated handler.\n\n   NOTE: Depending on the usecase it may also be necessary to call \n         `clear-subscription-cache!`.\"\n  ([]\n   (registrar/clear-handlers subs/kind))\n  ([query-id]\n   (registrar/clear-handlers subs/kind query-id)))\n\n(defn clear-subscription-cache!\n  \"Causes all subscriptions to be removed from the cache.\n  Does this by:\n     1. running `on-dispose` on all cached subscriptions\n     2. Each `on-dispose` will perform the removal of themselves.\n\n  This is for development time use. Useful when reloading Figwheel code\n  after a React exception, because React components won't have been\n  cleaned up properly. And this, in turn, means the subscriptions within those\n  components won't have been cleaned up correctly. So this forces the issue.\"\n  []\n  (subs/clear-subscription-cache!))\n\n(defn reg-sub-raw\n  \"This is a low level, advanced function.  You should probably be\n  using reg-sub instead.\n  Docs in https://github.com/day8/re-frame/blob/master/docs/SubscriptionFlow.md\"\n  [query-id handler-fn]\n  (registrar/register-handler subs/kind query-id handler-fn))\n\n\n;; -- effects -----------------------------------------------------------------\n(defn reg-fx\n  \"Register the given effect `handler` for the given `id`.\n\n  `id` is keyword, often namespaced.\n  `handler` is a side-effecting function which takes a single argument and whose return\n  value is ignored.\n\n  Example Use\n  -----------\n\n  First, registration ... associate `:effect2` with a handler.\n\n  (reg-fx\n     :effect2\n     (fn [value]\n        ... do something side-effect-y))\n\n  Then, later, if an event handler were to return this effects map ...\n\n  {...\n   :effect2  [1 2]}\n\n   ... then the `handler` `fn` we registered previously, using `reg-fx`, will be\n   called with an argument of `[1 2]`.\"\n  [id handler]\n  (fx/reg-fx id handler))\n\n(defn clear-fx ;; think unreg-fx\n  \"When called with no args, unregisters all effect handlers. When given one arg,\n   assumed to be the `id` of a registered effect handler, unregisters the \n   associated handler.\"\n  ([]\n   (registrar/clear-handlers fx/kind))\n  ([id]\n   (registrar/clear-handlers fx/kind id)))\n\n;; -- coeffects ---------------------------------------------------------------\n(defn reg-cofx\n  \"Register the given coeffect `handler` for the given `id`, for later use\n  within `inject-cofx`.\n\n  `id` is keyword, often namespaced.\n  `handler` is a function which takes either one or two arguements, the first of which is\n  always `coeffects` and which returns an updated `coeffects`.\n\n  See the docs for `inject-cofx` for example use.\"\n  [id handler]\n  (cofx/reg-cofx id handler))\n\n(defn inject-cofx\n  \"Given an `id`, and an optional, arbitrary `value`, returns an interceptor\n   whose `:before` adds to the `:coeffects` (map) by calling a pre-registered\n   'coeffect handler' identified by the `id`.\n\n   The previous association of a `coeffect handler` with an `id` will have\n   happened via a call to `re-frame.core/reg-cofx` - generally on program startup.\n\n   Within the created interceptor, this 'looked up' `coeffect handler` will\n   be called (within the `:before`) with two arguments:\n     - the current value of `:coeffects`\n     - optionally, the originally supplied arbitrary `value`\n\n   This `coeffect handler` is expected to modify and return its first, `coeffects` argument.\n\n   Example Of how `inject-cofx` and `reg-cofx` work together\n   ---------------------------------------------------------\n\n   1. Early in app startup, you register a `coeffect handler` for `:datetime`:\n\n      (re-frame.core/reg-cofx\n        :datetime                        ;; usage  (inject-cofx :datetime)\n        (fn coeffect-handler\n          [coeffect]\n          (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\n\n   2. Later, add an interceptor to an -fx event handler, using `inject-cofx`:\n\n      (re-frame.core/reg-event-fx        ;; we are registering an event handler\n         :event-id\n         [ ... (inject-cofx :datetime) ... ]    ;; <-- create an injecting interceptor\n         (fn event-handler\n           [coeffect event]\n           ... in here can access (:now coeffect) to obtain current datetime ... )))\n\n   Background\n   ----------\n\n   `coeffects` are the input resources required by an event handler\n   to perform its job. The two most obvious ones are `db` and `event`.\n   But sometimes an event handler might need other resources.\n\n   Perhaps an event handler needs a random number or a GUID or the current\n   datetime. Perhaps it needs access to a DataScript database connection.\n\n   If an event handler directly accesses these resources, it stops being\n   pure and, consequently, it becomes harder to test, etc. So we don't\n   want that.\n\n   Instead, the interceptor created by this function is a way to 'inject'\n   'necessary resources' into the `:coeffects` (map) subsequently given\n   to the event handler at call time.\"\n  ([id]\n   (cofx/inject-cofx id))\n  ([id value]\n   (cofx/inject-cofx id value)))\n\n(defn clear-cofx ;; think unreg-cofx\n  \"When called with no args, unregisters all coeffect handlers. When given one arg,\n   assumed to be the `id` of a registered coeffect handler, unregisters the \n   associated handler.\" \n  ([]\n   (registrar/clear-handlers cofx/kind))\n  ([id]\n   (registrar/clear-handlers cofx/kind id)))\n\n;; -- Events ------------------------------------------------------------------\n\n(defn reg-event-db\n  \"Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain.\n  `id` is typically a namespaced keyword  (but can be anything)\n  `handler` is a function: (db event) -> db\n  `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n  `handler` is wrapped in its own interceptor and added to the end of the interceptor\n   chain, so that, in the end, only a chain is registered.\n   Special effects and coeffects interceptors are added to the front of this\n   chain.\"\n  ([id handler]\n   (reg-event-db id nil handler))\n  ([id interceptors handler]\n   (events/register id [cofx/inject-db fx/do-fx std-interceptors/inject-global-interceptors interceptors (db-handler->interceptor handler)])))\n\n\n(defn reg-event-fx\n  \"Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain.\n  `id` is typically a namespaced keyword  (but can be anything)\n  `handler` is a function: (coeffects-map event-vector) -> effects-map\n  `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n  `handler` is wrapped in its own interceptor and added to the end of the interceptor\n   chain, so that, in the end, only a chain is registered.\n   Special effects and coeffects interceptors are added to the front of the\n   interceptor chain.  These interceptors inject the value of app-db into coeffects,\n   and, later, action effects.\"\n  ([id handler]\n   (reg-event-fx id nil handler))\n  ([id interceptors handler]\n   (events/register id [cofx/inject-db fx/do-fx std-interceptors/inject-global-interceptors interceptors (fx-handler->interceptor handler)])))\n\n\n(defn reg-event-ctx\n  \"Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain.\n  `id` is typically a namespaced keyword  (but can be anything)\n  `handler` is a function: (context-map event-vector) -> context-map\n\n  This form of registration is almost never used. \"\n  ([id handler]\n   (reg-event-ctx id nil handler))\n  ([id interceptors handler]\n   (events/register id [cofx/inject-db fx/do-fx std-interceptors/inject-global-interceptors interceptors (ctx-handler->interceptor handler)])))\n\n(defn clear-event ;; think unreg-event-*\n  \"When called with no args, unregisters all event handlers. When given one arg,\n   assumed to be the `id` of a registered event handler, unregisters the \n   associated handler.\"  \n  ([]\n   (registrar/clear-handlers events/kind))\n  ([id]\n   (registrar/clear-handlers events/kind id)))\n\n;; -- interceptors ------------------------------------------------------------\n\n;; Standard interceptors.\n;; Detailed docs on each in std-interceptors.cljs\n(def debug\n  \"An interceptor which logs/instruments an event handler's actions to\n  `js/console.debug`. See examples/todomvc/src/events.cljs for use.\n\n  Output includes:\n  1. the event vector\n  2. a `clojure.data/diff` of db, before vs after, which shows\n     the changes caused by the event handler.  You will absolutely have\n     to understand https://clojuredocs.org/clojure.data/diff to\n     understand the output.\n\n  You'd typically include this interceptor after (to the right of) any\n  path interceptor.\n\n  Warning:  calling clojure.data/diff on large, complex data structures\n  can be slow. So, you won't want this interceptor present in production\n  code. So condition it out like this :\n\n      (re-frame.core/reg-event-db\n         :evt-id\n         [(when ^boolean goog.DEBUG re-frame.core/debug)]  ;; <-- conditional\n         (fn [db v]\n           ...))\n\n  To make this code fragment work, you'll also have to set goog.DEBUG to\n  false in your production builds - look in `project.clj` of /examples/todomvc.\n  \"\n  std-interceptors/debug)\n\n(def path\n  \"returns an interceptor whose `:before` substitutes the coeffects `:db` with\n  a sub-path of `:db`. Within `:after` it grafts the handler's return value\n  back into db, at the right path.\n\n  So, its overall action is to make the event handler behave like the function\n  you might give to clojure's `update-in`.\n\n  Examples:\n\n      (path :some :path)\n      (path [:some :path])\n      (path [:some :path] :to :here)\n      (path [:some :path] [:to] :here)\n\n  Example Use:\n\n      (reg-event-db\n        :event-id\n        (path [:a :b])  ;; used here, in interceptor chain\n        (fn [b v]       ;; 1st arg is now not db. Is the value from path [:a :b] within db\n          ... new-b))   ;; returns a new value for that path (not the entire db)\n\n  Notes:\n    1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n    2. if `:effects` contains no `:db` effect, can't graft a value back in.\n  \"\n  std-interceptors/path)\n\n(def enrich\n  \"Interceptor factory which runs the given function `f` in the `after handler`\n  position.  `f` is called with two arguments: `db` and `v`, and is expected to\n  return a modified `db`.\n\n  Unlike the `after` interceptor which is only about side effects, `enrich`\n  expects `f` to process and alter the given `db` coeffect in some useful way,\n  contributing to the derived data, flowing vibe.\n\n  Example Use:\n  ------------\n\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them via a warning\n  at the bottom of the panel.\n\n  Almost any user action (edit text, add new todo, remove a todo) requires a\n  complete reassessment of duplication errors and warnings. Eg: that edit\n  just made might have introduced a new duplicate, or removed one. Same with\n  any todo removal. So we need to re-calculate warnings after any CRUD events\n  associated with the todos list.\n\n  Unless we are careful, we might end up coding subtly different checks\n  for each kind of CRUD operation.  The duplicates check made after\n  'delete todo' event might be subtly different to that done after an\n  editing operation. Nice and efficient, but fiddly. A bug generator\n  approach.\n\n  So, instead, we create an `f` which recalculates ALL warnings from scratch\n  every time there is ANY change. It will inspect all the todos, and\n  reset ALL FLAGS every time (overwriting what was there previously)\n  and fully recalculate the list of duplicates (displayed at the bottom?).\n\n  https://twitter.com/nathanmarz/status/879722740776939520\n\n  By applying `f` in an `:enrich` interceptor, after every CRUD event,\n  we keep the handlers simple and yet we ensure this important step\n  (of getting warnings right) is not missed on any change.\n\n  We can test `f` easily - it is a pure function - independently of\n  any CRUD operation.\n\n  This brings huge simplicity at the expense of some re-computation\n  each time. This may be a very satisfactory trade-off in many cases.\"\n  std-interceptors/enrich)\n\n(def trim-v\n  \"An interceptor which removes the first element of the event vector,\n  allowing you to write more aesthetically pleasing event handlers. No\n  leading underscore on the event-v!\n  Your event handlers will look like this:\n\n      (defn my-handler\n        [db [x y z]]    ;; <-- instead of [_ x y z]\n        ....)\"\n  std-interceptors/trim-v)\n\n(def after\n  \"returns an interceptor which runs a given function `f` in the `:after`\n  position, presumably for side effects.\n\n  `f` is called with two arguments: the `:effects` value for `:db`\n  (or the `coeffect` value of db if no db effect is returned) and the event.\n  Its return value is ignored, so `f` can only side-effect.\n\n  Examples use can be seen in the /examples/todomvc:\n     - `f` runs schema validation (reporting any errors found).\n     - `f` writes to localstorage.\"\n  std-interceptors/after)\n\n(def on-changes\n  \"Interceptor factory which acts a bit like `reaction`  (but it flows into\n  `db`, rather than out). It observes N paths within `db` and if any of them\n  test not identical? to their previous value  (as a result of a event handler\n  being run) then it runs `f` to compute a new value, which is then assoc-ed\n  into the given `out-path` within `db`.\n\n  Usage:\n\n      (defn my-f\n        [a-val b-val]\n        ... some computation on a and b in here)\n\n      (on-changes my-f [:c]  [:a] [:b])\n\n  Put this Interceptor on the right handlers (ones which might change :a or :b).\n  It will:\n     - call `f` each time the value at path [:a] or [:b] changes\n     - call `f` with the values extracted from [:a] [:b]\n     - assoc the return value from `f` into the path  [:c]\n  \"\n  std-interceptors/on-changes)\n\n\n(defn reg-global-interceptor\n  \"Registers `interceptor` as a global interceptor. Global interceptors are\n   included in the processing of every event.\n\n   When you register an event handler you have the option of supplying an\n   interceptor chain. Any global interceptors you register are effectively\n   prepending to this chain in the order that they are registered.\"\n  [interceptor]\n  (settings/reg-global-interceptor interceptor))\n\n(defn clear-global-interceptor ;; think unreg-global-interceptor\n  \"When called with no args, unregisters all global interceptors. When given\n   one arg, assumed to be the `id` of a currently registered global\n   interceptor, it unregisters the associated interceptor.\"\n  ([]\n   (settings/clear-global-interceptors))\n  ([id]\n   (settings/clear-global-interceptors id)))\n\n;; Utility functions for creating your own interceptors\n;;\n;;  (def my-interceptor\n;;     (->interceptor                ;; used to create an interceptor\n;;       :id     :my-interceptor     ;; an id - decorative only\n;;       :before (fn [context]                         ;; you normally want to change :coeffects\n;;                  ... use get-coeffect  and assoc-coeffect\n;;                       )\n;;       :after  (fn [context]                         ;; you normally want to change :effects\n;;                 (let [db (get-effect context :db)]  ;; (get-in context [:effects :db])\n;;                   (assoc-effect context :http-ajax {...}])))))\n;;\n(defn ->interceptor\n  \"Create an interceptor from named arguments\"\n  [& {:as m :keys [id before after]}]\n  (utils/apply-kw interceptor/->interceptor m))\n\n(defn get-coeffect\n  \"When called with one arg, returns the coeffects map from the `context`.\n   When called with two or three args, behaves like `clojure.core/get`, \n   returns the value mapped to `key` in the coeffects map, `not-found` or\n   `nil` if `key` is not present.\"\n  ([context]\n   (interceptor/get-coeffect context))\n  ([context key]\n   (interceptor/get-coeffect context key))\n  ([context key not-found]\n   (interceptor/get-coeffect context key not-found)))\n\n(defn assoc-coeffect\n  \"Returns a new `context` with a new coeffects map that contains `key`\n   mapped to the `value`.\"\n  [context key value]\n  (interceptor/assoc-coeffect context key value))\n\n(defn get-effect\n  \"When called with one arg, returns the effects map from the `context`.\n   When called with two or three args, behaves like `clojure.core/get`, \n   returns the value mapped to `key` in the effects map, `not-found` or\n   `nil` if `key` is not present.\"\n  ([context]\n   (interceptor/get-effect context))\n  ([context key]\n   (interceptor/get-effect context key))\n  ([context key not-found]\n   (interceptor/get-effect context key not-found)))\n\n(defn assoc-effect\n  \"Returns a new `context` with a new effects map that contains `key`\n   mapped to the `value`.\"\n  [context key value]\n  (interceptor/assoc-effect context key value))\n\n(defn enqueue\n  \"Add a collection of `interceptors` to the end of `context's` execution `:queue`.\n  Returns the updated `context`.\n\n  In an advanced case, this function could allow an interceptor to add new\n  interceptors to the `:queue` of a context.\"\n  [context interceptors]\n  (interceptor/enqueue context interceptors))\n\n\n;; --  logging ----------------------------------------------------------------\n;; Internally, re-frame uses the logging functions: warn, log, error, group and groupEnd\n;; By default, these functions map directly to the js/console implementations,\n;; but you can override with your own fns (set or subset).\n;; Example Usage:\n;;   (defn my-fn [& args]  (post-it-somewhere (apply str args)))  ;; here is my alternative\n;;   (re-frame.core/set-loggers!  {:warn my-fn :log my-fn})       ;; override the defaults with mine\n(defn set-loggers!\n  \"Change the set (or a subset) of logging functions used by re-frame.\n  `new-loggers` should be a map with the same keys as `loggers` (above)\"\n  [new-loggers]\n  (loggers/set-loggers! new-loggers))\n\n(defn console\n  \"Logs `args` to the console at `level`. \n   Level can be one of `:log` `:error` `:warn` `:debug` `:group` `:groupEnd`.\n   If you are writing an extension to re-frame, like prehaps an effect handler,\n   you may want to use re-frame logging so that users can configure logging \n   from a central location.\n\n   usage: (console :error \\\"Oh, dear God, it happened:\\\" a-var \\\"and\\\" another)\n          (console :warn \\\"Possible breach of containment wall at:\\\" dt)\"\n  [level & args]\n  (apply loggers/console (into [level] args)))\n\n;; -- unit testing ------------------------------------------------------------\n\n(defn make-restore-fn\n  \"Checkpoints the state of re-frame and returns a function which, when\n  later called, will restore re-frame to that checkpointed state.\n\n  Checkpoint includes app-db, all registered handlers and all subscriptions.\n  \"\n  []\n  (let [handlers @registrar/kind->id->handler\n        app-db   @db/app-db\n        subs-cache @subs/query->reaction]\n    (fn []\n      ;; call `dispose!` on all current subscriptions which\n      ;; didn't originally exist.\n      (let [original-subs (set (vals subs-cache))\n            current-subs  (set (vals @subs/query->reaction))]\n        (doseq [sub (set/difference current-subs original-subs)]\n          (interop/dispose! sub)))\n\n      ;; Reset the atoms\n      ;; We don't need to reset subs/query->reaction, as\n      ;; disposing of the subs removes them from the cache anyway\n      (reset! registrar/kind->id->handler handlers)\n      (reset! db/app-db app-db)\n      nil)))\n\n(defn purge-event-queue\n  \"Remove all events queued for processing\"\n  []\n  (router/purge re-frame.router/event-queue))\n\n;; -- Event Processing Callbacks  ---------------------------------------------\n\n(defn add-post-event-callback\n  \"Registers a function `f` to be called after each event is processed\n   `f` will be called with two arguments:\n    - `event`: a vector. The event just processed.\n    - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\n\n   This is useful in advanced cases like:\n     - you are implementing a complex bootstrap pipeline\n     - you want to create your own handling infrastructure, with perhaps multiple\n       handlers for the one event, etc.  Hook in here.\n     - libraries providing 'isomorphic javascript' rendering on  Nodejs or Nashorn.\n\n  'id' is typically a keyword. Supplied at \\\"add time\\\" so it can subsequently\n  be used at \\\"remove time\\\" to get rid of the right callback.\n  \"\n  ([f]\n   (add-post-event-callback f f))   ;; use f as its own identifier\n  ([id f]\n   (router/add-post-event-callback re-frame.router/event-queue id f)))\n\n\n(defn remove-post-event-callback\n  \"Unregisters the function identified by `id` to be called after each event is\n   processed.\"\n  [id]\n  (router/remove-post-event-callback re-frame.router/event-queue id))\n\n\n;; --  Deprecation ------------------------------------------------------------\n;; Assisting the v0.7.x ->  v0.8.x transition.\n(defn register-handler\n  \"Deprecated. Use `reg-event-db` instead.\"\n  {:deprecated \"0.8.0\"}\n  [& args]\n  (console :warn  \"re-frame:  \\\"register-handler\\\" has been renamed \\\"reg-event-db\\\" (look for registration of\" (str (first args)) \")\")\n  (apply reg-event-db args))\n\n(defn register-sub\n  \"Deprecated. Use `reg-sub-raw` instead.\"\n  {:deprecated \"0.8.0\"}\n  [& args]\n  (console :warn  \"re-frame:  \\\"register-sub\\\" is deprecated. Use \\\"reg-sub-raw\\\" (look for registration of\" (str (first args)) \")\")\n  (apply reg-sub-raw args))\n"]}