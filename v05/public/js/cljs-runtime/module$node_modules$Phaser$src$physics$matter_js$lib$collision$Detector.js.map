{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$lib$collision$Detector.js",
"lineCount":4,
"mappings":"AAAAA,cAAA,wEAAA,CAA4F,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CASpI,IAAIC,SAAW,EAEfF,OAAAC,QAAA,CAAiBC,QAEjB,KAAIC,IAAMJ,OAAA,CAAQ,oEAAR,CAAV,CACIK,KAAOL,OAAA,CAAQ,qEAAR,CADX,CAEIM,OAASN,OAAA,CAAQ,sEAAR,CAEZ,UAAQ,EAAG,CASRG,QAAAI,WAAA,CAAsBC,QAAQ,CAACC,eAAD,CAAkBC,MAAlB,CAA0B,CAAA,IAChDH;AAAa,EADmC,CAEhDI,WAAaD,MAAAE,MAAAC,MAGbC,OAAAA,CAAUJ,MAAAI,QAGd,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBN,eAAAO,OAApB,CAA4CD,CAAA,EAA5C,CAAiD,CAAA,IACzCE,MAAQR,eAAA,CAAgBM,CAAhB,CAAA,CAAmB,CAAnB,CADiC,CAEzCG,MAAQT,eAAA,CAAgBM,CAAhB,CAAA,CAAmB,CAAnB,CAEZ,KAAKI,CAAAF,KAAAE,SAAL,EAAuBC,CAAAH,KAAAG,WAAvB,EAA6CD,CAAAD,KAAAC,SAA7C,EAA+DC,CAAAF,KAAAE,WAA/D,GAGKjB,QAAAkB,WAAA,CAAoBJ,KAAAK,gBAApB,CAA2CJ,KAAAI,gBAA3C,CAHL,GAOAR,MAAAS,cAII,EAJqB,CAIrB,CAAAjB,MAAAkB,SAAA,CAAgBP,KAAAQ,OAAhB,CAA8BP,KAAAO,OAA9B,CAXJ,EAYI,IAAK,IAAIC,EAAyB,CAArB,CAAAT,KAAAU,MAAAX,OAAA,CAAyB,CAAzB,CAA6B,CAA1C,CAA6CU,CAA7C,CAAiDT,KAAAU,MAAAX,OAAjD,CAAqEU,CAAA,EAArE,CAGI,IAFA,IAAIE,MAAQX,KAAAU,MAAA,CAAYD,CAAZ,CAAZ,CAESG,EAAyB,CAArB,CAAAX,KAAAS,MAAAX,OAAA,CAAyB,CAAzB,CAA6B,CAA1C,CAA6Ca,CAA7C,CAAiDX,KAAAS,MAAAX,OAAjD,CAAqEa,CAAA,EAArE,CAA0E,CACtE,IAAIC;AAAQZ,KAAAS,MAAA,CAAYE,CAAZ,CAEZ,IAAKD,KAAL,GAAeX,KAAf,EAAwBa,KAAxB,GAAkCZ,KAAlC,EAA4CZ,MAAAkB,SAAA,CAAgBI,KAAAH,OAAhB,CAA8BK,KAAAL,OAA9B,CAA5C,CAAyF,CAAA,IAEjFM,OAAS1B,IAAA2B,GAAA,CAAQJ,KAAR,CAAeE,KAAf,CACTG,OAAAA,CAAOtB,UAAA,CAAWoB,MAAX,CAUPG,MAAAA,CAAY9B,GAAA+B,SAAA,CAAaP,KAAb,CAAoBE,KAApB,CAPZG,MAAJG,EAAYH,MAAAI,SAAZD,CACwBH,MAAAC,UADxBE,CAGwB,IAIR,CAGhBtB,OAAAwB,iBAAA,EAA4B,CACxBJ,MAAAK,OAAJ,GACIzB,MAAA0B,iBADJ,EACgC,CADhC,CAIIN,MAAAO,SAAJ,GACIlC,UAAAmC,KAAA,CAAgBR,KAAhB,CAEA,CAAApB,MAAA6B,iBAAA,EAA4B,CAHhC,CArBqF,CAHnB,CAnBrC,CAuDjD,MAAOpC,WA/D6C,CA0ExDJ,SAAAkB,WAAA,CAAsBuB,QAAQ,CAACC,OAAD,CAAUC,OAAV,CAAmB,CAC7C,MAAID,QAAAE,MAAJ,GAAsBD,OAAAC,MAAtB,EAAyD,CAAzD,GAAuCF,OAAAE,MAAvC,CAC2B,CAD3B,CACWF,OAAAE,MADX;AAG6C,CAH7C,IAGQF,OAAAG,KAHR,CAGuBF,OAAAG,SAHvB,GAGwF,CAHxF,IAGmDH,OAAAE,KAHnD,CAGkEH,OAAAI,SAHlE,CAD6C,CAnFzC,CAAX,CAAD,EAjBoI;",
"sources":["node_modules/Phaser/src/physics/matter-js/lib/collision/Detector.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$lib$collision$Detector\"] = function(global,require,module,exports) {\n/**\r\n* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.\r\n*\r\n* @class Detector\r\n*/\r\n\r\n// TODO: speculative contacts\r\n\r\nvar Detector = {};\r\n\r\nmodule.exports = Detector;\r\n\r\nvar SAT = require('./SAT');\r\nvar Pair = require('./Pair');\r\nvar Bounds = require('../geometry/Bounds');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Finds all collisions given a list of pairs.\r\n     * @method collisions\r\n     * @param {pair[]} broadphasePairs\r\n     * @param {engine} engine\r\n     * @return {array} collisions\r\n     */\r\n    Detector.collisions = function(broadphasePairs, engine) {\r\n        var collisions = [],\r\n            pairsTable = engine.pairs.table;\r\n\r\n        // @if DEBUG\r\n        var metrics = engine.metrics;\r\n        // @endif\r\n        \r\n        for (var i = 0; i < broadphasePairs.length; i++) {\r\n            var bodyA = broadphasePairs[i][0], \r\n                bodyB = broadphasePairs[i][1];\r\n\r\n            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))\r\n                continue;\r\n            \r\n            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))\r\n                continue;\r\n\r\n            // @if DEBUG\r\n            metrics.midphaseTests += 1;\r\n            // @endif\r\n\r\n            // mid phase\r\n            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {\r\n                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {\r\n                    var partA = bodyA.parts[j];\r\n\r\n                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {\r\n                        var partB = bodyB.parts[k];\r\n\r\n                        if ((partA === bodyA && partB === bodyB) || Bounds.overlaps(partA.bounds, partB.bounds)) {\r\n                            // find a previous collision we could reuse\r\n                            var pairId = Pair.id(partA, partB),\r\n                                pair = pairsTable[pairId],\r\n                                previousCollision;\r\n\r\n                            if (pair && pair.isActive) {\r\n                                previousCollision = pair.collision;\r\n                            } else {\r\n                                previousCollision = null;\r\n                            }\r\n\r\n                            // narrow phase\r\n                            var collision = SAT.collides(partA, partB, previousCollision);\r\n\r\n                            // @if DEBUG\r\n                            metrics.narrowphaseTests += 1;\r\n                            if (collision.reused)\r\n                                metrics.narrowReuseCount += 1;\r\n                            // @endif\r\n\r\n                            if (collision.collided) {\r\n                                collisions.push(collision);\r\n                                // @if DEBUG\r\n                                metrics.narrowDetections += 1;\r\n                                // @endif\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return collisions;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\r\n     * See `body.collisionFilter` for more information.\r\n     * @method canCollide\r\n     * @param {} filterA\r\n     * @param {} filterB\r\n     * @return {bool} `true` if collision can occur\r\n     */\r\n    Detector.canCollide = function(filterA, filterB) {\r\n        if (filterA.group === filterB.group && filterA.group !== 0)\r\n            return filterA.group > 0;\r\n\r\n        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\r\n    };\r\n\r\n})();\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Detector","SAT","Pair","Bounds","collisions","Detector.collisions","broadphasePairs","engine","pairsTable","pairs","table","metrics","i","length","bodyA","bodyB","isStatic","isSleeping","canCollide","collisionFilter","midphaseTests","overlaps","bounds","j","parts","partA","k","partB","pairId","id","pair","collision","collides","previousCollision","isActive","narrowphaseTests","reused","narrowReuseCount","collided","push","narrowDetections","Detector.canCollide","filterA","filterB","group","mask","category"]
}
