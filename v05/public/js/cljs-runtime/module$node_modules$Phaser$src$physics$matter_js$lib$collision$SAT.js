shadow$provide.module$node_modules$Phaser$src$physics$matter_js$lib$collision$SAT=function(global,require,module,exports){var SAT={};module.exports=SAT;var Vertices=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices"),Vector=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vector");(function(){SAT.collides=function(bodyA,bodyB,previousCollision){var overlapBA=!1;if(previousCollision){var collision=bodyA.parent;overlapBA=bodyB.parent;collision=collision.speed*
collision.speed+collision.angularSpeed*collision.angularSpeed+overlapBA.speed*overlapBA.speed+overlapBA.angularSpeed*overlapBA.angularSpeed;overlapBA=previousCollision&&previousCollision.collided&&.2>collision;collision=previousCollision}else collision={collided:!1,bodyA:bodyA,bodyB:bodyB};if(previousCollision&&overlapBA){if(overlapBA=collision.axisBody,previousCollision=SAT._overlapAxes(overlapBA.vertices,(overlapBA===bodyA?bodyB:bodyA).vertices,[overlapBA.axes[previousCollision.axisNumber]]),collision.reused=
!0,0>=previousCollision.overlap)return collision.collided=!1,collision}else{previousCollision=SAT._overlapAxes(bodyA.vertices,bodyB.vertices,bodyA.axes);if(0>=previousCollision.overlap)return collision.collided=!1,collision;overlapBA=SAT._overlapAxes(bodyB.vertices,bodyA.vertices,bodyB.axes);if(0>=overlapBA.overlap)return collision.collided=!1,collision;previousCollision.overlap<overlapBA.overlap?collision.axisBody=bodyA:(previousCollision=overlapBA,collision.axisBody=bodyB);collision.axisNumber=
previousCollision.axisNumber}collision.bodyA=bodyA.id<bodyB.id?bodyA:bodyB;collision.bodyB=bodyA.id<bodyB.id?bodyB:bodyA;collision.collided=!0;collision.depth=previousCollision.overlap;collision.parentA=collision.bodyA.parent;collision.parentB=collision.bodyB.parent;bodyA=collision.bodyA;bodyB=collision.bodyB;0>Vector.dot(previousCollision.axis,Vector.sub(bodyB.position,bodyA.position))?collision.normal={x:previousCollision.axis.x,y:previousCollision.axis.y}:collision.normal={x:-previousCollision.axis.x,
y:-previousCollision.axis.y};collision.tangent=Vector.perp(collision.normal);collision.penetration=collision.penetration||{};collision.penetration.x=collision.normal.x*collision.depth;collision.penetration.y=collision.normal.y*collision.depth;previousCollision=SAT._findSupports(bodyA,bodyB,collision.normal);overlapBA=[];Vertices.contains(bodyA.vertices,previousCollision[0])&&overlapBA.push(previousCollision[0]);Vertices.contains(bodyA.vertices,previousCollision[1])&&overlapBA.push(previousCollision[1]);
2>overlapBA.length&&(bodyA=SAT._findSupports(bodyB,bodyA,Vector.neg(collision.normal)),Vertices.contains(bodyB.vertices,bodyA[0])&&overlapBA.push(bodyA[0]),2>overlapBA.length&&Vertices.contains(bodyB.vertices,bodyA[1])&&overlapBA.push(bodyA[1]));1>overlapBA.length&&(overlapBA=[previousCollision[0]]);collision.supports=overlapBA;return collision};SAT._overlapAxes=function(verticesA,verticesB,axes){for(var projectionA=Vector._temp[0],projectionB=Vector._temp[1],result={overlap:Number.MAX_VALUE},overlap,
axis,i=0;i<axes.length;i++){axis=axes[i];SAT._projectToAxis(projectionA,verticesA,axis);SAT._projectToAxis(projectionB,verticesB,axis);overlap=Math.min(projectionA.max-projectionB.min,projectionB.max-projectionA.min);if(0>=overlap){result.overlap=overlap;break}overlap<result.overlap&&(result.overlap=overlap,result.axis=axis,result.axisNumber=i)}return result};SAT._projectToAxis=function(projection,vertices,axis){for(var min=Vector.dot(vertices[0],axis),max=min,i=1;i<vertices.length;i+=1){var dot=
Vector.dot(vertices[i],axis);dot>max?max=dot:dot<min&&(min=dot)}projection.min=min;projection.max=max};SAT._findSupports=function(bodyA,bodyB,normal){var nearestDistance=Number.MAX_VALUE,vertexToBody=Vector._temp[0];bodyB=bodyB.vertices;bodyA=bodyA.position;var vertexB;for(vertexB=0;vertexB<bodyB.length;vertexB++){var vertex=bodyB[vertexB];vertexToBody.x=vertex.x-bodyA.x;vertexToBody.y=vertex.y-bodyA.y;var distance=-Vector.dot(normal,vertexToBody);if(distance<nearestDistance){nearestDistance=distance;
var vertexA=vertex}}vertex=bodyB[0<=vertexA.index-1?vertexA.index-1:bodyB.length-1];vertexToBody.x=vertex.x-bodyA.x;vertexToBody.y=vertex.y-bodyA.y;nearestDistance=-Vector.dot(normal,vertexToBody);vertexB=vertex;vertex=bodyB[(vertexA.index+1)%bodyB.length];vertexToBody.x=vertex.x-bodyA.x;vertexToBody.y=vertex.y-bodyA.y;distance=-Vector.dot(normal,vertexToBody);distance<nearestDistance&&(vertexB=vertex);return[vertexA,vertexB]}})()}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$lib$collision$SAT.js.map
