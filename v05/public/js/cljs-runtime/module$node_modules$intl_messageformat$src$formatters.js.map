{
"version":3,
"file":"module$node_modules$intl_messageformat$src$formatters.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/intl-messageformat/src/formatters.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$intl_messageformat$src$formatters\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatToParts = exports.isFormatXMLElementFn = exports.PART_TYPE = void 0;\nvar intl_messageformat_parser_1 = require(\"intl-messageformat-parser\");\nvar error_1 = require(\"./error\");\nvar PART_TYPE;\n(function (PART_TYPE) {\n    PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n    PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE = exports.PART_TYPE || (exports.PART_TYPE = {}));\nfunction mergeLiteral(parts) {\n    if (parts.length < 2) {\n        return parts;\n    }\n    return parts.reduce(function (all, part) {\n        var lastPart = all[all.length - 1];\n        if (!lastPart ||\n            lastPart.type !== 0 /* literal */ ||\n            part.type !== 0 /* literal */) {\n            all.push(part);\n        }\n        else {\n            lastPart.value += part.value;\n        }\n        return all;\n    }, []);\n}\nfunction isFormatXMLElementFn(el) {\n    return typeof el === 'function';\n}\nexports.isFormatXMLElementFn = isFormatXMLElementFn;\n// TODO(skeleton): add skeleton support\nfunction formatToParts(els, locales, formatters, formats, values, currentPluralValue, \n// For debugging\noriginalMessage) {\n    // Hot path for straight simple msg translations\n    if (els.length === 1 && intl_messageformat_parser_1.isLiteralElement(els[0])) {\n        return [\n            {\n                type: 0 /* literal */,\n                value: els[0].value,\n            },\n        ];\n    }\n    var result = [];\n    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n        var el = els_1[_i];\n        // Exit early for string parts.\n        if (intl_messageformat_parser_1.isLiteralElement(el)) {\n            result.push({\n                type: 0 /* literal */,\n                value: el.value,\n            });\n            continue;\n        }\n        // TODO: should this part be literal type?\n        // Replace `#` in plural rules with the actual numeric value.\n        if (intl_messageformat_parser_1.isPoundElement(el)) {\n            if (typeof currentPluralValue === 'number') {\n                result.push({\n                    type: 0 /* literal */,\n                    value: formatters.getNumberFormat(locales).format(currentPluralValue),\n                });\n            }\n            continue;\n        }\n        var varName = el.value;\n        // Enforce that all required values are provided by the caller.\n        if (!(values && varName in values)) {\n            throw new error_1.MissingValueError(varName, originalMessage);\n        }\n        var value = values[varName];\n        if (intl_messageformat_parser_1.isArgumentElement(el)) {\n            if (!value || typeof value === 'string' || typeof value === 'number') {\n                value =\n                    typeof value === 'string' || typeof value === 'number'\n                        ? String(value)\n                        : '';\n            }\n            result.push({\n                type: typeof value === 'string' ? 0 /* literal */ : 1 /* object */,\n                value: value,\n            });\n            continue;\n        }\n        // Recursively format plural and select parts' option \u2014 which can be a\n        // nested pattern structure. The choosing of the option to use is\n        // abstracted-by and delegated-to the part helper object.\n        if (intl_messageformat_parser_1.isDateElement(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.date[el.style]\n                : intl_messageformat_parser_1.isDateTimeSkeleton(el.style)\n                    ? el.style.parsedOptions\n                    : undefined;\n            result.push({\n                type: 0 /* literal */,\n                value: formatters\n                    .getDateTimeFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if (intl_messageformat_parser_1.isTimeElement(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.time[el.style]\n                : intl_messageformat_parser_1.isDateTimeSkeleton(el.style)\n                    ? el.style.parsedOptions\n                    : undefined;\n            result.push({\n                type: 0 /* literal */,\n                value: formatters\n                    .getDateTimeFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if (intl_messageformat_parser_1.isNumberElement(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.number[el.style]\n                : intl_messageformat_parser_1.isNumberSkeleton(el.style)\n                    ? el.style.parsedOptions\n                    : undefined;\n            if (style && style.scale) {\n                value =\n                    value *\n                        (style.scale || 1);\n            }\n            result.push({\n                type: 0 /* literal */,\n                value: formatters\n                    .getNumberFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if (intl_messageformat_parser_1.isTagElement(el)) {\n            var children = el.children, value_1 = el.value;\n            var formatFn = values[value_1];\n            if (!isFormatXMLElementFn(formatFn)) {\n                throw new error_1.InvalidValueTypeError(value_1, 'function', originalMessage);\n            }\n            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n            var chunks = formatFn(parts.map(function (p) { return p.value; }));\n            if (!Array.isArray(chunks)) {\n                chunks = [chunks];\n            }\n            result.push.apply(result, chunks.map(function (c) {\n                return {\n                    type: typeof c === 'string' ? 0 /* literal */ : 1 /* object */,\n                    value: c,\n                };\n            }));\n        }\n        if (intl_messageformat_parser_1.isSelectElement(el)) {\n            var opt = el.options[value] || el.options.other;\n            if (!opt) {\n                throw new error_1.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n            }\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n            continue;\n        }\n        if (intl_messageformat_parser_1.isPluralElement(el)) {\n            var opt = el.options[\"=\" + value];\n            if (!opt) {\n                if (!Intl.PluralRules) {\n                    throw new error_1.FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", \"MISSING_INTL_API\" /* MISSING_INTL_API */, originalMessage);\n                }\n                var rule = formatters\n                    .getPluralRules(locales, { type: el.pluralType })\n                    .select(value - (el.offset || 0));\n                opt = el.options[rule] || el.options.other;\n            }\n            if (!opt) {\n                throw new error_1.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n            }\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n            continue;\n        }\n    }\n    return mergeLiteral(result);\n}\nexports.formatToParts = formatToParts;\n\n};"],
"names":["shadow$provide","global","require","module","exports","mergeLiteral","parts","length","reduce","all","part","lastPart","type","value","push","isFormatXMLElementFn","el","formatToParts","els","locales","formatters","formats","values","currentPluralValue","originalMessage","intl_messageformat_parser_1","isLiteralElement","result","_i","isPoundElement","getNumberFormat","format","varName","error_1","MissingValueError","isArgumentElement","String","isDateElement","style","date","isDateTimeSkeleton","parsedOptions","undefined","getDateTimeFormat","isTimeElement","time","isNumberElement","number","isNumberSkeleton","scale","isTagElement","children","value_1","formatFn","InvalidValueTypeError","chunks","map","p","Array","isArray","apply","c","isSelectElement","opt","options","other","InvalidValueError","Object","keys","isPluralElement","Intl","PluralRules","FormatError","rule","getPluralRules","pluralType","select","offset","defineProperty","PART_TYPE"]
}
