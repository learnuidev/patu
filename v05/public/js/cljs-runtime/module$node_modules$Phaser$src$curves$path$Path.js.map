{
"version":3,
"file":"module$node_modules$Phaser$src$curves$path$Path.js",
"lineCount":12,
"mappings":"AAAAA,cAAA,gDAAA,CAAoE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CASxGC,MAAAA,CAAQH,OAAA,CAAQ,4CAAR,CACZ,KAAII,iBAAmBJ,OAAA,CAAQ,wDAAR,CAAvB,CACIK,aAAeL,OAAA,CAAQ,oDAAR,CACfM,QAAAA,CAAoBN,OAAA,CAAQ,8DAAR,CACxB,KAAIO,UAAYP,OAAA,CAAQ,iDAAR,CAAhB,CACIQ,WAAaR,OAAA,CAAQ,mDAAR,CADjB;AAEIS,qBAAuBT,OAAA,CAAQ,4DAAR,CAF3B,CAGIU,UAAYV,OAAA,CAAQ,yDAAR,CAHhB,CAIIW,YAAcX,OAAA,CAAQ,mDAAR,CAJlB,CAKIY,QAAUZ,OAAA,CAAQ,6CAAR,CALd,CA6BIa,KAAO,IAAIV,MAAJ,CAAU,CAEjBW,WAEAD,QAAc,CAACE,CAAD,CAAIC,CAAJ,CACd,CACcC,IAAAA,EAAV,GAAIF,CAAJ,GAAuBA,CAAvB,CAA2B,CAA3B,CACUE,KAAAA,EAAV,GAAID,CAAJ,GAAuBA,CAAvB,CAA2B,CAA3B,CAUA,KAAAE,KAAA,CAAY,EAUZ,KAAAC,OAAA,CAAc,EAUd,KAAAC,aAAA,CAAoB,EAUpB,KAAAC,UAAA,CAAiB,CAAA,CASjB,KAAAC,WAAA,CAAkB,IAAIV,OAUtB,KAAAW,UAAA,CAAiB,IAAIX,OAUrB;IAAAY,UAAA,CAAiB,IAAIZ,OAEJ,SAAjB,GAAI,MAAOG,EAAX,CAEI,IAAAU,SAAA,CAAcV,CAAd,CAFJ,CAMI,IAAAO,WAAAI,IAAA,CAAoBX,CAApB,CAAuBC,CAAvB,CA/ER,CALiB,CAkGjBW,IAAKA,QAAS,CAACC,KAAD,CACd,CACI,IAAAT,OAAAU,KAAA,CAAiBD,KAAjB,CAEA,OAAO,KAHX,CAnGiB,CAqHjBE,SAAUA,QAAS,CAACC,MAAD,CAASC,SAAT,CAAoBC,QAApB,CACnB,CACsBhB,IAAAA,EAAlB,GAAIe,SAAJ,GAA+BA,SAA/B,CAA2C,CAAA,CAA3C,CAEA,OAAO,KAAAE,UAAA,CAAeH,MAAf,CAAuBA,MAAvB,CAA+B,CAA/B,CAAkC,GAAlC,CAAuCC,SAAvC,CAAkDC,QAAlD,CAHX,CAtHiB,CAoIjBE,UAAWA,QAAS,EACpB,CAEI,IAAIb,WAAa,IAAAH,OAAA,CAAY,CAAZ,CAAAiB,SAAA,CAAwB,CAAxB,CAAjB,CACIC,SAAW,IAAAlB,OAAA,CAAY,IAAAA,OAAAmB,OAAZ,CAAiC,CAAjC,CAAAF,SAAA,CAA6C,CAA7C,CAEVd,WAAAiB,OAAA,CAAkBF,QAAlB,CAAL,EAGI,IAAAlB,OAAAU,KAAA,CAAiB,IAAItB,SAAJ,CAAc8B,QAAd,CAAwBf,UAAxB,CAAjB,CAGJ,OAAO,KAXX,CArIiB;AAkKjBkB,cAAeA,QAAS,CAACzB,CAAD,CAAIC,CAAJ,CAAOyB,SAAP,CAAkBC,SAAlB,CAA6BC,SAA7B,CAAwCC,SAAxC,CACxB,CACI,IAAIC,GAAK,IAAAC,YAAA,EAML/B,EAAJ,WAAiBH,QAAjB,EAEImC,SAEA,CAFKhC,CAEL,CADAiC,SACA,CADKhC,CACL,CAAAiC,CAAA,CAAKR,SAJT,GAQIM,SAEA,CAFK,IAAInC,OAAJ,CAAY6B,SAAZ,CAAuBC,SAAvB,CAEL,CADAM,SACA,CADK,IAAIpC,OAAJ,CAAY+B,SAAZ,CAAuBC,SAAvB,CACL,CAAAK,CAAA,CAAK,IAAIrC,OAAJ,CAAYG,CAAZ,CAAeC,CAAf,CAVT,CAaA,OAAO,KAAAW,IAAA,CAAS,IAAIvB,gBAAJ,CAAqByC,EAArB,CAAyBE,SAAzB,CAA6BC,SAA7B,CAAiCC,CAAjC,CAAT,CApBX,CAnKiB,CAyMjBC,kBAAmBA,QAAS,CAACnC,CAAD,CAAIC,CAAJ,CAAOmC,QAAP,CAAiBC,QAAjB,CAC5B,CACI,IAAIP,GAAK,IAAAC,YAAA,EAKL/B,EAAJ,WAAiBH,QAAjB,EAEImC,QACA,CADKhC,CACL,CAAAiC,CAAA,CAAKhC,CAHT,GAOI+B,QACA,CADK,IAAInC,OAAJ,CAAYuC,QAAZ,CAAsBC,QAAtB,CACL,CAAAJ,CAAA,CAAK,IAAIpC,OAAJ,CAAYG,CAAZ,CAAeC,CAAf,CART,CAWA,OAAO,KAAAW,IAAA,CAAS,IAAIlB,oBAAJ,CAAyBoC,EAAzB;AAA6BE,QAA7B,CAAiCC,CAAjC,CAAT,CAjBX,CA1MiB,CA2OjBK,KAAMA,QAAS,CAACC,QAAD,CAAWC,WAAX,CACf,CACI,IAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAArC,OAAAmB,OAApB,CAAwCkB,CAAA,EAAxC,CACA,CACI,IAAI5B,MAAQ,IAAAT,OAAA,CAAYqC,CAAZ,CAEP5B,MAAA6B,OAAL,EAKA7B,KAAAyB,KAAA,CAAWC,QAAX,CAAqBC,WAArB,CARJ,CAWA,MAAOD,SAbX,CA5OiB,CA2QjBpB,UAAWA,QAAS,CAACwB,OAAD,CAAUC,OAAV,CAAmBC,UAAnB,CAA+BC,QAA/B,CAAyC7B,SAAzC,CAAoDC,QAApD,CACpB,CACQ6B,OAAAA,CAAU,IAAIzD,YAAJ,CAAiB,CAAjB,CAAoB,CAApB,CAAuBqD,OAAvB,CAAgCC,OAAhC,CAAyCC,UAAzC,CAAqDC,QAArD,CAA+D7B,SAA/D,CAA0EC,QAA1E,CAEV8B,QAAAA,CAAM,IAAAjB,YAAA,CAAiB,IAAAvB,UAAjB,CAGNyC,WAAAA,CAAQF,OAAAG,cAAA,CAAsB,IAAAzC,UAAtB,CAEZuC,QAAAG,SAAA,CAAaF,UAAb,CAEAF,QAAA/C,EAAA,CAAYgD,OAAAhD,EACZ+C,QAAA9C,EAAA,CAAY+C,OAAA/C,EAEZ,OAAO,KAAAW,IAAA,CAASmC,OAAT,CAbX,CA5QiB;AAsSjBrC,SAAUA,QAAS,CAAC0C,IAAD,CACnB,CAGI,IAAAhD,OAAA,CAAc,EACd,KAAAC,aAAA,CAAoB,EAEpB,KAAAE,WAAAI,IAAA,CAAoByC,IAAApD,EAApB,CAA4BoD,IAAAnD,EAA5B,CAEA,KAAAK,UAAA,CAAiB8C,IAAA9C,UAEjB,KAAK,IAAImC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBW,IAAAhD,OAAAmB,OAApB,CAAwCkB,CAAA,EAAxC,CACA,CACI,IAAI5B,MAAQuC,IAAAhD,OAAA,CAAYqC,CAAZ,CAEZ,QAAQ5B,KAAAwC,KAAR,EAEI,KAAK,WAAL,CACI,IAAAzC,IAAA,CAASpB,SAAAkB,SAAA,CAAmBG,KAAnB,CAAT,CACA,MAEJ,MAAK,cAAL,CACI,IAAAD,IAAA,CAAStB,YAAAoB,SAAA,CAAsBG,KAAtB,CAAT,CACA,MAEJ,MAAK,aAAL,CACI,IAAAD,IAAA,CAAShB,WAAAc,SAAA,CAAqBG,KAArB,CAAT,CACA,MAEJ,MAAK,kBAAL,CACI,IAAAD,IAAA,CAASvB,gBAAAqB,SAAA,CAA0BG,KAA1B,CAAT,CACA,MAEJ,MAAK,sBAAL,CACI,IAAAD,IAAA,CAASlB,oBAAAgB,SAAA,CAA8BG,KAA9B,CAAT,CAnBR,CAHJ,CA2BA,MAAO,KAtCX,CAvSiB;AA6VjByC,UAAWA,QAAS,CAACC,GAAD,CAAMC,QAAN,CACpB,CACgBtD,IAAAA,EAAZ,GAAIqD,GAAJ,GAAyBA,GAAzB,CAA+B,IAAI5D,SAAnC,CACiBO,KAAAA,EAAjB,GAAIsD,QAAJ,GAA8BA,QAA9B,CAAyC,EAAzC,CAEAD,IAAAvD,EAAA,CAAQyD,MAAAC,UACRH,IAAAtD,EAAA,CAAQwD,MAAAC,UAMR,KAJA,IAAIC,OAAS,IAAIhE,SAAjB,CACIiE,SAAWH,MAAAI,iBADf,CAEIC,UAAYL,MAAAI,iBAFhB,CAISpB,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAArC,OAAAmB,OAApB,CAAwCkB,CAAA,EAAxC,CACA,CACI,IAAI5B,MAAQ,IAAAT,OAAA,CAAYqC,CAAZ,CAEP5B,MAAA6B,OAAL,GAKA7B,KAAAyC,UAAA,CAAgBK,MAAhB,CAAwBH,QAAxB,CAMA,CAJAD,GAAAvD,EAIA,CAJQ+D,IAAAC,IAAA,CAAST,GAAAvD,EAAT,CAAgB2D,MAAA3D,EAAhB,CAIR,CAHAuD,GAAAtD,EAGA,CAHQ8D,IAAAC,IAAA,CAAST,GAAAtD,EAAT,CAAgB0D,MAAA1D,EAAhB,CAGR,CADA2D,QACA,CADWG,IAAAE,IAAA,CAASL,QAAT,CAAmBD,MAAAO,MAAnB,CACX,CAAAJ,SAAA,CAAYC,IAAAE,IAAA,CAASH,SAAT,CAAoBH,MAAAQ,OAApB,CAXZ,CAHJ,CAiBAZ,GAAAW,MAAA;AAAYN,QACZL,IAAAY,OAAA,CAAaL,SAEb,OAAOP,IAhCX,CA9ViB,CAyYjBa,gBAAiBA,QAAS,EAC1B,CAGI,GAAI,IAAA/D,aAAAkB,OAAJ,GAAiC,IAAAnB,OAAAmB,OAAjC,CAEI,MAAO,KAAAlB,aASX,KAHA,IAAIgE,QAAU,EAAd,CACIC,KAAO,CADX,CAGS7B,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAArC,OAAAmB,OAApB,CAAwCkB,CAAA,EAAxC,CAEI6B,IAEA,EAFQ,IAAAlE,OAAA,CAAYqC,CAAZ,CAAA8B,UAAA,EAER,CAAAF,OAAAvD,KAAA,CAAawD,IAAb,CAKJ,OAFA,KAAAjE,aAEA,CAFoBgE,OArBxB,CA1YiB,CAgbjBtC,YAAaA,QAAS,CAACwB,GAAD,CACtB,CACgBrD,IAAAA,EAAZ,GAAIqD,GAAJ,GAAyBA,GAAzB,CAA+B,IAAI1D,OAAnC,CAEyB,EAAzB,CAAI,IAAAO,OAAAmB,OAAJ,CAEI,IAAAnB,OAAA,CAAY,IAAAA,OAAAmB,OAAZ,CAAiC,CAAjC,CAAAF,SAAA,CAA6C,CAA7C,CAAgDkC,GAAhD,CAFJ,CAMIA,GAAAiB,KAAA,CAAS,IAAAjE,WAAT,CAGJ,OAAOgD,IAZX,CAjbiB,CAwcjBgB,UAAWA,QAAS,EACpB,CACI,IAAIE,KAAO,IAAAL,gBAAA,EAEX;MAAOK,KAAA,CAAKA,IAAAlD,OAAL,CAAmB,CAAnB,CAHX,CAzciB,CAqejBF,SAAUA,QAAS,CAACqD,CAAD,CAAInB,GAAJ,CACnB,CACgBrD,IAAAA,EAAZ,GAAIqD,GAAJ,GAAyBA,GAAzB,CAA+B,IAAI1D,OAAnC,CAEA,KAAI8E,EAAID,CAAJC,CAAQ,IAAAJ,UAAA,EAAZ,CACIK,aAAe,IAAAR,gBAAA,EAGnB,KAFI3B,CAEJ,CAFQ,CAER,CAAOA,CAAP,CAAWmC,YAAArD,OAAX,CAAA,CACA,CACI,GAAIqD,YAAA,CAAanC,CAAb,CAAJ,EAAuBkC,CAAvB,CAQI,MANIE,EAMG,CANID,YAAA,CAAanC,CAAb,CAMJ,CANsBkC,CAMtB,CALH9D,CAKG,CALK,IAAAT,OAAA,CAAYqC,CAAZ,CAKL,CAHHqC,YAGG,CAHajE,CAAA0D,UAAA,EAGb,CAAA1D,CAAAkE,WAAA,CAFoB,CAAnBC,GAACF,YAADE,CAAwB,CAAxBA,CAA4B,CAA5BA,CAAgCH,CAAhCG,CAAuCF,YAExC,CAAoBvB,GAApB,CAGXd,EAAA,EAZJ,CAgBA,MAAO,KAxBX,CAteiB,CA2gBjBwC,UAAWA,QAAS,CAACC,SAAD,CACpB,CACsBhF,IAAAA,EAAlB,GAAIgF,SAAJ,GAA+BA,SAA/B,CAA2C,EAA3C,CAKA,KAHA,IAAIC,OAAS,EAAb,CACIC,IADJ,CAGS3C,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAArC,OAAAmB,OAApB,CAAwCkB,CAAA,EAAxC,CACA,CACI,IAAI5B,MAAQ,IAAAT,OAAA,CAAYqC,CAAZ,CAEZ,IAAK5B,KAAA6B,OAAL,CAAA,CAKA,IAAI2C;AAAaxE,KAAAyE,cAAA,CAAoBJ,SAApB,CAEbK,MAAAA,CAAM1E,KAAAoE,UAAA,CAAgBI,UAAhB,CAEV,KAASG,UAAT,CAAa,CAAb,CAAgBA,UAAhB,CAAoBD,KAAAhE,OAApB,CAAgCiE,UAAA,EAAhC,CACA,CACI,IAAIC,MAAQF,KAAA,CAAIC,UAAJ,CAERJ,KAAJ,EAAYA,IAAA5D,OAAA,CAAYiE,KAAZ,CAAZ,GAMAN,MAAArE,KAAA,CAAY2E,KAAZ,CAEA,CAAAL,IAAA,CAAOK,KARP,CAHJ,CAVA,CAHJ,CA4BI,IAAAnF,UAAJ,EAAsC,CAAtC,CAAsB6E,MAAA5D,OAAtB,EAA2C,CAAC4D,MAAA,CAAOA,MAAA5D,OAAP,CAAuB,CAAvB,CAAAC,OAAA,CAAiC2D,MAAA,CAAO,CAAP,CAAjC,CAA5C,EAEIA,MAAArE,KAAA,CAAYqE,MAAA,CAAO,CAAP,CAAZ,CAGJ,OAAOA,OAxCX,CA5gBiB,CAmkBjBO,eAAgBA,QAAS,CAACnC,GAAD,CACzB,CACgBrD,IAAAA,EAAZ,GAAIqD,GAAJ,GAAyBA,GAAzB,CAA+B,IAAI1D,OAAnC,CAEA,OAAO,KAAAwB,SAAA,CAAc0C,IAAA4B,OAAA,EAAd,CAA6BpC,GAA7B,CAHX,CApkBiB,CAolBjBqC,gBAAiBA,QAAS,CAACV,SAAD,CAC1B,CACsBhF,IAAAA,EAAlB,GAAIgF,SAAJ,GAA+BA,SAA/B,CAA2C,EAA3C,CAIA,KAFA,IAAIC;AAAS,EAAb,CAES1C,EAAI,CAAb,CAAgBA,CAAhB,EAAqByC,SAArB,CAAgCzC,CAAA,EAAhC,CAEI0C,MAAArE,KAAA,CAAY,IAAAO,SAAA,CAAcoB,CAAd,CAAkByC,SAAlB,CAAZ,CAGA,KAAA5E,UAAJ,EAEI6E,MAAArE,KAAA,CAAYqE,MAAA,CAAO,CAAP,CAAZ,CAGJ,OAAOA,OAfX,CArlBiB,CAmnBjBjC,cAAeA,QAAS,CAACK,GAAD,CACxB,CACgBrD,IAAAA,EAAZ,GAAIqD,GAAJ,GAAyBA,GAAzB,CAA+B,IAAI1D,OAAnC,CAEA,OAAO0D,IAAAiB,KAAA,CAAS,IAAAjE,WAAT,CAHX,CApnBiB,CAuoBjBsF,OAAQA,QAAS,CAAC7F,CAAD,CAAIC,CAAJ,CACjB,CACQD,CAAJ,WAAiBH,QAAjB,CAEI,IAAAY,UAAA+D,KAAA,CAAoBxE,CAApB,CAFJ,CAMI,IAAAS,UAAAE,IAAA,CAAmBX,CAAnB,CAAsBC,CAAtB,CAGA+C,EAAAA,CAAM,IAAAjB,YAAA,CAAiB,IAAAvB,UAAjB,CAEV,OAAO,KAAAI,IAAA,CAAS,IAAIpB,SAAJ,CAAc,CAAEwD,CAAAhD,EAAF,CAASgD,CAAA/C,EAAT,CAAgB,IAAAQ,UAAAT,EAAhB,CAAkC,IAAAS,UAAAR,EAAlC,CAAd,CAAT,CAZX,CAxoBiB,CAmqBjB6F,SAAUA,QAAS,CAACX,MAAD,CACnB,CACIA,MAAAY,QAAA,CAAe,IAAAhE,YAAA,EAAf,CAEA,OAAO,KAAAnB,IAAA,CAAS,IAAIhB,WAAJ,CAAgBuF,MAAhB,CAAT,CAHX,CApqBiB;AAqrBjBa,OAAQA,QAAS,CAAChG,CAAD,CAAIC,CAAJ,CACjB,CACI,MAAO,KAAAW,IAAA,CAAS,IAAInB,UAAJ,CAAeO,CAAf,CAAkBC,CAAlB,CAAT,CADX,CAtrBiB,CAksBjBgG,OAAQA,QAAS,EACjB,CAGI,IAFA,IAAI1C,IAAM,EAAV,CAESd,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAArC,OAAAmB,OAApB,CAAwCkB,CAAA,EAAxC,CAEIc,GAAAzC,KAAA,CAAS,IAAAV,OAAA,CAAYqC,CAAZ,CAAAwD,OAAA,EAAT,CAGJ,OAAO,CACH5C,KAAM,MADH,CAEHrD,EAAG,IAAAO,WAAAP,EAFA,CAGHC,EAAG,IAAAM,WAAAN,EAHA,CAIHK,UAAW,IAAAA,UAJR,CAKHF,OAAQmD,GALL,CARX,CAnsBiB,CA4tBjB2C,iBAAkBA,QAAS,EAC3B,CACI,IAAA7F,aAAA,CAAoB,EAEpB,KAAA+D,gBAAA,EAHJ,CA7tBiB,CAyuBjB+B,QAASA,QAAS,EAClB,CACI,IAAA/F,OAAAmB,OAAA,CAAqB,CACrB,KAAAlB,aAAAkB,OAAA,CAA2B,CAC3B,KAAAhB,WAAA,CAAkBL,IAAAA,EAHtB,CA1uBiB,CAAV,CA6vBXX,QAAA6G,SAAA,CAA2B,MAA3B,CAAmC,QAAS,CAACpG,CAAD,CAAIC,CAAJ,CAC5C,CACI,MAAO,KAAIH,IAAJ,CAASE,CAAT,CAAYC,CAAZ,CADX,CADA,CAaAf,OAAAC,QAAA,CAAiBW,IApzB2F;",
"sources":["node_modules/Phaser/src/curves/path/Path.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$curves$path$Path\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CubicBezierCurve = require('../CubicBezierCurve');\r\nvar EllipseCurve = require('../EllipseCurve');\r\nvar GameObjectFactory = require('../../gameobjects/GameObjectFactory');\r\nvar LineCurve = require('../LineCurve');\r\nvar MovePathTo = require('./MoveTo');\r\nvar QuadraticBezierCurve = require('../QuadraticBezierCurve');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar SplineCurve = require('../SplineCurve');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @typedef {object} JSONPath\r\n *\r\n * @property {string} type - The of the curve.\r\n * @property {number} x - [description]\r\n * @property {number} y - [description]\r\n * @property {boolean} autoClose - The path is auto closed.\r\n * @property {JSONCurve[]} curves - The list of the curves\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Path\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - [description]\r\n * @param {number} [y=0] - [description]\r\n */\r\nvar Path = new Class({\r\n\r\n    initialize:\r\n\r\n    function Path (x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Path#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Path#curves\r\n         * @type {Phaser.Curves.Curve[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.curves = [];\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Path#cacheLengths\r\n         * @type {number[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.cacheLengths = [];\r\n\r\n        /**\r\n         * Automatically closes the path.\r\n         *\r\n         * @name Phaser.Curves.Path#autoClose\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.autoClose = false;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Path#startPoint\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.startPoint = new Vector2();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Path#_tmpVec2A\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2A = new Vector2();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Path#_tmpVec2B\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2B = new Vector2();\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.fromJSON(x);\r\n        }\r\n        else\r\n        {\r\n            this.startPoint.set(x, y);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Curves.Curve} curve - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    add: function (curve)\r\n    {\r\n        this.curves.push(curve);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#circleTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - [description]\r\n     * @param {boolean} [clockwise=false] - [description]\r\n     * @param {number} [rotation=0] - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    circleTo: function (radius, clockwise, rotation)\r\n    {\r\n        if (clockwise === undefined) { clockwise = false; }\r\n\r\n        return this.ellipseTo(radius, radius, 0, 360, clockwise, rotation);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#closePath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    closePath: function ()\r\n    {\r\n        // Add a line curve if start and end of lines are not connected\r\n        var startPoint = this.curves[0].getPoint(0);\r\n        var endPoint = this.curves[this.curves.length - 1].getPoint(1);\r\n\r\n        if (!startPoint.equals(endPoint))\r\n        {\r\n            //  This will copy a reference to the vectors, which probably isn't sensible\r\n            this.curves.push(new LineCurve(endPoint, startPoint));\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a cubic bezier curve starting at the previous end point and ending at p3, using p1 and p2 as control points.\r\n     *\r\n     * @method Phaser.Curves.Path#cubicBezierTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Math.Vector2)} x - The x coordinate of the end point. Or, if a Vec2, the p1 value.\r\n     * @param {(number|Phaser.Math.Vector2)} y - The y coordinate of the end point. Or, if a Vec2, the p2 value.\r\n     * @param {(number|Phaser.Math.Vector2)} control1X - The x coordinate of the first control point. Or, if a Vec2, the p3 value.\r\n     * @param {number} [control1Y] - The y coordinate of the first control point. Not used if vec2s are provided as the first 3 arguments.\r\n     * @param {number} [control2X] - The x coordinate of the second control point. Not used if vec2s are provided as the first 3 arguments.\r\n     * @param {number} [control2Y] - The y coordinate of the second control point. Not used if vec2s are provided as the first 3 arguments.\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    cubicBezierTo: function (x, y, control1X, control1Y, control2X, control2Y)\r\n    {\r\n        var p0 = this.getEndPoint();\r\n        var p1;\r\n        var p2;\r\n        var p3;\r\n\r\n        //  Assume they're all vec2s\r\n        if (x instanceof Vector2)\r\n        {\r\n            p1 = x;\r\n            p2 = y;\r\n            p3 = control1X;\r\n        }\r\n        else\r\n        {\r\n            p1 = new Vector2(control1X, control1Y);\r\n            p2 = new Vector2(control2X, control2Y);\r\n            p3 = new Vector2(x, y);\r\n        }\r\n\r\n        return this.add(new CubicBezierCurve(p0, p1, p2, p3));\r\n    },\r\n\r\n    //  Creates a quadratic bezier curve starting at the previous end point and ending at p2, using p1 as a control point\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#quadraticBezierTo\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(number|Phaser.Math.Vector2[])} x - [description]\r\n     * @param {number} [y] - [description]\r\n     * @param {number} [controlX] - [description]\r\n     * @param {number} [controlY] - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    quadraticBezierTo: function (x, y, controlX, controlY)\r\n    {\r\n        var p0 = this.getEndPoint();\r\n        var p1;\r\n        var p2;\r\n\r\n        //  Assume they're all vec2s\r\n        if (x instanceof Vector2)\r\n        {\r\n            p1 = x;\r\n            p2 = y;\r\n        }\r\n        else\r\n        {\r\n            p1 = new Vector2(controlX, controlY);\r\n            p2 = new Vector2(x, y);\r\n        }\r\n\r\n        return this.add(new QuadraticBezierCurve(p0, p1, p2));\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [out,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - [description]\r\n     * @param {integer} [pointsTotal=32] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} [description]\r\n     */\r\n    draw: function (graphics, pointsTotal)\r\n    {\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            var curve = this.curves[i];\r\n\r\n            if (!curve.active)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            curve.draw(graphics, pointsTotal);\r\n        }\r\n\r\n        return graphics;\r\n    },\r\n\r\n    /**\r\n     * Creates an ellipse curve positioned at the previous end point, using the given parameters.\r\n     *\r\n     * @method Phaser.Curves.Path#ellipseTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} xRadius - [description]\r\n     * @param {number} yRadius - [description]\r\n     * @param {number} startAngle - [description]\r\n     * @param {number} endAngle - [description]\r\n     * @param {boolean} clockwise - [description]\r\n     * @param {number} rotation - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    ellipseTo: function (xRadius, yRadius, startAngle, endAngle, clockwise, rotation)\r\n    {\r\n        var ellipse = new EllipseCurve(0, 0, xRadius, yRadius, startAngle, endAngle, clockwise, rotation);\r\n\r\n        var end = this.getEndPoint(this._tmpVec2A);\r\n\r\n        //  Calculate where to center the ellipse\r\n        var start = ellipse.getStartPoint(this._tmpVec2B);\r\n\r\n        end.subtract(start);\r\n\r\n        ellipse.x = end.x;\r\n        ellipse.y = end.y;\r\n\r\n        return this.add(ellipse);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} data - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    fromJSON: function (data)\r\n    {\r\n        //  data should be an object matching the Path.toJSON object structure.\r\n\r\n        this.curves = [];\r\n        this.cacheLengths = [];\r\n\r\n        this.startPoint.set(data.x, data.y);\r\n\r\n        this.autoClose = data.autoClose;\r\n\r\n        for (var i = 0; i < data.curves.length; i++)\r\n        {\r\n            var curve = data.curves[i];\r\n\r\n            switch (curve.type)\r\n            {\r\n                case 'LineCurve':\r\n                    this.add(LineCurve.fromJSON(curve));\r\n                    break;\r\n\r\n                case 'EllipseCurve':\r\n                    this.add(EllipseCurve.fromJSON(curve));\r\n                    break;\r\n\r\n                case 'SplineCurve':\r\n                    this.add(SplineCurve.fromJSON(curve));\r\n                    break;\r\n\r\n                case 'CubicBezierCurve':\r\n                    this.add(CubicBezierCurve.fromJSON(curve));\r\n                    break;\r\n\r\n                case 'QuadraticBezierCurve':\r\n                    this.add(QuadraticBezierCurve.fromJSON(curve));\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - [description]\r\n     * @param {integer} [accuracy=16] - [description]\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} [description]\r\n     */\r\n    getBounds: function (out, accuracy)\r\n    {\r\n        if (out === undefined) { out = new Rectangle(); }\r\n        if (accuracy === undefined) { accuracy = 16; }\r\n\r\n        out.x = Number.MAX_VALUE;\r\n        out.y = Number.MAX_VALUE;\r\n\r\n        var bounds = new Rectangle();\r\n        var maxRight = Number.MIN_SAFE_INTEGER;\r\n        var maxBottom = Number.MIN_SAFE_INTEGER;\r\n\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            var curve = this.curves[i];\r\n\r\n            if (!curve.active)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            curve.getBounds(bounds, accuracy);\r\n\r\n            out.x = Math.min(out.x, bounds.x);\r\n            out.y = Math.min(out.y, bounds.y);\r\n\r\n            maxRight = Math.max(maxRight, bounds.right);\r\n            maxBottom = Math.max(maxBottom, bounds.bottom);\r\n        }\r\n\r\n        out.right = maxRight;\r\n        out.bottom = maxBottom;\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getCurveLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number[]} [description]\r\n     */\r\n    getCurveLengths: function ()\r\n    {\r\n        // We use cache values if curves and cache array are same length\r\n\r\n        if (this.cacheLengths.length === this.curves.length)\r\n        {\r\n            return this.cacheLengths;\r\n        }\r\n\r\n        // Get length of sub-curve\r\n        // Push sums into cached array\r\n\r\n        var lengths = [];\r\n        var sums = 0;\r\n\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            sums += this.curves[i].getLength();\r\n\r\n            lengths.push(sums);\r\n        }\r\n\r\n        this.cacheLengths = lengths;\r\n\r\n        return lengths;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getEndPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getEndPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        if (this.curves.length > 0)\r\n        {\r\n            this.curves[this.curves.length - 1].getPoint(1, out);\r\n        }\r\n        else\r\n        {\r\n            out.copy(this.startPoint);\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getLength: function ()\r\n    {\r\n        var lens = this.getCurveLengths();\r\n\r\n        return lens[lens.length - 1];\r\n    },\r\n\r\n    // To get accurate point with reference to\r\n    // entire path distance at time t,\r\n    // following has to be done:\r\n\r\n    // 1. Length of each sub path have to be known\r\n    // 2. Locate and identify type of curve\r\n    // 3. Get t for the curve\r\n    // 4. Return curve.getPointAt(t')\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {?Phaser.Math.Vector2} [description]\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var d = t * this.getLength();\r\n        var curveLengths = this.getCurveLengths();\r\n        var i = 0;\r\n\r\n        while (i < curveLengths.length)\r\n        {\r\n            if (curveLengths[i] >= d)\r\n            {\r\n                var diff = curveLengths[i] - d;\r\n                var curve = this.curves[i];\r\n\r\n                var segmentLength = curve.getLength();\r\n                var u = (segmentLength === 0) ? 0 : 1 - diff / segmentLength;\r\n\r\n                return curve.getPointAt(u, out);\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        // loop where sum != 0, sum > d , sum+1 <d\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions=12] - The number of points to divide the path in to.\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} An array of Vector2 objects that containing the points along the Path.\r\n     */\r\n    getPoints: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = 12; }\r\n\r\n        var points = [];\r\n        var last;\r\n\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            var curve = this.curves[i];\r\n\r\n            if (!curve.active)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var resolution = curve.getResolution(divisions);\r\n\r\n            var pts = curve.getPoints(resolution);\r\n\r\n            for (var j = 0; j < pts.length; j++)\r\n            {\r\n                var point = pts[j];\r\n\r\n                if (last && last.equals(point))\r\n                {\r\n                    // ensures no consecutive points are duplicates\r\n                    continue;\r\n                }\r\n\r\n                points.push(point);\r\n\r\n                last = point;\r\n            }\r\n        }\r\n\r\n        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0]))\r\n        {\r\n            points.push(points[0]);\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - `Vector2` instance that should be used for storing the result. If `undefined` a new `Vector2` will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getRandomPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPoint(Math.random(), out);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getSpacedPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions=40] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} [description]\r\n     */\r\n    getSpacedPoints: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = 40; }\r\n\r\n        var points = [];\r\n\r\n        for (var i = 0; i <= divisions; i++)\r\n        {\r\n            points.push(this.getPoint(i / divisions));\r\n        }\r\n\r\n        if (this.autoClose)\r\n        {\r\n            points.push(points[0]);\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return out.copy(this.startPoint);\r\n    },\r\n\r\n    //  Creates a line curve from the previous end point to x/y\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#lineTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Math.Vector2)} x - [description]\r\n     * @param {number} [y] - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    lineTo: function (x, y)\r\n    {\r\n        if (x instanceof Vector2)\r\n        {\r\n            this._tmpVec2B.copy(x);\r\n        }\r\n        else\r\n        {\r\n            this._tmpVec2B.set(x, y);\r\n        }\r\n\r\n        var end = this.getEndPoint(this._tmpVec2A);\r\n\r\n        return this.add(new LineCurve([ end.x, end.y, this._tmpVec2B.x, this._tmpVec2B.y ]));\r\n    },\r\n\r\n    //  Creates a spline curve starting at the previous end point, using the given parameters\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#splineTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2[]} points - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    splineTo: function (points)\r\n    {\r\n        points.unshift(this.getEndPoint());\r\n\r\n        return this.add(new SplineCurve(points));\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */\r\n    moveTo: function (x, y)\r\n    {\r\n        return this.add(new MovePathTo(x, y));\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONPath} [description]\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var out = [];\r\n\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            out.push(this.curves[i].toJSON());\r\n        }\r\n\r\n        return {\r\n            type: 'Path',\r\n            x: this.startPoint.x,\r\n            y: this.startPoint.y,\r\n            autoClose: this.autoClose,\r\n            curves: out\r\n        };\r\n    },\r\n\r\n    // cacheLengths must be recalculated.\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#updateArcLengths\r\n     * @since 3.0.0\r\n     */\r\n    updateArcLengths: function ()\r\n    {\r\n        this.cacheLengths = [];\r\n\r\n        this.getCurveLengths();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.curves.length = 0;\r\n        this.cacheLengths.length = 0;\r\n        this.startPoint = undefined;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Creates a new Path Object.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#path\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Path.\r\n * @param {number} y - The vertical position of this Path.\r\n *\r\n * @return {Phaser.Curves.Path} The Path Object that was created.\r\n */\r\nGameObjectFactory.register('path', function (x, y)\r\n{\r\n    return new Path(x, y);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n\r\nmodule.exports = Path;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Class","CubicBezierCurve","EllipseCurve","GameObjectFactory","LineCurve","MovePathTo","QuadraticBezierCurve","Rectangle","SplineCurve","Vector2","Path","initialize","x","y","undefined","name","curves","cacheLengths","autoClose","startPoint","_tmpVec2A","_tmpVec2B","fromJSON","set","add","curve","push","circleTo","radius","clockwise","rotation","ellipseTo","closePath","getPoint","endPoint","length","equals","cubicBezierTo","control1X","control1Y","control2X","control2Y","p0","getEndPoint","p1","p2","p3","quadraticBezierTo","controlX","controlY","draw","graphics","pointsTotal","i","active","xRadius","yRadius","startAngle","endAngle","ellipse","end","start","getStartPoint","subtract","data","type","getBounds","out","accuracy","Number","MAX_VALUE","bounds","maxRight","MIN_SAFE_INTEGER","maxBottom","Math","min","max","right","bottom","getCurveLengths","lengths","sums","getLength","copy","lens","t","d","curveLengths","diff","segmentLength","getPointAt","u","getPoints","divisions","points","last","resolution","getResolution","pts","j","point","getRandomPoint","random","getSpacedPoints","lineTo","splineTo","unshift","moveTo","toJSON","updateArcLengths","destroy","register"]
}
