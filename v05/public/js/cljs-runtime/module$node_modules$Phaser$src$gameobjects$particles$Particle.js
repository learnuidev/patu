shadow$provide.module$node_modules$Phaser$src$gameobjects$particles$Particle=function(global,require,module,exports){global=require("module$node_modules$Phaser$src$utils$Class");var DegToRad=require("module$node_modules$Phaser$src$math$DegToRad"),DistanceBetween=require("module$node_modules$Phaser$src$math$distance$DistanceBetween");require=new global({initialize:function(emitter){this.emitter=emitter;this.frame=null;this.accelerationY=this.accelerationX=this.velocityY=this.velocityX=this.y=this.x=
this.index=0;this.maxVelocityY=this.maxVelocityX=1E4;this.bounce=0;this.alpha=this.scaleY=this.scaleX=1;this.rotation=this.angle=0;this.tint=16777215;this.lifeCurrent=this.life=1E3;this.lifeT=this.delayCurrent=0;this.data={tint:{min:16777215,max:16777215,current:16777215},alpha:{min:1,max:1},rotate:{min:0,max:0},scaleX:{min:1,max:1},scaleY:{min:1,max:1}}},isAlive:function(){return 0<this.lifeCurrent},fire:function(x,y){var emitter=this.emitter;this.frame=emitter.getFrame();emitter.emitZone&&emitter.emitZone.getPoint(this);
void 0===x?(emitter.follow&&(this.x+=emitter.follow.x+emitter.followOffset.x),this.x+=emitter.x.onEmit(this,"x")):this.x+=x;void 0===y?(emitter.follow&&(this.y+=emitter.follow.y+emitter.followOffset.y),this.y+=emitter.y.onEmit(this,"y")):this.y+=y;this.lifeCurrent=this.life=emitter.lifespan.onEmit(this,"lifespan");this.lifeT=0;x=emitter.speedX.onEmit(this,"speedX");y=emitter.speedY?emitter.speedY.onEmit(this,"speedY"):x;if(emitter.radial){var rad=DegToRad(emitter.angle.onEmit(this,"angle"));this.velocityX=
Math.cos(rad)*Math.abs(x);this.velocityY=Math.sin(rad)*Math.abs(y)}else emitter.moveTo?(y=emitter.moveToX.onEmit(this,"moveToX"),rad=emitter.moveToY?emitter.moveToY.onEmit(this,"moveToY"):y,x=Math.atan2(rad-this.y,y-this.x),y=DistanceBetween(this.x,this.y,y,rad)/(this.life/1E3),this.velocityX=Math.cos(x)*y,this.velocityY=Math.sin(x)*y):(this.velocityX=x,this.velocityY=y);emitter.acceleration&&(this.accelerationX=emitter.accelerationX.onEmit(this,"accelerationX"),this.accelerationY=emitter.accelerationY.onEmit(this,
"accelerationY"));this.maxVelocityX=emitter.maxVelocityX.onEmit(this,"maxVelocityX");this.maxVelocityY=emitter.maxVelocityY.onEmit(this,"maxVelocityY");this.delayCurrent=emitter.delay.onEmit(this,"delay");this.scaleX=emitter.scaleX.onEmit(this,"scaleX");this.scaleY=emitter.scaleY?emitter.scaleY.onEmit(this,"scaleY"):this.scaleX;this.angle=emitter.rotate.onEmit(this,"rotate");this.rotation=DegToRad(this.angle);this.bounce=emitter.bounce.onEmit(this,"bounce");this.alpha=emitter.alpha.onEmit(this,"alpha");
this.tint=emitter.tint.onEmit(this,"tint");this.index=emitter.alive.length},computeVelocity:function(emitter,delta,step,processors){var vx=this.velocityX,vy=this.velocityY,ax=this.accelerationX,ay=this.accelerationY,mx=this.maxVelocityX,my=this.maxVelocityY;vx+=emitter.gravityX*step;vy+=emitter.gravityY*step;ax&&(vx+=ax*step);ay&&(vy+=ay*step);vx>mx?vx=mx:vx<-mx&&(vx=-mx);vy>my?vy=my:vy<-my&&(vy=-my);this.velocityX=vx;this.velocityY=vy;for(emitter=0;emitter<processors.length;emitter++)processors[emitter].update(this,
delta,step)},checkBounds:function(emitter){var bounds=emitter.bounds,bounce=-this.bounce;this.x<bounds.x&&emitter.collideLeft?(this.x=bounds.x,this.velocityX*=bounce):this.x>bounds.right&&emitter.collideRight&&(this.x=bounds.right,this.velocityX*=bounce);this.y<bounds.y&&emitter.collideTop?(this.y=bounds.y,this.velocityY*=bounce):this.y>bounds.bottom&&emitter.collideBottom&&(this.y=bounds.bottom,this.velocityY*=bounce)},update:function(delta,step,processors){if(0<this.delayCurrent)return this.delayCurrent-=
delta,!1;var emitter=this.emitter,t=1-this.lifeCurrent/this.life;this.lifeT=t;this.computeVelocity(emitter,delta,step,processors);this.x+=this.velocityX*step;this.y+=this.velocityY*step;emitter.bounds&&this.checkBounds(emitter);if(emitter.deathZone&&emitter.deathZone.willKill(this))return this.lifeCurrent=0,!0;this.scaleX=emitter.scaleX.onUpdate(this,"scaleX",t,this.scaleX);this.scaleY=emitter.scaleY?emitter.scaleY.onUpdate(this,"scaleY",t,this.scaleY):this.scaleX;this.angle=emitter.rotate.onUpdate(this,
"rotate",t,this.angle);this.rotation=DegToRad(this.angle);this.alpha=emitter.alpha.onUpdate(this,"alpha",t,this.alpha);this.tint=emitter.tint.onUpdate(this,"tint",t,this.tint);this.lifeCurrent-=delta;return 0>=this.lifeCurrent}});module.exports=require}
//# sourceMappingURL=module$node_modules$Phaser$src$gameobjects$particles$Particle.js.map
