{"version":3,"sources":["app/kaboom_next/math.cljs"],"mappings":";;;;;;;;AAMA,AAOA,AAAA,AAAMA,AAAQC;AAAd,AACE,AAAAC,AAAS,AAACC,AAAQF;;AAEpB,AAAKG,AAAQ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACJ;AAId,AAAKK,AAAQ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACL;AAGd,AAAKM,AAAQ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACN;AAGd,AAAA,AAAMO,AAAOC;AAAb,AACE,AAAA,AAACC,AAAI,AAAS,AAAUD;;AAE1B,AAAA,AAAME,AAAOF;AAAb,AACE,AAAA,AAACC,AAAI,AAAS,AAAUD;;AAE1B,AAAA,AAAMG,AAAOH;AAAb,AACE,AAAA,AAACC,AAAI,AAAS,AAAUD;;AAG1B,AAcA;;;;;;;;;AAAA,AAAMI,AAQHC;AARH,AASE,AAACC,AAAeD;;AAClB,AAKA;;;;;;;;;AAAA,AAAME,AAQHC;AARH,AASE,AAACC,AAAeD;;AAClB,AAGA;;;;;;;;;AAAA,AAAME,AAQHC,AAAMC,AAAIC;AARb,AASE,AAACC,AAAWH,AAAMC,AAAIC;;AACxB,AAGA;;;;;;;;;;AAAA,AAAME,AASHC,AAAEC,AAAEC;AATP,AAUE,AAACC,AAAUH,AAAEC,AAAEC;;AACjB,AAGA,AAAA,AAAME,AAAMJ,AAAEC;AAAd,AACE,AAAAI,AAAOL,AAAEC;;AACX,AAGA,AAAA;;;AAAA,AAAAK,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AAEFR,AAAEC;AAFN,AAES,AAAAI,AAAOL,AAAEC;;;AAFlB,AAAA,AAAA,AAAMO,AAGFR,AAAEC,AAAES;AAHR,AAGW,AAAAC,AAAOX,AAAEC,AAAES;;;AAHtB,AAAA,AAAA,AAAMF;;AAAN,AAKA,AAGA","names":["app.kaboom-next.math/matrix","val","js/goog.math.Matrix","cljs.core/clj->js","app.kaboom-next.math/matrix4","app.kaboom-next.math/matrix3","app.kaboom-next.math/matrix2","app.kaboom-next.math/mat2?","m","cljs.core._EQ_","app.kaboom-next.math/mat3?","app.kaboom-next.math/mat4?","app.kaboom-next.math/deg->rad","deg","goog.math/toRadians","app.kaboom-next.math/rad->deg","rad","goog.math/toDegrees","app.kaboom-next.math/clamp","value","min","max","goog.math/clamp","app.kaboom-next.math/lerp","a","b","x","goog.math/lerp","app.kaboom-next.math/vec2","js/goog.math.Vec2","var_args","G__64010","app.kaboom-next.math/vect","js/Error","c","js/goog.math.Vec3"],"sourcesContent":["(ns app.kaboom-next.math\n  (:require [goog.math :as math]\n            [clojure.repl :refer [doc]]\n            [app.kaboom-next.log :refer [log]])\n  (:import [goog.math Vec2 Vec3 Matrix]))\n\n(comment\n  (Matrix. (clj->js [[1 2 3]\n                     [1 2 3]\n                     [1 3 4]]))\n  (log (Matrix. (clj->js [[1 2]\n                          [1 2]]))))\n\n(defn matrix [val]\n  (Matrix. (clj->js val)))\n\n(def matrix4 (matrix [[1 2 3 4]\n                      [1 2 3 4]\n                      [1 3 4 4]\n                      [1 2 3 4]]))\n(def matrix3 (matrix [[1 2 3]\n                      [1 2 3]\n                      [1 3 4]]))\n(def matrix2 (matrix [[1 2]\n                      [1 2]]))\n\n(defn mat2? [m]\n  (= 2 (.-width (.getSize m))))\n\n(defn mat3? [m]\n  (= 3 (.-width (.getSize m))))\n\n(defn mat4? [m]\n  (= 4 (.-width (.getSize m))))\n\n;\n(comment\n  (mat2? matrix2)\n  (mat2? matrix3)\n  (mat3? matrix3)\n  (mat4? matrix4)\n  (log (.-width (.getSize matrix2)))\n  (log matrix4)\n  (log matrix4)\n  (log  (.getTranspose matrix4))\n  (log (.getInverse matrix4))\n  (log (.multiply matrix4 matrix4))\n  (log (.getInverse (matrix [[1 7]\n                             [6 1]]))))\n\n(defn deg->rad\n  \"Converts radians to degrees.\n    Parameters:\n    - angleRadians  number\n                Angle in radians.\n    Returns: number\n             Angle in degrees.\n    ex: (deg->rad 1) => 0.017453292519943295\"\n  [deg]\n  (math/toRadians deg))\n(comment\n  (doc deg->rad)\n  (deg->rad 1)\n  (math/toRadians 1))\n\n(defn rad->deg\n  \"Converts radians to degrees.\n   Parameters\n   - angleRadians(number): Angle in radians.\n   Returns\n   - number: Angle in degrees.\n   ex: (rad->deg (/ 22 7)) => 180.07244989825872\n   \"\n  [rad]\n  (math/toDegrees rad))\n(comment\n  (math/toDegrees (/ 22 7)))\n\n(defn clamp\n  \"Takes a number and clamps it to within the provided bounds.\n   Parameters\n   - value(number): The input number.\n   - min  (number): The minimum value to return.\n   - max  (number): The maximum value to return.\n   Returns\n   - number: The input number if it is within bounds, or the nearest number within the bounds.\"\n  [value min max]\n  (math/clamp value min max))\n(comment\n  (doc clamp))\n\n(defn lerp\n  \"Performs linear interpolation between values a and b.\n  Returns the value between a and b proportional to x (when x is between 0 and 1.\n  When x is outside this range, the return value is a linear extrapolation).\n  Parameters:\n   - a: number\n   - b: number\n   - x: The proportion between a and b\n  \"\n  [a b x]\n  (math/lerp a b x))\n(comment\n  (lerp 1 2 4))\n\n(defn vec2 [a b]\n  (Vec2. a b))\n(comment\n  (new Vec2 1 2)\n  (vec2 1 2))\n(defn vect\n  \"vec is a reserved function, so had to name as vect\"\n  ([a b] (Vec2. a b))\n  ([a b c] (Vec3. a b c)))\n\n(comment\n  (js/console.log (vect 1 1))\n  (js/console.log (vect 1 1 1)))\n(comment\n  \"Difference between vector and vec\"\n  (vec 1 2) \"Doesnt work.. hint: try (doc vec)\"\n  (doc vec)   \"Agh it accepts a coll.. which stands for collection/sequence... but what kind of collection\n               Lets try with a map since map is collection.\"\n  (vec {:a 1}) \"Cool it works. so it should work  set, list and it works on it self as well \"\n  (do\n    (vec '(2 3 5))\n    (vec #{:a 1})\n    (vec [:a 1]))\n  (vec #js {:a 1})\n  (vector 1 2))\n"]}