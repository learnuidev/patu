shadow$provide.module$node_modules$Phaser$src$physics$matter_js$MatterTileBody=function(global,require,module,exports){var Bodies=require("module$node_modules$Phaser$src$physics$matter_js$lib$factory$Bodies"),Body=require("module$node_modules$Phaser$src$physics$matter_js$lib$body$Body");global=require("module$node_modules$Phaser$src$utils$Class");exports=require("module$node_modules$Phaser$src$physics$matter_js$components$index");var GetFastValue=require("module$node_modules$Phaser$src$utils$object$GetFastValue"),
HasValue=require("module$node_modules$Phaser$src$utils$object$HasValue"),Vertices=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices");require=new global({Mixins:[exports.Bounce,exports.Collision,exports.Friction,exports.Gravity,exports.Mass,exports.Sensor,exports.Sleep,exports.Static],initialize:function(world,tile,options){this.tile=tile;this.world=world;tile.physics.matterBody&&tile.physics.matterBody.destroy();tile.physics.matterBody=this;world=GetFastValue(options,
"body",null);var addToWorld=GetFastValue(options,"addToWorld",!0);world?this.setBody(world,addToWorld):(tile=tile.getCollisionGroup(),0<GetFastValue(tile,"objects",[]).length?this.setFromTileCollision(options):this.setFromTileRectangle(options))},setFromTileRectangle:function(options){void 0===options&&(options={});HasValue(options,"isStatic")||(options.isStatic=!0);HasValue(options,"addToWorld")||(options.addToWorld=!0);var bounds=this.tile.getBounds();bounds=Bodies.rectangle(bounds.x+bounds.width/
2,bounds.y+bounds.height/2,bounds.width,bounds.height,options);this.setBody(bounds,options.addToWorld);return this},setFromTileCollision:function(options){void 0===options&&(options={});HasValue(options,"isStatic")||(options.isStatic=!0);HasValue(options,"addToWorld")||(options.addToWorld=!0);var sx=this.tile.tilemapLayer.scaleX,sy=this.tile.tilemapLayer.scaleY,tileX=this.tile.getLeft(),tileY=this.tile.getTop(),collisionGroup=this.tile.getCollisionGroup();collisionGroup=GetFastValue(collisionGroup,
"objects",[]);for(var parts=[],i=0;i<collisionGroup.length;i++){var object=collisionGroup[i],ox=tileX+object.x*sx,oy=tileY+object.y*sy,ow=object.width*sx,oh=object.height*sy,body=null;if(object.rectangle)body=Bodies.rectangle(ox+ow/2,oy+oh/2,ow,oh,options);else if(object.ellipse)body=Bodies.circle(ox+ow/2,oy+oh/2,ow/2,options);else if(object.polygon||object.polyline)ow=(object.polygon?object.polygon:object.polyline).map(function(p){return{x:p.x*sx,y:p.y*sy}}),object=Vertices.create(ow),Vertices.isConvex(ow)&&
(ow=Vertices.centre(object),ox+=ow.x,oy+=ow.y),body=Bodies.fromVertices(ox,oy,object,options);body&&parts.push(body)}1===parts.length?this.setBody(parts[0],options.addToWorld):1<parts.length&&(options.parts=parts,this.setBody(Body.create(options),options.addToWorld));return this},setBody:function(body,addToWorld){void 0===addToWorld&&(addToWorld=!0);this.body&&this.removeBody();this.body=body;this.body.gameObject=this;addToWorld&&this.world.add(this.body);return this},removeBody:function(){this.body&&
(this.world.remove(this.body),this.body=this.body.gameObject=void 0);return this},destroy:function(){this.removeBody();this.tile.physics.matterBody=void 0}});module.exports=require}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$MatterTileBody.js.map
