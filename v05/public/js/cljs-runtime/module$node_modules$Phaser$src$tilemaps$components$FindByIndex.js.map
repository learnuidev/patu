{
"version":3,
"file":"module$node_modules$Phaser$src$tilemaps$components$FindByIndex.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,+DAAA,CAAmF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAkF3HD,MAAAC,QAAA,CAxDkBC,QAAS,CAACC,SAAD,CAAYC,IAAZ,CAAkBC,OAAlB,CAA2BC,KAA3B,CAC3B,CACiBC,IAAAA,EAAb,GAAIH,IAAJ,GAA0BA,IAA1B,CAAiC,CAAjC,CACgBG,KAAAA,EAAhB,GAAIF,OAAJ,GAA6BA,OAA7B,CAAuC,CAAA,CAAvC,CAEA,KAAIG,MAAQ,CAAZ,CAEIC,EAFJ,CAGIC,IAEJ,IAAIL,OAAJ,CAEI,IAAKI,EAAL,CAAUH,KAAAK,OAAV,CAAyB,CAAzB,CAAkC,CAAlC,EAA4BF,EAA5B,CAAqCA,EAAA,EAArC,CAEI,IAAKG,OAAL,CAAUN,KAAAO,MAAV,CAAwB,CAAxB,CAAiC,CAAjC,EAA2BD,OAA3B,CAAoCA,OAAA,EAApC,CAGI,KADAF,IACA,CADOJ,KAAAQ,KAAA,CAAWL,EAAX,CAAA,CAAeG,OAAf,CACP,GAAYF,IAAAK,MAAZ,GAA2BZ,SAA3B,CACA,CACI,GAAIK,KAAJ,GAAcJ,IAAd,CAEI,MAAOM,KAIPF,MAAA,EAAS,CAPjB,CADA,CAPZ,IAuBI,KAAKC,EAAL,CAAU,CAAV,CAAaA,EAAb,CAAkBH,KAAAK,OAAlB,CAAgCF,EAAA,EAAhC,CAEI,IAAKG,OAAL,CAAU,CAAV,CAAaA,OAAb,CAAkBN,KAAAO,MAAlB,CAA+BD,OAAA,EAA/B,CAGI,IADAF,IACA;AADOJ,KAAAQ,KAAA,CAAWL,EAAX,CAAA,CAAeG,OAAf,CACP,GAAYF,IAAAK,MAAZ,GAA2BZ,SAA3B,CACA,CACI,GAAIK,KAAJ,GAAcJ,IAAd,CAEI,MAAOM,KAIPF,MAAA,EAAS,CAPjB,CAcZ,MAAO,KApDX,CA3B2H;",
"sources":["node_modules/Phaser/src/tilemaps/components/FindByIndex.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$tilemaps$components$FindByIndex\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n * the top-left.\r\n *\r\n * @function Phaser.Tilemaps.Components.FindByIndex\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {integer} index - The tile index value to search for.\r\n * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.\r\n * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the\r\n * bottom-right. Otherwise it scans from the top-left.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?Phaser.Tilemaps.Tile} The first (or n skipped) tile with the matching index.\r\n */\r\nvar FindByIndex = function (findIndex, skip, reverse, layer)\r\n{\r\n    if (skip === undefined) { skip = 0; }\r\n    if (reverse === undefined) { reverse = false; }\r\n\r\n    var count = 0;\r\n    var tx;\r\n    var ty;\r\n    var tile;\r\n\r\n    if (reverse)\r\n    {\r\n        for (ty = layer.height - 1; ty >= 0; ty--)\r\n        {\r\n            for (tx = layer.width - 1; tx >= 0; tx--)\r\n            {\r\n                tile = layer.data[ty][tx];\r\n                if (tile && tile.index === findIndex)\r\n                {\r\n                    if (count === skip)\r\n                    {\r\n                        return tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        count += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (tx = 0; tx < layer.width; tx++)\r\n            {\r\n                tile = layer.data[ty][tx];\r\n                if (tile && tile.index === findIndex)\r\n                {\r\n                    if (count === skip)\r\n                    {\r\n                        return tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        count += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nmodule.exports = FindByIndex;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","FindByIndex","findIndex","skip","reverse","layer","undefined","count","ty","tile","height","tx","width","data","index"]
}
