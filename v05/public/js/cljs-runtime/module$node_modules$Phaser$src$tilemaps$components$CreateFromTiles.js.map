{
"version":3,
"file":"module$node_modules$Phaser$src$tilemaps$components$CreateFromTiles.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,mEAAA,CAAuF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAO/H,IAAIC,aAAeH,OAAA,CAAQ,iEAAR,CAAnB,CACII,aAAeJ,OAAA,CAAQ,iEAAR,CADnB,CAEIK,eAAiBL,OAAA,CAAQ,mEAAR,CAFrB,CAGIM,eAAiBN,OAAA,CAAQ,mEAAR,CAqErBC,OAAAC,QAAA;AAhDsBK,QAAS,CAACC,OAAD,CAAUC,YAAV,CAAwBC,YAAxB,CAAsCC,KAAtC,CAA6CC,MAA7C,CAAqDC,KAArD,CAC/B,CACyBC,IAAAA,EAArB,GAAIJ,YAAJ,GAAkCA,YAAlC,CAAiD,EAAjD,CAEKK,MAAAC,QAAA,CAAcR,OAAd,CAAL,GAA+BA,OAA/B,CAAyC,CAAEA,OAAF,CAAzC,CAEA,KAAIS,aAAeJ,KAAAI,aACLH,KAAAA,EAAd,GAAIH,KAAJ,GAA2BA,KAA3B,CAAmCM,YAAAN,MAAnC,CACeG,KAAAA,EAAf,GAAIF,MAAJ,GAA4BA,MAA5B,CAAqCD,KAAAO,QAAAC,KAArC,CAEIC,aAAAA,CAAQf,cAAA,CAAe,CAAf,CAAkB,CAAlB,CAAqBQ,KAAAQ,MAArB,CAAkCR,KAAAS,OAAlC,CAAgD,IAAhD,CAAsDT,KAAtD,CACZ,KAAIU,QAAU,EAAd,CACIC,CAEJ,KAAKA,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBJ,YAAAK,OAAhB,CAA8BD,CAAA,EAA9B,CACA,CACI,IAAIE,KAAON,YAAA,CAAMI,CAAN,CAEyB,GAApC,GAAIhB,OAAAmB,QAAA,CAAgBD,IAAAE,MAAhB,CAAJ,GAEIlB,YAAAmB,EAIA,CAJiB1B,YAAA,CAAauB,IAAAG,EAAb,CAAqBjB,MAArB,CAA6BC,KAA7B,CAIjB;AAHAH,YAAAoB,EAGA,CAHiB1B,YAAA,CAAasB,IAAAI,EAAb,CAAqBlB,MAArB,CAA6BC,KAA7B,CAGjB,CADIkB,IACJ,CADapB,KAAAqB,KAAAD,OAAA,CAAkBrB,YAAlB,CACb,CAAAa,OAAAU,KAAA,CAAaF,IAAb,CANJ,CAHJ,CAaA,GAA4B,QAA5B,GAAI,MAAOtB,aAAX,CAGI,IAAKe,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBhB,OAAAiB,OAAhB,CAAgCD,CAAA,EAAhC,CAEIlB,cAAA,CAAeE,OAAA,CAAQgB,CAAR,CAAf,CAA2Bf,YAA3B,CAAyC,CAAzC,CAA4C,CAA5C,CAA+CI,KAAAQ,MAA/C,CAA4DR,KAAAS,OAA5D,CAA0ET,KAA1E,CALR,KAQK,IAAIE,KAAAC,QAAA,CAAcP,YAAd,CAAJ,CAGD,IAAKe,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBhB,OAAAiB,OAAhB,CAAgCD,CAAA,EAAhC,CAEIlB,cAAA,CAAeE,OAAA,CAAQgB,CAAR,CAAf,CAA2Bf,YAAA,CAAae,CAAb,CAA3B,CAA4C,CAA5C,CAA+C,CAA/C,CAAkDX,KAAAQ,MAAlD,CAA+DR,KAAAS,OAA/D,CAA6ET,KAA7E,CAIR,OAAOU,QA5CX,CAhC+H;",
"sources":["node_modules/Phaser/src/tilemaps/components/CreateFromTiles.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$tilemaps$components$CreateFromTiles\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar TileToWorldX = require('./TileToWorldX');\r\nvar TileToWorldY = require('./TileToWorldY');\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar ReplaceByIndex = require('./ReplaceByIndex');\r\n\r\n/**\r\n * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n *\r\n * @function Phaser.Tilemaps.Components.CreateFromTiles\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a one-to-one mapping with the indexes array.\r\n * @param {SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when determining the world XY\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n */\r\nvar CreateFromTiles = function (indexes, replacements, spriteConfig, scene, camera, layer)\r\n{\r\n    if (spriteConfig === undefined) { spriteConfig = {}; }\r\n\r\n    if (!Array.isArray(indexes)) { indexes = [ indexes ]; }\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    if (scene === undefined) { scene = tilemapLayer.scene; }\r\n    if (camera === undefined) { camera = scene.cameras.main; }\r\n\r\n    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);\r\n    var sprites = [];\r\n    var i;\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        if (indexes.indexOf(tile.index) !== -1)\r\n        {\r\n            spriteConfig.x = TileToWorldX(tile.x, camera, layer);\r\n            spriteConfig.y = TileToWorldY(tile.y, camera, layer);\r\n\r\n            var sprite = scene.make.sprite(spriteConfig);\r\n            sprites.push(sprite);\r\n        }\r\n    }\r\n\r\n    if (typeof replacements === 'number')\r\n    {\r\n        //  Assume 1 replacement for all types of tile given\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n    else if (Array.isArray(replacements))\r\n    {\r\n        //  Assume 1 to 1 mapping with indexes array\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n\r\n    return sprites;\r\n};\r\n\r\nmodule.exports = CreateFromTiles;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","TileToWorldX","TileToWorldY","GetTilesWithin","ReplaceByIndex","CreateFromTiles","indexes","replacements","spriteConfig","scene","camera","layer","undefined","Array","isArray","tilemapLayer","cameras","main","tiles","width","height","sprites","i","length","tile","indexOf","index","x","y","sprite","make","push"]
}
