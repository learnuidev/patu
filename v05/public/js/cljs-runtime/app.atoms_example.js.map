{"version":3,"sources":["app/atoms_example.cljs"],"mappings":";;AAeA,AAACA,AAAK,AAAA,AAACC;AAKN,AAAA,AAAA,AAAA,AAAA,AAACA;AAGF,AAACC,AAAM,AAAA,AAAA,AAAA,AAACD;AAYR,AAAKE,AAAQ,AAAA,AAACF;AACd,AAACC,AAAMC;AAEP,AAACC,AAAMD,AAAQE;AACf,AAACH,AAAMC;AASP,AAAA,AAACG,AAAOH;AAER,AAACD,AAAMC","names":["cljs.core/type","cljs.core.atom","cljs.core/deref","app.atoms-example/counter","cljs.core.swap_BANG_","cljs.core/inc","cljs.core/reset!"],"sourcesContent":["(ns app.atoms-example)\n\n;; Objectives\n;; 1 What is an atom\n;; 2 Atom creation\n;; 3 Read values out of an atom\n;; 4 Updating atoms\n\n;; 1. What is an atom\n;; - Atoms hold values (immutable), its a container for mutable values\n;; - Similar to reference types in other programming languages\n;; - Atoms enables you to model things that change over time\n\n;; 2. Creating an atom\n;; - Create an atom by calling atom function and passing initial value\n(type (atom 0))\n\n;; 3. Getting value out of the atom: Two ways\n\n;; 3.1 Prefixing @ to atom\n@(atom #{:apples :oranges :bananas})\n\n;; 3.2 Using deref function\n(deref (atom {:person/name \"John Doe\"}))\n\n;; 4 Updating atoms: two ways swap! and reset!\n;; 4.1 swap!: swap! function takes two arguments:\n;;  - the atom and\n;;  - the function to produce the next value of the atom\n;;  - swap! calls the function with the old value of the atom\n;;    and uses the value returned from the function as the new value\n;;    of the atom\n;;  - In our example each call to swap! will increment the value\n;;    in the atom, giving us our counter\n;;  - swap! lets you march from one value of your atom to the other\n(def counter (atom 0))\n(deref counter)\n\n(swap! counter inc)\n(deref counter)\n\n;; 4.2 reset! - reser! function takes two arguments:\n;;   - the atom and\n;;   - a value\n;;   - reset! function will take the value and use it as the new value\n;;     of the atom\n;;   - This function can be useful for resetting things\n\n(reset! counter 0)\n;; Now the counter value is reset to 0\n(deref counter)\n\n\n;; Armed with this knowledge, lets implement our counter example\n;; ...\n;; ...\n;; ...\n;; Except it doesnt work. The value in our atom gets updated\n;; But our component does not get re-render\n;; Reagent provides its own version of atom calling reagent atom or ratom\n\n;; native clojure.core/atoms does not keep track of derefs\n\n;; What is Reagent Atoms?\n;;- Reagent Atoms is like clojure.core/atom, \n;;  except that it keeps track of derefs.\n;;  Reagent components that derefs one of these are automatically\n;;  re-rendered when their value gets updated\n;;  With ratoms we can write truly reactive applications"]}