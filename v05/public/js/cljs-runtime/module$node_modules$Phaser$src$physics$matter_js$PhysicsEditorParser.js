shadow$provide.module$node_modules$Phaser$src$physics$matter_js$PhysicsEditorParser=function(global,require,module,exports){var Bodies=require("module$node_modules$Phaser$src$physics$matter_js$lib$factory$Bodies"),Body=require("module$node_modules$Phaser$src$physics$matter_js$lib$body$Body"),Bounds=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Bounds"),Common=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Common"),GetFastValue=require("module$node_modules$Phaser$src$utils$object$GetFastValue"),
Vector=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vector"),Vertices=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices");module.exports={parseBody:function(x,y,w,h,config){for(var fixtureConfigs=GetFastValue(config,"fixtures",[]),fixtures=[],fc=0;fc<fixtureConfigs.length;fc++)for(var fixtureParts=this.parseFixture(fixtureConfigs[fc]),i=0;i<fixtureParts.length;i++)fixtures.push(fixtureParts[i]);config=Common.extend({},!1,config);delete config.fixtures;
delete config.type;config=Body.create(config);Body.setParts(config,fixtures);config.render.sprite.xOffset=config.position.x/w;config.render.sprite.yOffset=config.position.y/h;Body.setPosition(config,{x:x,y:y});return config},parseFixture:function(fixtureConfig){var matterConfig=Common.extend({},!1,fixtureConfig);delete matterConfig.circle;delete matterConfig.vertices;if(fixtureConfig.circle){var fixtures=GetFastValue(fixtureConfig.circle,"x");var y=GetFastValue(fixtureConfig.circle,"y");fixtureConfig=
GetFastValue(fixtureConfig.circle,"radius");fixtures=[Bodies.circle(fixtures,y,fixtureConfig,matterConfig)]}else fixtureConfig.vertices&&(fixtures=this.parseVertices(fixtureConfig.vertices,matterConfig));return fixtures},parseVertices:function(vertexSets,options){var k,z,parts=[];options=options||{};for(k=0;k<vertexSets.length;k+=1)parts.push(Body.create(Common.extend({position:Vertices.centre(vertexSets[k]),vertices:vertexSets[k]},options)));for(vertexSets=0;vertexSets<parts.length;vertexSets++){var partA=
parts[vertexSets];for(options=vertexSets+1;options<parts.length;options++){var partB=parts[options];if(Bounds.overlaps(partA.bounds,partB.bounds)){var pav=partA.vertices,pbv=partB.vertices;for(k=0;k<partA.vertices.length;k++)for(z=0;z<partB.vertices.length;z++){var da=Vector.magnitudeSquared(Vector.sub(pav[(k+1)%pav.length],pbv[z])),db=Vector.magnitudeSquared(Vector.sub(pav[k],pbv[(z+1)%pbv.length]));5>da&&5>db&&(pav[k].isInternal=!0,pbv[z].isInternal=!0)}}}}return parts}}}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$PhysicsEditorParser.js.map
