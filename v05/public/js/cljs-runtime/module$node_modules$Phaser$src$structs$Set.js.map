{
"version":3,
"file":"module$node_modules$Phaser$src$structs$Set.js",
"lineCount":5,
"mappings":"AAAAA,cAAA,2CAAA,CAA+D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAiCvG,IAAIC,IAAM,KA1BEH,OAAAI,CAAQ,4CAARA,CA0BF,EAAU,CAEhBC,WAEAF,QAAa,CAACG,QAAD,CACb,CAWI,IAAAC,QAAA,CAAe,EAEf,IAAIC,KAAAC,QAAA,CAAcH,QAAd,CAAJ,CAEI,IAAK,IAAII,EAAI,CAAb,CAAgBA,CAAhB,CAAoBJ,QAAAK,OAApB,CAAqCD,CAAA,EAArC,CAEI,IAAAE,IAAA,CAASN,QAAA,CAASI,CAAT,CAAT,CAjBZ,CALgB,CAwChBE,IAAKA,QAAS,CAACC,KAAD,CACd,CACwC,EAApC,GAAI,IAAAN,QAAAO,QAAA,CAAqBD,KAArB,CAAJ,EAEI,IAAAN,QAAAQ,KAAA,CAAkBF,KAAlB,CAGJ,OAAO,KANX,CAzCgB,CAgEhBG,IAAKA,QAAS,CAACC,QAAD,CAAWJ,KAAX,CACd,CACI,IAAK,IAAIH,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAAH,QAAAI,OAApB,CAAyCD,CAAA,EAAzC,CACA,CACI,IAAIQ,MAAQ,IAAAX,QAAA,CAAaG,CAAb,CAEZ,IAAIQ,KAAA,CAAMD,QAAN,CAAJ;AAAwBJ,KAAxB,CAEI,MAAOK,MALf,CAFJ,CAjEgB,CAuFhBC,SAAUA,QAAS,EACnB,CACI,MAAO,KAAAZ,QAAAa,MAAA,CAAmB,CAAnB,CADX,CAxFgB,CAyGhBC,OAAQA,QAAS,CAACR,KAAD,CACjB,CACQS,KAAAA,CAAQ,IAAAf,QAAAO,QAAA,CAAqBD,KAArB,CAEA,GAAZ,CAAIS,KAAJ,EAEI,IAAAf,QAAAgB,OAAA,CAAoBD,KAApB,CAA2B,CAA3B,CAGJ,OAAO,KARX,CA1GgB,CA2HhBE,KAAMA,QAAS,EACf,CAEIC,OAAAC,MAAA,CAAc,KAAd,CAEA,KAAK,IAAIhB,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAAH,QAAAI,OAApB,CAAyCD,CAAA,EAAzC,CAGIe,OAAAE,IAAA,CADY,IAAApB,QAAAW,CAAaR,CAAbQ,CACZ,CAIJO,QAAAG,SAAA,EAXJ,CA5HgB,CAyJhBC,KAAMA,QAAS,CAACC,QAAD,CAAWC,aAAX,CACf,CACI,IAAIrB,CAAJ,CACIsB,KAAO,IAAAzB,QAAAa,MAAA,EADX,CAEIa,IAAMD,IAAArB,OAEV,IAAIoB,aAAJ,CAEI,IAAKrB,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBuB,GAAhB,EAEqD,CAAA,CAFrD,GAEQH,QAAAI,KAAA,CAAcH,aAAd,CAA6BC,IAAA,CAAKtB,CAAL,CAA7B,CAAsCA,CAAtC,CAFR,CAAqBA,CAAA,EAArB,EAFJ,IAYI,KAAKA,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBuB,GAAhB,EAEiC,CAAA,CAFjC,GAEQH,QAAA,CAASE,IAAA,CAAKtB,CAAL,CAAT;AAAkBA,CAAlB,CAFR,CAAqBA,CAAA,EAArB,EASJ,MAAO,KA1BX,CA1JgB,CAsMhByB,QAASA,QAAS,CAACL,QAAD,CAAWC,aAAX,CAClB,CACI,IAAIrB,CAAJ,CACIuB,IAAM,IAAA1B,QAAAI,OAEV,IAAIoB,aAAJ,CAEI,IAAKrB,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBuB,GAAhB,EAE6D,CAAA,CAF7D,GAEQH,QAAAI,KAAA,CAAcH,aAAd,CAA6B,IAAAxB,QAAA,CAAaG,CAAb,CAA7B,CAA8CA,CAA9C,CAFR,CAAqBA,CAAA,EAArB,EAFJ,IAYI,KAAKA,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBuB,GAAhB,EAEyC,CAAA,CAFzC,GAEQH,QAAA,CAAS,IAAAvB,QAAA,CAAaG,CAAb,CAAT,CAA0BA,CAA1B,CAFR,CAAqBA,CAAA,EAArB,EASJ,MAAO,KAzBX,CAvMgB,CAgPhB0B,aAAcA,QAAS,CAACC,WAAD,CACvB,CACI,IAAI3B,CAAJ,CACI4B,KAAO,EAEX,KAAK5B,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgB6B,SAAA5B,OAAhB,CAAkCD,CAAA,EAAlC,CAEI4B,IAAAvB,KAAA,CAAUwB,SAAA,CAAU7B,CAAV,CAAV,CAGJ,KAAIuB,IAAM,IAAA1B,QAAAI,OAEV,KAAKD,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBuB,GAAhB,CAAqBvB,CAAA,EAArB,CACA,CACI,IAAIQ,MAAQ,IAAAX,QAAA,CAAaG,CAAb,CAEZQ,MAAA,CAAMmB,WAAN,CAAAG,MAAA,CAAyBtB,KAAzB,CAAgCoB,IAAhC,CAHJ,CAMA,MAAO,KAlBX,CAjPgB,CAgRhBG,MAAOA,QAAS,EAChB,CACI,IAAAlC,QAAAI,OAAA;AAAsB,CAEtB,OAAO,KAHX,CAjRgB,CAmShB+B,SAAUA,QAAS,CAAC7B,KAAD,CACnB,CACI,MAAsC,EAAtC,CAAQ,IAAAN,QAAAO,QAAA,CAAqBD,KAArB,CADZ,CApSgB,CAoThB8B,MAAOA,QAAS,CAAC/B,GAAD,CAChB,CACI,IAAIgC,OAAS,IAAIzC,GAEjBS,IAAAL,QAAAsC,QAAA,CAAoB,QAAS,CAAChC,KAAD,CAC7B,CACI+B,MAAAhC,IAAA,CAAWC,KAAX,CADJ,CADA,CAKA,KAAAN,QAAAsC,QAAA,CAAqB,QAAS,CAAChC,KAAD,CAC9B,CACI+B,MAAAhC,IAAA,CAAWC,KAAX,CADJ,CADA,CAKA,OAAO+B,OAbX,CArTgB,CAiVhBE,UAAWA,QAAS,CAAClC,GAAD,CACpB,CACI,IAAIgC,OAAS,IAAIzC,GAEjB,KAAAI,QAAAsC,QAAA,CAAqB,QAAS,CAAChC,KAAD,CAC9B,CACQD,GAAA8B,SAAA,CAAa7B,KAAb,CAAJ,EAEI+B,MAAAhC,IAAA,CAAWC,KAAX,CAHR,CADA,CAQA,OAAO+B,OAXX,CAlVgB,CA4WhBG,WAAYA,QAAS,CAACnC,GAAD,CACrB,CACI,IAAIgC,OAAS,IAAIzC,GAEjB,KAAAI,QAAAsC,QAAA,CAAqB,QAAS,CAAChC,KAAD,CAC9B,CACSD,GAAA8B,SAAA,CAAa7B,KAAb,CAAL,EAEI+B,MAAAhC,IAAA,CAAWC,KAAX,CAHR,CADA,CAQA;MAAO+B,OAXX,CA7WgB,CAoYhBI,KAAM,CAEFhC,IAAKA,QAAS,EACd,CACI,MAAO,KAAAT,QAAAI,OADX,CAHE,CAOFC,IAAKA,QAAS,CAACC,KAAD,CACd,CACI,MAAIA,MAAJ,CAAY,IAAAN,QAAAI,OAAZ,CAEW,IAAAJ,QAAAI,OAFX,CAEiCE,KAFjC,CAMW,IAAAN,QAAAI,OAPf,CARE,CApYU,CAAV,CA2ZVV,OAAAC,QAAA,CAAiBC,GA5bsF;",
"sources":["node_modules/Phaser/src/structs/Set.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$structs$Set\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @callback EachSetCallback\r\n * @generic E - [entry]\r\n *\r\n * @param {*} entry - [description]\r\n * @param {number} index - [description]\r\n *\r\n * @return {?boolean} [description]\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Set is a collection of unique elements.\r\n *\r\n * @class Set\r\n * @memberOf Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n * @genericUse {T[]} - [elements]\r\n *\r\n * @param {Array.<*>} [elements] - An optional array of elements to insert into this Set.\r\n */\r\nvar Set = new Class({\r\n\r\n    initialize:\r\n\r\n    function Set (elements)\r\n    {\r\n        /**\r\n         * The entries of this Set. Stored internally as an array.\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.Set#entries\r\n         * @type {Array.<*>}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.entries = [];\r\n\r\n        if (Array.isArray(elements))\r\n        {\r\n            for (var i = 0; i < elements.length; i++)\r\n            {\r\n                this.set(elements[i]);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Inserts the provided value into this Set. If the value is already contained in this Set this method will have no effect.\r\n     *\r\n     * @method Phaser.Structs.Set#set\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - The value to insert into this Set.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    set: function (value)\r\n    {\r\n        if (this.entries.indexOf(value) === -1)\r\n        {\r\n            this.entries.push(value);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get an element of this Set which has a property of the specified name, if that property is equal to the specified value.\r\n     * If no elements of this Set satisfy the condition then this method will return `null`.\r\n     *\r\n     * @method Phaser.Structs.Set#get\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value,$return]\r\n     *\r\n     * @param {string} property - The property name to check on the elements of this Set.\r\n     * @param {*} value - The value to check for.\r\n     *\r\n     * @return {*} The first element of this Set that meets the required condition, or `null` if this Set contains no elements that meet the condition.\r\n     */\r\n    get: function (property, value)\r\n    {\r\n        for (var i = 0; i < this.entries.length; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n\r\n            if (entry[property] === value)\r\n            {\r\n                return entry;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing all the values in this Set.\r\n     *\r\n     * @method Phaser.Structs.Set#getArray\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An array containing all the values in this Set.\r\n     */\r\n    getArray: function ()\r\n    {\r\n        return this.entries.slice(0);\r\n    },\r\n\r\n    /**\r\n     * Removes the given value from this Set if this Set contains that value.\r\n     *\r\n     * @method Phaser.Structs.Set#delete\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - The value to remove from the Set.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    delete: function (value)\r\n    {\r\n        var index = this.entries.indexOf(value);\r\n\r\n        if (index > -1)\r\n        {\r\n            this.entries.splice(index, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Dumps the contents of this Set to the console via `console.group`.\r\n     *\r\n     * @method Phaser.Structs.Set#dump\r\n     * @since 3.0.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        // eslint-disable-next-line no-console\r\n        console.group('Set');\r\n\r\n        for (var i = 0; i < this.entries.length; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n            console.log(entry);\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.groupEnd();\r\n    },\r\n\r\n    /**\r\n     * Passes each value in this Set to the given callback.\r\n     * Use this function when you know this Set will be modified during the iteration, otherwise use `iterate`.\r\n     *\r\n     * @method Phaser.Structs.Set#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.\r\n     * @param {*} callbackScope - The scope of the callback.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    each: function (callback, callbackScope)\r\n    {\r\n        var i;\r\n        var temp = this.entries.slice();\r\n        var len = temp.length;\r\n\r\n        if (callbackScope)\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback.call(callbackScope, temp[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback(temp[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes each value in this Set to the given callback.\r\n     * For when you absolutely know this Set won't be modified during the iteration.\r\n     *\r\n     * @method Phaser.Structs.Set#iterate\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.\r\n     * @param {*} callbackScope - The scope of the callback.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    iterate: function (callback, callbackScope)\r\n    {\r\n        var i;\r\n        var len = this.entries.length;\r\n\r\n        if (callbackScope)\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback.call(callbackScope, this.entries[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback(this.entries[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Goes through each entry in this Set and invokes the given function on them, passing in the arguments.\r\n     *\r\n     * @method Phaser.Structs.Set#iterateLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {string} callbackKey - The key of the function to be invoked on each Set entry.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    iterateLocal: function (callbackKey)\r\n    {\r\n        var i;\r\n        var args = [];\r\n\r\n        for (i = 1; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        var len = this.entries.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n\r\n            entry[callbackKey].apply(entry, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears this Set so that it no longer contains any values.\r\n     *\r\n     * @method Phaser.Structs.Set#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.entries.length = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if this Set contains the given value, otherwise returns `false`.\r\n     *\r\n     * @method Phaser.Structs.Set#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     *\r\n     * @param {*} value - The value to check for in this Set.\r\n     *\r\n     * @return {boolean} `true` if the given value was found in this Set, otherwise `false`.\r\n     */\r\n    contains: function (value)\r\n    {\r\n        return (this.entries.indexOf(value) > -1);\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set containing all values that are either in this Set or in the Set provided as an argument.\r\n     *\r\n     * @method Phaser.Structs.Set#union\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to perform the union with.\r\n     *\r\n     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set and the Set provided as an argument.\r\n     */\r\n    union: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        set.entries.forEach(function (value)\r\n        {\r\n            newSet.set(value);\r\n        });\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            newSet.set(value);\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set that contains only the values which are in this Set and that are also in the given Set.\r\n     *\r\n     * @method Phaser.Structs.Set#intersect\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to intersect this set with.\r\n     *\r\n     * @return {Phaser.Structs.Set} The result of the intersection, as a new Set.\r\n     */\r\n    intersect: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            if (set.contains(value))\r\n            {\r\n                newSet.set(value);\r\n            }\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set containing all the values in this Set which are *not* also in the given Set.\r\n     *\r\n     * @method Phaser.Structs.Set#difference\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to perform the difference with.\r\n     *\r\n     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set that are not also in the Set provided as an argument to this method.\r\n     */\r\n    difference: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            if (!set.contains(value))\r\n            {\r\n                newSet.set(value);\r\n            }\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * The size of this Set. This is the number of entries within it.\r\n     * Changing the size will truncate the Set if the given value is smaller than the current size.\r\n     * Increasing the size larger than the current size has no effect.\r\n     *\r\n     * @name Phaser.Structs.Set#size\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    size: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.entries.length;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (value < this.entries.length)\r\n            {\r\n                return this.entries.length = value;\r\n            }\r\n            else\r\n            {\r\n                return this.entries.length;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Set;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Set","Class","initialize","elements","entries","Array","isArray","i","length","set","value","indexOf","push","get","property","entry","getArray","slice","delete","index","splice","dump","console","group","log","groupEnd","each","callback","callbackScope","temp","len","call","iterate","iterateLocal","callbackKey","args","arguments","apply","clear","contains","union","newSet","forEach","intersect","difference","size"]
}
