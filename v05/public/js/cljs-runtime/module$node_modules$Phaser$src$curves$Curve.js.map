{
"version":3,
"file":"module$node_modules$Phaser$src$curves$Curve.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/Phaser/src/curves/Curve.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$curves$Curve\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar FromPoints = require('../geom/rectangle/FromPoints');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Base Curve class, which all other curve types extend.\r\n *\r\n * Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n *\r\n * @class Curve\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} type - [description]\r\n */\r\nvar Curve = new Class({\r\n\r\n    initialize:\r\n\r\n    function Curve (type)\r\n    {\r\n        /**\r\n         * String based identifier for the type of curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * The default number of divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#defaultDivisions\r\n         * @type {integer}\r\n         * @default 5\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultDivisions = 5;\r\n\r\n        /**\r\n         * The quantity of arc length divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#arcLengthDivisions\r\n         * @type {integer}\r\n         * @default 100\r\n         * @since 3.0.0\r\n         */\r\n        this.arcLengthDivisions = 100;\r\n\r\n        /**\r\n         * An array of cached arc length values.\r\n         *\r\n         * @name Phaser.Curves.Curve#cacheArcLengths\r\n         * @type {number[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.cacheArcLengths = [];\r\n\r\n        /**\r\n         * Does the data of this curve need updating?\r\n         *\r\n         * @name Phaser.Curves.Curve#needsUpdate\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.needsUpdate = true;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Curve#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2A\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2A = new Vector2();\r\n\r\n        /**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2B\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2B = new Vector2();\r\n    },\r\n\r\n    /**\r\n     * Draws this curve on the given Graphics object.\r\n     *\r\n     * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.\r\n     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n     *\r\n     * @method Phaser.Curves.Curve#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n     * @param {integer} [pointsTotal=32] - The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n     */\r\n    draw: function (graphics, pointsTotal)\r\n    {\r\n        if (pointsTotal === undefined) { pointsTotal = 32; }\r\n\r\n        //  So you can chain graphics calls\r\n        return graphics.strokePoints(this.getPoints(pointsTotal));\r\n    },\r\n    \r\n    /**\r\n     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n     *\r\n     * You can control the accuracy of the bounds. The value given is used to work out how many points\r\n     * to plot across the curve. Higher values are more accurate at the cost of calculation speed.\r\n     *\r\n     * @method Phaser.Curves.Curve#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in. If falsey a new object will be created.\r\n     * @param {integer} [accuracy=16] - The accuracy of the bounds calculations.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n     */\r\n    getBounds: function (out, accuracy)\r\n    {\r\n        if (!out) { out = new Rectangle(); }\r\n        if (accuracy === undefined) { accuracy = 16; }\r\n\r\n        var len = this.getLength();\r\n\r\n        if (accuracy > len)\r\n        {\r\n            accuracy = len / 2;\r\n        }\r\n\r\n        //  The length of the curve in pixels\r\n        //  So we'll have 1 spaced point per 'accuracy' pixels\r\n\r\n        var spaced = Math.max(1, Math.round(len / accuracy));\r\n\r\n        return FromPoints(this.getSpacedPoints(spaced), out);\r\n    },\r\n\r\n    /**\r\n     * Returns an array of points, spaced out X distance pixels apart.\r\n     * The smaller the distance, the larger the array will be.\r\n     *\r\n     * @method Phaser.Curves.Curve#getDistancePoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} distance - The distance, in pixels, between each point along the curve.\r\n     *\r\n     * @return {Phaser.Geom.Point[]} An Array of Point objects.\r\n     */\r\n    getDistancePoints: function (distance)\r\n    {\r\n        var len = this.getLength();\r\n\r\n        var spaced = Math.max(1, len / distance);\r\n\r\n        return this.getSpacedPoints(spaced);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getEndPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - Optional Vector object to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} Vector2 containing the coordinates of the curves end point.\r\n     */\r\n    getEndPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPointAt(1, out);\r\n    },\r\n\r\n    // Get total curve arc length\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getLength: function ()\r\n    {\r\n        var lengths = this.getLengths();\r\n\r\n        return lengths[lengths.length - 1];\r\n    },\r\n\r\n    // Get list of cumulative segment lengths\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number[]} [description]\r\n     */\r\n    getLengths: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = this.arcLengthDivisions; }\r\n\r\n        if ((this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate)\r\n        {\r\n            return this.cacheArcLengths;\r\n        }\r\n\r\n        this.needsUpdate = false;\r\n\r\n        var cache = [];\r\n        var current;\r\n        var last = this.getPoint(0, this._tmpVec2A);\r\n        var sum = 0;\r\n\r\n        cache.push(0);\r\n\r\n        for (var p = 1; p <= divisions; p++)\r\n        {\r\n            current = this.getPoint(p / divisions, this._tmpVec2B);\r\n\r\n            sum += current.distance(last);\r\n\r\n            cache.push(sum);\r\n\r\n            last.copy(current);\r\n        }\r\n\r\n        this.cacheArcLengths = cache;\r\n\r\n        return cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n    },\r\n\r\n    // Get point at relative position in curve according to arc length\r\n\r\n    // - u [0 .. 1]\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getPointAt: function (u, out)\r\n    {\r\n        var t = this.getUtoTmapping(u);\r\n\r\n        return this.getPoint(t, out);\r\n    },\r\n\r\n    // Get sequence of points using getPoint( t )\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} [description]\r\n     */\r\n    getPoints: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = this.defaultDivisions; }\r\n\r\n        var points = [];\r\n\r\n        for (var d = 0; d <= divisions; d++)\r\n        {\r\n            points.push(this.getPoint(d / divisions));\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getRandomPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPoint(Math.random(), out);\r\n    },\r\n\r\n    // Get sequence of points using getPointAt( u )\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getSpacedPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} [description]\r\n     */\r\n    getSpacedPoints: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = this.defaultDivisions; }\r\n\r\n        var points = [];\r\n\r\n        for (var d = 0; d <= divisions; d++)\r\n        {\r\n            var t = this.getUtoTmapping(d / divisions, null, divisions);\r\n\r\n            points.push(this.getPoint(t));\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPointAt(0, out);\r\n    },\r\n\r\n    // Returns a unit vector tangent at t\r\n    // In case any sub curve does not implement its tangent derivation,\r\n    // 2 points a small delta apart will be used to find its gradient\r\n    // which seems to give a reasonable approximation\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangent\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} Vector approximating the tangent line at the point t (delta +/- 0.0001)\r\n     */\r\n    getTangent: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var delta = 0.0001;\r\n        var t1 = t - delta;\r\n        var t2 = t + delta;\r\n\r\n        // Capping in case of danger\r\n\r\n        if (t1 < 0)\r\n        {\r\n            t1 = 0;\r\n        }\r\n\r\n        if (t2 > 1)\r\n        {\r\n            t2 = 1;\r\n        }\r\n\r\n        this.getPoint(t1, this._tmpVec2A);\r\n        this.getPoint(t2, out);\r\n\r\n        return out.subtract(this._tmpVec2A).normalize();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangentAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getTangentAt: function (u, out)\r\n    {\r\n        var t = this.getUtoTmapping(u);\r\n\r\n        return this.getTangent(t, out);\r\n    },\r\n\r\n    //  Given a distance in pixels, get a t to find p.\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTFromDistance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} distance - [description]\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getTFromDistance: function (distance, divisions)\r\n    {\r\n        if (distance <= 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        return this.getUtoTmapping(0, distance, divisions);\r\n    },\r\n\r\n    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getUtoTmapping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} u - [description]\r\n     * @param {integer} distance - [description]\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getUtoTmapping: function (u, distance, divisions)\r\n    {\r\n        var arcLengths = this.getLengths(divisions);\r\n\r\n        var i = 0;\r\n        var il = arcLengths.length;\r\n\r\n        var targetArcLength; // The targeted u distance value to get\r\n\r\n        if (distance)\r\n        {\r\n            //  Cannot overshoot the curve\r\n            targetArcLength = Math.min(distance, arcLengths[il - 1]);\r\n        }\r\n        else\r\n        {\r\n            targetArcLength = u * arcLengths[il - 1];\r\n        }\r\n\r\n        // binary search for the index with largest value smaller than target u distance\r\n\r\n        var low = 0;\r\n        var high = il - 1;\r\n        var comparison;\r\n\r\n        while (low <= high)\r\n        {\r\n            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n            comparison = arcLengths[i] - targetArcLength;\r\n\r\n            if (comparison < 0)\r\n            {\r\n                low = i + 1;\r\n            }\r\n            else if (comparison > 0)\r\n            {\r\n                high = i - 1;\r\n            }\r\n            else\r\n            {\r\n                high = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        i = high;\r\n\r\n        if (arcLengths[i] === targetArcLength)\r\n        {\r\n            return i / (il - 1);\r\n        }\r\n\r\n        // we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n        var lengthBefore = arcLengths[i];\r\n        var lengthAfter = arcLengths[i + 1];\r\n\r\n        var segmentLength = lengthAfter - lengthBefore;\r\n\r\n        // determine where we are between the 'before' and 'after' points\r\n\r\n        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\r\n\r\n        // add that fractional amount to t\r\n\r\n        return (i + segmentFraction) / (il - 1);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#updateArcLengths\r\n     * @since 3.0.0\r\n     */\r\n    updateArcLengths: function ()\r\n    {\r\n        this.needsUpdate = true;\r\n\r\n        this.getLengths();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Curve;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Class","FromPoints","Rectangle","Vector2","Curve","initialize","type","defaultDivisions","arcLengthDivisions","cacheArcLengths","active","needsUpdate","_tmpVec2A","_tmpVec2B","draw","graphics","pointsTotal","undefined","strokePoints","getPoints","getBounds","out","accuracy","len","getLength","getSpacedPoints","Math","max","spaced","round","getDistancePoints","distance","getEndPoint","getPointAt","lengths","getLengths","length","divisions","cache","last","getPoint","sum","push","p","current","copy","u","t","getUtoTmapping","points","d","getRandomPoint","random","getStartPoint","getTangent","t1","delta","t2","subtract","normalize","getTangentAt","getTFromDistance","arcLengths","il","targetArcLength","min","low","high","comparison","i","floor","lengthBefore","lengthAfter","updateArcLengths"]
}
