{
"version":3,
"file":"module$node_modules$Phaser$src$geom$intersects$TriangleToTriangle.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,kEAAA,CAAsF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAO9H,IAAIC,cAAgBH,OAAA,CAAQ,4DAAR,CAApB,CACII,UAAYJ,OAAA,CAAQ,wDAAR,CADhB,CAEIK,WAAaL,OAAA,CAAQ,2DAAR,CAyEjBC,OAAAC,QAAA,CA5DyBI,QAAS,CAACC,SAAD,CAAYC,SAAZ,CAClC,CAGI,GACID,SAAAE,KADJ,CACqBD,SAAAE,MADrB,EAEIH,SAAAG,MAFJ,CAEsBF,SAAAC,KAFtB,EAGIF,SAAAI,IAHJ,CAGoBH,SAAAI,OAHpB;AAIIL,SAAAK,OAJJ,CAIuBJ,SAAAG,IAJvB,CAMI,MAAO,CAAA,CAGX,KAAIE,OAASN,SAAAO,SAAA,EAAb,CACIC,OAASR,SAAAS,SAAA,EADb,CAEIC,OAASV,SAAAW,SAAA,EAFb,CAIIC,OAASX,SAAAM,SAAA,EAJb,CAKIM,OAASZ,SAAAQ,SAAA,EALb,CAMIK,OAASb,SAAAU,SAAA,EAab,IAVIb,UAAA,CAAWQ,MAAX,CAAmBM,MAAnB,CAUJ,EAVkCd,UAAA,CAAWQ,MAAX,CAAmBO,MAAnB,CAUlC,EAVgEf,UAAA,CAAWQ,MAAX,CAAmBQ,MAAnB,CAUhE,EALIhB,UAAA,CAAWU,MAAX,CAAmBI,MAAnB,CAKJ,EALkCd,UAAA,CAAWU,MAAX,CAAmBK,MAAnB,CAKlC,EALgEf,UAAA,CAAWU,MAAX,CAAmBM,MAAnB,CAKhE,EAAIhB,UAAA,CAAWY,MAAX,CAAmBE,MAAnB,CAAJ,EAAkCd,UAAA,CAAWY,MAAX,CAAmBG,MAAnB,CAAlC,EAAgEf,UAAA,CAAWY,MAAX,CAAmBI,MAAnB,CAAhE,CAEI,MAAO,CAAA,CAKPC,OAAAA,CAASlB,SAAA,CAAUG,SAAV,CACTgB,OAAAA;AAASpB,aAAA,CAAcK,SAAd,CAAyBc,MAAzB,CAAiC,CAAA,CAAjC,CAEb,IAAoB,CAApB,CAAIC,MAAAC,OAAJ,CAEI,MAAO,CAAA,CAKXF,OAAA,CAASlB,SAAA,CAAUI,SAAV,CACTe,OAAA,CAASpB,aAAA,CAAcI,SAAd,CAAyBe,MAAzB,CAAiC,CAAA,CAAjC,CAET,OAAoB,EAApB,CAAIC,MAAAC,OAAJ,CAEW,CAAA,CAFX,CAKO,CAAA,CAxDX,CAvB8H;",
"sources":["node_modules/Phaser/src/geom/intersects/TriangleToTriangle.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$geom$intersects$TriangleToTriangle\"] = function(global,require,module,exports) {\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\nvar ContainsArray = require('../triangle/ContainsArray');\r\nvar Decompose = require('../triangle/Decompose');\r\nvar LineToLine = require('./LineToLine');\r\n\r\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.TriangleToTriangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangleA - [description]\r\n * @param {Phaser.Geom.Triangle} triangleB - [description]\r\n *\r\n * @return {boolean} [description]\r\n */\r\nvar TriangleToTriangle = function (triangleA, triangleB)\r\n{\r\n    //  First the cheapest ones:\r\n\r\n    if (\r\n        triangleA.left > triangleB.right ||\r\n        triangleA.right < triangleB.left ||\r\n        triangleA.top > triangleB.bottom ||\r\n        triangleA.bottom < triangleB.top)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var lineAA = triangleA.getLineA();\r\n    var lineAB = triangleA.getLineB();\r\n    var lineAC = triangleA.getLineC();\r\n\r\n    var lineBA = triangleB.getLineA();\r\n    var lineBB = triangleB.getLineB();\r\n    var lineBC = triangleB.getLineC();\r\n\r\n    //  Now check the lines against each line of TriangleB\r\n    if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    //  Nope, so check to see if any of the points of triangleA are within triangleB\r\n\r\n    var points = Decompose(triangleA);\r\n    var within = ContainsArray(triangleB, points, true);\r\n\r\n    if (within.length > 0)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    //  Finally check to see if any of the points of triangleB are within triangleA\r\n\r\n    points = Decompose(triangleB);\r\n    within = ContainsArray(triangleA, points, true);\r\n\r\n    if (within.length > 0)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nmodule.exports = TriangleToTriangle;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","ContainsArray","Decompose","LineToLine","TriangleToTriangle","triangleA","triangleB","left","right","top","bottom","lineAA","getLineA","lineAB","getLineB","lineAC","getLineC","lineBA","lineBB","lineBC","points","within","length"]
}
