{
"version":3,
"file":"module$node_modules$Phaser$src$utils$Class.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/Phaser/src/utils/Class.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$utils$Class\"] = function(global,require,module,exports) {\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class  Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","extend","ctor","definition","isClassDescriptor","k","hasOwnProperty","def","Object","getOwnPropertyDescriptor","value","get","set","enumerable","configurable","prop","prototype","Class","ignoreFinals","Error","defineProperty","mixin","myClass","mixins","Array","isArray","i","length","initialize","Extends","base","apply","arguments","create","constructor","Mixins"]
}
