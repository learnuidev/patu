{"version":3,"sources":["shadow/remote/runtime/cljs/js_builtins.cljs"],"mappings":";;;;AAKA,AAAA,AAAA,AAAAA,AAAAC,AAAA,AAAA;;AAAA,AAAAD,AAAAE,AAAA,AAOE,AAASE;AAAT,AACE,AAAA,AAAQ,AAAY,AAAaA,AAAGC;AAClCD;;AACA,AAACE,AAEM,AAACE,AACC,AAAKC,AAAEC,AAGT,AAACI;AAHC,AACE,AAACH,AAAOF,AAAEC,AAAI,AAACE,AAASR,AAAEM;AAJrC,AAAA,AAAA,AACO,AAACH,AAAaH,AAIZ,AAAA,AAACS,AAGA,AAAKE,AAAKC,AAAEC;AAAZ,AACE,AAACL,AAASR,AAAEY;;;;;AAnB9B,AAAA,AAAAhB,AAAAC,AAAA,AAAA;;AAAA,AAAAD,AAAAE,AAAA,AAsBE,AAASE;AAAT,AACE,AAACc,AAAId;;;AAvBT,AAAA,AAAA,AAAA,AAAAD,AAyBEgB;;AAzBF,AAAA,AAAA,AAyBEA,AACA,AAASC;AAAT,AAAA,AAAA,AAASA;AAAT,AACE,AAAMC,AAAK,AAACC,AAAQF;AACdG,AAAK,AAAYH;AACjBI,AAAK,AAAcJ;AACnBK,AAAO,AAAgBL;AAH7B,AAIgB,AAAWA,AACd,AAAQA,AACP,AAASA,AACjB,AAAAM,AAAA,AAAA,AAAA,AAAA;AAAAA,AAAA,AAAAA,AACE,AAAA,AAAA,AAAOL,AACP,AAAAK,AAAA,AAACC,AAAYN;AAFfK,AAAA,AAAAA,AAIEH,AACA,AAAAG,AAAA,AAACC,AAAYJ;AALfG,AAAA,AAAAA,AAOEF,AACA,AAAAE,AAAA,AAACC,AAAYH;AARf,AAAA,AAUEC;AACA,AAAAC,AAAA,AAACC,AAAcF;;AAXjBC","names":["goog.object/set","clojure.core.protocols/Datafiable","clojure.core.protocols/datafy","cljs.core/PROTOCOL_SENTINEL","o","js/Object.prototype","cljs.core/with-meta","goog.object/getKeys","cljs.core.reduce","m","key","cljs.core.assoc_BANG_","goog.object/get","cljs.core/transient","cljs.core/persistent!","coll","k","v","cljs.core/vec","js/Error","e","data","cljs.core/ex-data","file","line","column","G__34646","cljs.core.assoc"],"sourcesContent":["(ns shadow.remote.runtime.cljs.js-builtins\n  (:require\n    [goog.object :as gobj]\n    [clojure.core.protocols :as p]))\n\n(extend-protocol p/Datafiable\n  ;; FIXME: this is kind of a bad idea\n  ;; can't do this for all objects, since none of the CLJS types implement this\n  ;; protocol either. the protocol dispatch will end up using object\n  ;; FIXME: this could detect CLJS types to some extent\n  ;; or should it just implement the protocols for the types?\n  object\n  (datafy [o]\n    (if-not (identical? (.-__proto__ o) js/Object.prototype)\n      o\n      (with-meta\n        (->> (gobj/getKeys o)\n             (reduce\n               (fn [m key]\n                 (assoc! m key (gobj/get o key)))\n               (transient {}))\n             (persistent!))\n\n        {`p/nav (fn [coll k v]\n                  (gobj/get o k))})))\n\n  array\n  (datafy [o]\n    (vec o))\n\n  js/Error\n  (datafy [e]\n    (let [data (ex-data e)\n          file (.-fileName e)\n          line (.-lineNumber e)\n          column (.-columnNumber e)]\n      (-> {:message (.-message e)\n           :name (.-name e)\n           :stack (.-stack e)}\n          (cond->\n            (some? data)\n            (assoc :data data)\n\n            file\n            (assoc :file file)\n\n            line\n            (assoc :line line)\n\n            column\n            (assoc :column column)\n            )))))\n"]}