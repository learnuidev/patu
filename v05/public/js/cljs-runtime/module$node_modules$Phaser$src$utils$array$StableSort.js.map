{
"version":3,
"file":"module$node_modules$Phaser$src$utils$array$StableSort.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,sDAAA,CAA0E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAUjH,SAAQ,EAAG,CAuBZC,QAASA,KAAI,CAACC,GAAD,CAAMC,IAAN,CAAY,CACA,UAArB,GAAI,MAAOA,KAAX,GACIA,IADJ,CACWA,QAAQ,CAACC,CAAD,CAAIC,CAAJ,CAAO,CAClB,MAAOC,OAAA,CAAOF,CAAP,CAAAG,cAAA,CAAwBF,CAAxB,CADW,CAD1B,CAOA,KAAIG,IAAMN,GAAAO,OACV,IAAW,CAAX,EAAID,GAAJ,CACI,MAAON,IAOX,KADA,IAAIQ,OAAaC,KAAJ,CAAUH,GAAV,CAAb,CACSI,IAAM,CAAf,CAAkBA,GAAlB,CAAwBJ,GAAxB,CAA6BI,GAA7B,EAAoC,CAApC,CAAuC,CACnCC,IAAA,CAAKX,GAAL,CAAUC,IAAV,CAAgBS,GAAhB,CAAqBF,MAArB,CAEA,KAAII,IAAMZ,GACVA,IAAA,CAAMQ,MACNA,OAAA,CAASI,GAL0B,CAQvC,MAAOZ,IAzBc,CAlBzB,IAAIa,OAASA,QAAQ,CAACb,GAAD,CAAMC,IAAN,CAAY,CAC7B,MAAOF,KAAA,CAAKC,GAAAc,MAAA,EAAL,CAAkBb,IAAlB,CADsB,CAIjCY,OAAAE,QAAA,CAAiBC,QAAQ,CAAChB,GAAD,CAAMC,IAAN,CAAY,CAC7BgB,IAAAA,CAASlB,IAAA,CAAKC,GAAL,CAAUC,IAAV,CAITgB;IAAJ,GAAejB,GAAf,EACIW,IAAA,CAAKM,IAAL,CAAa,IAAb,CAAmBjB,GAAAO,OAAnB,CAA+BP,GAA/B,CAGJ,OAAOA,IAT0B,CA2CrC,KAAIW,KAAOA,QAAQ,CAACX,GAAD,CAAMC,IAAN,CAAYS,GAAZ,CAAiBO,MAAjB,CAAyB,CACxC,IAAIX,IAAMN,GAAAO,OAAV,CACIW,EAAI,CADR,CAGIC,IAAY,CAAZA,CAAMT,GAHV,CAKIU,CALJ,CAOQC,EAGR,KAAKD,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBd,GAAhB,CAAqBc,CAArB,EAA0BD,GAA1B,CAA+B,CAC3B,IAAAG,EAAIF,CAAJE,CAAQZ,GACR,KAAAa,EAAID,CAAJC,CAAQb,GACJY,EAAJ,CAAQhB,GAAR,GAAagB,CAAb,CAAiBhB,GAAjB,CACIiB,EAAJ,CAAQjB,GAAR,GAAaiB,CAAb,CAAiBjB,GAAjB,CAGA,KAAAkB,GAAKJ,CAEL,KADAC,EACA,CADKC,CACL,CAAA,CAAA,CAEI,GAAIE,EAAJ,CAASF,CAAT,EAAcD,EAAd,CAAmBE,CAAnB,CAGkC,CAA9B,EAAItB,IAAA,CAAKD,GAAA,CAAIwB,EAAJ,CAAL,CAAcxB,GAAA,CAAIqB,EAAJ,CAAd,CAAJ,CACIJ,MAAA,CAAOC,CAAA,EAAP,CADJ,CACkBlB,GAAA,CAAIwB,EAAA,EAAJ,CADlB,CAIIP,MAAA,CAAOC,CAAA,EAAP,CAJJ,CAIkBlB,GAAA,CAAIqB,EAAA,EAAJ,CAPtB,KAWK,IAAIG,EAAJ,CAASF,CAAT,CACDL,MAAA,CAAOC,CAAA,EAAP,CAAA,CAAclB,GAAA,CAAIwB,EAAA,EAAJ,CADb,KAGA,IAAIH,EAAJ,CAASE,CAAT,CACDN,MAAA,CAAOC,CAAA,EAAP,CAAA,CAAclB,GAAA,CAAIqB,EAAA,EAAJ,CADb,KAKD,MA9BmB,CAXS,CAgDrB,YAAvB,GAAI,MAAOxB,OAAX,CACIA,MAAAC,QADJ,CACqBe,MADrB,CAIIY,MAAAZ,OAJJ,CAIoBA,MAxGR,CAAX,CAAD,EAVkH;",
"sources":["node_modules/Phaser/src/utils/array/StableSort.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$utils$array$StableSort\"] = function(global,require,module,exports) {\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n//! stable.js 0.1.6, https://github.com/Two-Screen/stable\r\n//! \u00a9 2017 Angry Bytes and contributors. MIT licensed.\r\n\r\n(function() {\r\n\r\n// A stable array sort, because `Array#sort()` is not guaranteed stable.\r\n// This is an implementation of merge sort, without recursion.\r\n\r\nvar stable = function(arr, comp) {\r\n    return exec(arr.slice(), comp);\r\n};\r\n\r\nstable.inplace = function(arr, comp) {\r\n    var result = exec(arr, comp);\r\n\r\n    // This simply copies back if the result isn't in the original array,\r\n    // which happens on an odd number of passes.\r\n    if (result !== arr) {\r\n        pass(result, null, arr.length, arr);\r\n    }\r\n\r\n    return arr;\r\n};\r\n\r\n// Execute the sort using the input array and a second buffer as work space.\r\n// Returns one of those two, containing the final result.\r\nfunction exec(arr, comp) {\r\n    if (typeof(comp) !== 'function') {\r\n        comp = function(a, b) {\r\n            return String(a).localeCompare(b);\r\n        };\r\n    }\r\n\r\n    // Short-circuit when there's nothing to sort.\r\n    var len = arr.length;\r\n    if (len <= 1) {\r\n        return arr;\r\n    }\r\n\r\n    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\r\n    // Chunks are the size of the left or right hand in merge sort.\r\n    // Stop when the left-hand covers all of the array.\r\n    var buffer = new Array(len);\r\n    for (var chk = 1; chk < len; chk *= 2) {\r\n        pass(arr, comp, chk, buffer);\r\n\r\n        var tmp = arr;\r\n        arr = buffer;\r\n        buffer = tmp;\r\n    }\r\n\r\n    return arr;\r\n}\r\n\r\n// Run a single pass with the given chunk size.\r\nvar pass = function(arr, comp, chk, result) {\r\n    var len = arr.length;\r\n    var i = 0;\r\n    // Step size / double chunk size.\r\n    var dbl = chk * 2;\r\n    // Bounds of the left and right chunks.\r\n    var l, r, e;\r\n    // Iterators over the left and right chunk.\r\n    var li, ri;\r\n\r\n    // Iterate over pairs of chunks.\r\n    for (l = 0; l < len; l += dbl) {\r\n        r = l + chk;\r\n        e = r + chk;\r\n        if (r > len) r = len;\r\n        if (e > len) e = len;\r\n\r\n        // Iterate both chunks in parallel.\r\n        li = l;\r\n        ri = r;\r\n        while (true) {\r\n            // Compare the chunks.\r\n            if (li < r && ri < e) {\r\n                // This works for a regular `sort()` compatible comparator,\r\n                // but also for a simple comparator like: `a > b`\r\n                if (comp(arr[li], arr[ri]) <= 0) {\r\n                    result[i++] = arr[li++];\r\n                }\r\n                else {\r\n                    result[i++] = arr[ri++];\r\n                }\r\n            }\r\n            // Nothing to compare, just flush what's left.\r\n            else if (li < r) {\r\n                result[i++] = arr[li++];\r\n            }\r\n            else if (ri < e) {\r\n                result[i++] = arr[ri++];\r\n            }\r\n            // Both iterators are at the chunk ends.\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n// Export using CommonJS or to the window.\r\nif (typeof(module) !== 'undefined') {\r\n    module.exports = stable;\r\n}\r\nelse {\r\n    window.stable = stable;\r\n}\r\n\r\n})();\n};"],
"names":["shadow$provide","global","require","module","exports","exec","arr","comp","a","b","String","localeCompare","len","length","buffer","Array","chk","pass","tmp","stable","slice","inplace","stable.inplace","result","i","dbl","l","ri","r","e","li","window"]
}
