{
"version":3,
"file":"module$node_modules$Phaser$src$renderer$webgl$pipelines$BitmapMaskPipeline.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/Phaser/src/renderer/webgl/pipelines/BitmapMaskPipeline.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$renderer$webgl$pipelines$BitmapMaskPipeline\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar ShaderSourceFS = require('../shaders/BitmapMask-frag.js');\r\nvar ShaderSourceVS = require('../shaders/BitmapMask-vert.js');\r\nvar WebGLPipeline = require('../WebGLPipeline');\r\n\r\n/**\r\n * @classdesc\r\n * BitmapMaskPipeline handles all bitmap masking rendering in WebGL. It works by using \r\n * sampling two texture on the fragment shader and using the fragment's alpha to clip the region.\r\n * The config properties are:\r\n * - game: Current game instance.\r\n * - renderer: Current WebGL renderer.\r\n * - topology: This indicates how the primitives are rendered. The default value is GL_TRIANGLES.\r\n *              Here is the full list of rendering primitives (https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants).\r\n * - vertShader: Source for vertex shader as a string.\r\n * - fragShader: Source for fragment shader as a string.\r\n * - vertexCapacity: The amount of vertices that shall be allocated\r\n * - vertexSize: The size of a single vertex in bytes.\r\n *\r\n * @class BitmapMaskPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberOf Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - Used for overriding shader an pipeline properties if extending this pipeline.\r\n */\r\nvar BitmapMaskPipeline = new Class({\r\n\r\n    Extends: WebGLPipeline,\r\n    \r\n    initialize:\r\n\r\n    function BitmapMaskPipeline (config)\r\n    {\r\n        WebGLPipeline.call(this, {\r\n            game: config.game,\r\n            renderer: config.renderer,\r\n            gl: config.renderer.gl,\r\n            topology: (config.topology ? config.topology : config.renderer.gl.TRIANGLES),\r\n            vertShader: (config.vertShader ? config.vertShader : ShaderSourceVS),\r\n            fragShader: (config.fragShader ? config.fragShader : ShaderSourceFS),\r\n            vertexCapacity: (config.vertexCapacity ? config.vertexCapacity : 3),\r\n\r\n            vertexSize: (config.vertexSize ? config.vertexSize :\r\n                Float32Array.BYTES_PER_ELEMENT * 2),\r\n\r\n            vertices: new Float32Array([\r\n                -1, +1, -1, -7, +7, +1\r\n            ]).buffer,\r\n\r\n            attributes: [\r\n                {\r\n                    name: 'inPosition',\r\n                    size: 2,\r\n                    type: config.renderer.gl.FLOAT,\r\n                    normalized: false,\r\n                    offset: 0\r\n                }\r\n            ]\r\n        });\r\n\r\n        /**\r\n         * Float32 view of the array buffer containing the pipeline's vertices.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.vertexViewF32 = new Float32Array(this.vertexData);\r\n\r\n        /**\r\n         * Size of the batch.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#maxQuads\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.maxQuads = 1;\r\n\r\n        /**\r\n         * Dirty flag to check if resolution properties need to be updated on the \r\n         * masking shader.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resolutionDirty\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.resolutionDirty = true;\r\n    },\r\n\r\n    /**\r\n     * Called every time the pipeline needs to be used.\r\n     * It binds all necessary resources.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#onBind\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    onBind: function ()\r\n    {\r\n        WebGLPipeline.prototype.onBind.call(this);\r\n\r\n        var renderer = this.renderer;\r\n        var program = this.program;\r\n        \r\n        if (this.resolutionDirty)\r\n        {\r\n            renderer.setFloat2(program, 'uResolution', this.width, this.height);\r\n            renderer.setInt1(program, 'uMainSampler', 0);\r\n            renderer.setInt1(program, 'uMaskSampler', 1);\r\n            this.resolutionDirty = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} resolution - [description]\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    resize: function (width, height, resolution)\r\n    {\r\n        WebGLPipeline.prototype.resize.call(this, width, height, resolution);\r\n        this.resolutionDirty = true;\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds necessary resources and renders the mask to a separated framebuffer.\r\n     * The framebuffer for the masked object is also bound for further use.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#beginMask\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} mask - GameObject used as mask.\r\n     * @param {Phaser.GameObjects.GameObject} maskedObject - GameObject masked by the mask GameObject.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */\r\n    beginMask: function (mask, maskedObject, camera)\r\n    {\r\n        var renderer = this.renderer;\r\n        var gl = this.gl;\r\n\r\n        //  The renderable Game Object that is being used for the bitmap mask\r\n        var bitmapMask = mask.bitmapMask;\r\n\r\n        if (bitmapMask && gl)\r\n        {\r\n            renderer.flush();\r\n\r\n            // First we clear the mask framebuffer\r\n            renderer.setFramebuffer(mask.maskFramebuffer);\r\n            gl.clearColor(0, 0, 0, 0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n            // We render our mask source\r\n            bitmapMask.renderWebGL(renderer, bitmapMask, 0, camera);\r\n            renderer.flush();\r\n\r\n            // Bind and clear our main source (masked object)\r\n            renderer.setFramebuffer(mask.mainFramebuffer);\r\n\r\n            gl.clearColor(0, 0, 0, 0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The masked game object's framebuffer is unbound and it's texture \r\n     * is bound together with the mask texture and the mask shader and \r\n     * a draw call with a single quad is processed. Here is where the\r\n     * masking effect is applied.  \r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#endMask\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} mask - GameObject used as a mask.\r\n     */\r\n    endMask: function (mask)\r\n    {\r\n        var renderer = this.renderer;\r\n        var gl = this.gl;\r\n\r\n        //  The renderable Game Object that is being used for the bitmap mask\r\n        var bitmapMask = mask.bitmapMask;\r\n\r\n        if (bitmapMask && gl)\r\n        {\r\n            // Return to default framebuffer\r\n            renderer.setFramebuffer(null);\r\n            \r\n            // Bind bitmap mask pipeline and draw\r\n            renderer.setPipeline(this);\r\n            \r\n            renderer.setTexture2D(mask.maskTexture, 1);\r\n            renderer.setTexture2D(mask.mainTexture, 0);\r\n            renderer.setInt1(this.program, 'uInvertMaskAlpha', mask.invertAlpha);\r\n\r\n            // Finally draw a triangle filling the whole screen\r\n            gl.drawArrays(this.topology, 0, 3);\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BitmapMaskPipeline;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Class","ShaderSourceFS","ShaderSourceVS","WebGLPipeline","BitmapMaskPipeline","Extends","initialize","config","call","game","renderer","gl","topology","TRIANGLES","vertShader","fragShader","vertexCapacity","vertexSize","Float32Array","BYTES_PER_ELEMENT","vertices","buffer","attributes","name","size","type","FLOAT","normalized","offset","vertexViewF32","vertexData","maxQuads","resolutionDirty","onBind","prototype","program","setFloat2","width","height","setInt1","resize","resolution","beginMask","mask","maskedObject","camera","bitmapMask","flush","setFramebuffer","maskFramebuffer","clearColor","clear","COLOR_BUFFER_BIT","renderWebGL","mainFramebuffer","endMask","setPipeline","setTexture2D","maskTexture","mainTexture","invertAlpha","drawArrays"]
}
