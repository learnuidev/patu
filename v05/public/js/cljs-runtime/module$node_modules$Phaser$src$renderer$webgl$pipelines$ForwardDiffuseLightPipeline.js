shadow$provide.module$node_modules$Phaser$src$renderer$webgl$pipelines$ForwardDiffuseLightPipeline=function(global,require,module,exports){global=require("module$node_modules$Phaser$src$utils$Class");var ShaderSourceFS=require("module$node_modules$Phaser$src$renderer$webgl$shaders$ForwardDiffuse_frag"),TextureTintPipeline=require("module$node_modules$Phaser$src$renderer$webgl$pipelines$TextureTintPipeline");require=new global({Extends:TextureTintPipeline,initialize:function(config){config.fragShader=
ShaderSourceFS.replace("%LIGHT_COUNT%",(10).toString());TextureTintPipeline.call(this,config)},boot:function(){this.defaultNormalMap=this.game.textures.getFrame("__DEFAULT")},onBind:function(gameObject){TextureTintPipeline.prototype.onBind.call(this);var renderer=this.renderer,program=this.program;this.mvpUpdate();renderer.setInt1(program,"uNormSampler",1);renderer.setFloat2(program,"uResolution",this.width,this.height);gameObject&&this.setNormalMap(gameObject);return this},onRender:function(scene,
camera){this.active=!1;var lightManager=scene.sys.lights;if(!lightManager||0>=lightManager.lights.length||!lightManager.active)return this;scene=lightManager.cull(camera);var lightCount=Math.min(scene.length,10);if(0===lightCount)return this;this.active=!0;var renderer=this.renderer,program=this.program,cameraMatrix=camera.matrix,point={x:0,y:0},height=renderer.height,index;for(index=0;10>index;++index)renderer.setFloat1(program,"uLights["+index+"].radius",0);renderer.setFloat4(program,"uCamera",
camera.x,camera.y,camera.rotation,camera.zoom);renderer.setFloat3(program,"uAmbientLightColor",lightManager.ambientColor.r,lightManager.ambientColor.g,lightManager.ambientColor.b);for(index=0;index<lightCount;++index){lightManager=scene[index];var lightName="uLights["+index+"].";cameraMatrix.transformPoint(lightManager.x,lightManager.y,point);renderer.setFloat2(program,lightName+"position",point.x-camera.scrollX*lightManager.scrollFactorX*camera.zoom,height-(point.y-camera.scrollY*lightManager.scrollFactorY*
camera.zoom));renderer.setFloat3(program,lightName+"color",lightManager.r,lightManager.g,lightManager.b);renderer.setFloat1(program,lightName+"intensity",lightManager.intensity);renderer.setFloat1(program,lightName+"radius",lightManager.radius)}return this},batchTexture:function(gameObject,texture,textureWidth,textureHeight,srcX,srcY,srcWidth,srcHeight,scaleX,scaleY,rotation,flipX,flipY,scrollFactorX,scrollFactorY,displayOriginX,displayOriginY,frameX,frameY,frameWidth,frameHeight,tintTL,tintTR,tintBL,
tintBR,tintEffect,uOffset,vOffset,camera,parentTransformMatrix){if(this.active){this.renderer.setPipeline(this);var normalTexture;gameObject.displayTexture?normalTexture=gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex]:gameObject.texture?normalTexture=gameObject.texture.dataSource[gameObject.frame.sourceIndex]:gameObject.tileset&&(normalTexture=gameObject.tileset.image.dataSource[0]);if(normalTexture){this.setTexture2D(normalTexture.glTexture,1);var camMatrix=this._tempMatrix1,
spriteMatrix=this._tempMatrix2,calcMatrix=this._tempMatrix3;normalTexture=frameX/textureWidth+uOffset;var v0=frameY/textureHeight+vOffset,u1=(frameX+frameWidth)/textureWidth+uOffset,v1=(frameY+frameHeight)/textureHeight+vOffset,width=srcWidth,height=srcHeight;frameX=-displayOriginX;frameY=-displayOriginY;gameObject.isCropped&&(v1=gameObject._crop,width=v1.width,height=v1.height,srcWidth=v1.width,srcHeight=v1.height,frameX=v1.x,frameY=v1.y,u1=frameX,gameObject=frameY,flipX&&(u1=frameWidth-v1.x-v1.width),
flipY&&!texture.isRenderTexture&&(gameObject=frameHeight-v1.y-v1.height),normalTexture=u1/textureWidth+uOffset,v0=gameObject/textureHeight+vOffset,u1=(u1+v1.width)/textureWidth+uOffset,v1=(gameObject+v1.height)/textureHeight+vOffset,frameX=-displayOriginX+frameX,frameY=-displayOriginY+frameY);flipY^=texture.isRenderTexture?1:0;flipX&&(width*=-1,frameX+=srcWidth);flipY&&(height*=-1,frameY+=srcHeight);textureWidth=frameX+width;textureHeight=frameY+height;spriteMatrix.applyITRS(srcX,srcY,rotation,scaleX,
scaleY);camMatrix.copyFrom(camera.matrix);parentTransformMatrix?(camMatrix.multiplyWithOffset(parentTransformMatrix,-camera.scrollX*scrollFactorX,-camera.scrollY*scrollFactorY),spriteMatrix.e=srcX,spriteMatrix.f=srcY):(spriteMatrix.e-=camera.scrollX*scrollFactorX,spriteMatrix.f-=camera.scrollY*scrollFactorY);camMatrix.multiply(spriteMatrix,calcMatrix);srcX=calcMatrix.getX(frameX,frameY);srcY=calcMatrix.getY(frameX,frameY);scaleX=calcMatrix.getX(frameX,textureHeight);scaleY=calcMatrix.getY(frameX,
textureHeight);rotation=calcMatrix.getX(textureWidth,textureHeight);scrollFactorX=calcMatrix.getY(textureWidth,textureHeight);scrollFactorY=calcMatrix.getX(textureWidth,frameY);calcMatrix=calcMatrix.getY(textureWidth,frameY);camera.roundPixels&&(srcX|=0,srcY|=0,scaleX|=0,scaleY|=0,rotation|=0,scrollFactorX|=0,scrollFactorY|=0,calcMatrix|=0);this.setTexture2D(texture,0);this.batchQuad(srcX,srcY,scaleX,scaleY,rotation,scrollFactorX,scrollFactorY,calcMatrix,normalTexture,v0,u1,v1,tintTL,tintTR,tintBL,
tintBR,tintEffect)}else console.warn("Normal map missing or invalid")}},setNormalMap:function(gameObject){if(this.active&&gameObject){var normalTexture;gameObject.texture&&(normalTexture=gameObject.texture.dataSource[gameObject.frame.sourceIndex]);normalTexture||(normalTexture=this.defaultNormalMap);this.setTexture2D(normalTexture.glTexture,1);this.renderer.setPipeline(gameObject.defaultPipeline)}},batchSprite:function(sprite,camera,parentTransformMatrix){if(this.active){var normalTexture=sprite.texture.dataSource[sprite.frame.sourceIndex];
normalTexture&&(this.renderer.setPipeline(this),this.setTexture2D(normalTexture.glTexture,1),TextureTintPipeline.prototype.batchSprite.call(this,sprite,camera,parentTransformMatrix))}}});require.LIGHT_COUNT=10;module.exports=require}
//# sourceMappingURL=module$node_modules$Phaser$src$renderer$webgl$pipelines$ForwardDiffuseLightPipeline.js.map
