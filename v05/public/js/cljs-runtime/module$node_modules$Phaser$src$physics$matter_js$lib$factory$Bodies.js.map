{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$lib$factory$Bodies.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/matter-js/lib/factory/Bodies.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$lib$factory$Bodies\"] = function(global,require,module,exports) {\n/**\r\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \r\n* with commonly used body configurations (such as rectangles, circles and other polygons).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Bodies\r\n*/\r\n\r\n// TODO: true circle bodies\r\n\r\nvar Bodies = {};\r\n\r\nmodule.exports = Bodies;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Common = require('../core/Common');\r\nvar Body = require('../body/Body');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Vector = require('../geometry/Vector');\r\nvar decomp = require('../../poly-decomp');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new rigid body model with a rectangle hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method rectangle\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {object} [options]\r\n     * @return {body} A new rectangle body\r\n     */\r\n    Bodies.rectangle = function(x, y, width, height, options) {\r\n        options = options || {};\r\n\r\n        var rectangle = { \r\n            label: 'Rectangle Body',\r\n            position: { x: x, y: y },\r\n            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\r\n        };\r\n\r\n        if (options.chamfer) {\r\n            var chamfer = options.chamfer;\r\n            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, \r\n                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\r\n            delete options.chamfer;\r\n        }\r\n\r\n        return Body.create(Common.extend({}, rectangle, options));\r\n    };\r\n    \r\n    /**\r\n     * Creates a new rigid body model with a trapezoid hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method trapezoid\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {number} slope\r\n     * @param {object} [options]\r\n     * @return {body} A new trapezoid body\r\n     */\r\n    Bodies.trapezoid = function(x, y, width, height, slope, options) {\r\n        options = options || {};\r\n\r\n        slope *= 0.5;\r\n        var roof = (1 - (slope * 2)) * width;\r\n        \r\n        var x1 = width * slope,\r\n            x2 = x1 + roof,\r\n            x3 = x2 + x1,\r\n            verticesPath;\r\n\r\n        if (slope < 0.5) {\r\n            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\r\n        } else {\r\n            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\r\n        }\r\n\r\n        var trapezoid = { \r\n            label: 'Trapezoid Body',\r\n            position: { x: x, y: y },\r\n            vertices: Vertices.fromPath(verticesPath)\r\n        };\r\n\r\n        if (options.chamfer) {\r\n            var chamfer = options.chamfer;\r\n            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, \r\n                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\r\n            delete options.chamfer;\r\n        }\r\n\r\n        return Body.create(Common.extend({}, trapezoid, options));\r\n    };\r\n\r\n    /**\r\n     * Creates a new rigid body model with a circle hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method circle\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} radius\r\n     * @param {object} [options]\r\n     * @param {number} [maxSides]\r\n     * @return {body} A new circle body\r\n     */\r\n    Bodies.circle = function(x, y, radius, options, maxSides) {\r\n        options = options || {};\r\n\r\n        var circle = {\r\n            label: 'Circle Body',\r\n            circleRadius: radius\r\n        };\r\n        \r\n        // approximate circles with polygons until true circles implemented in SAT\r\n        maxSides = maxSides || 25;\r\n        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\r\n\r\n        // optimisation: always use even number of sides (half the number of unique axes)\r\n        if (sides % 2 === 1)\r\n            sides += 1;\r\n\r\n        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\r\n    };\r\n\r\n    /**\r\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method polygon\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} sides\r\n     * @param {number} radius\r\n     * @param {object} [options]\r\n     * @return {body} A new regular polygon body\r\n     */\r\n    Bodies.polygon = function(x, y, sides, radius, options) {\r\n        options = options || {};\r\n\r\n        if (sides < 3)\r\n            return Bodies.circle(x, y, radius, options);\r\n\r\n        var theta = 2 * Math.PI / sides,\r\n            path = '',\r\n            offset = theta * 0.5;\r\n\r\n        for (var i = 0; i < sides; i += 1) {\r\n            var angle = offset + (i * theta),\r\n                xx = Math.cos(angle) * radius,\r\n                yy = Math.sin(angle) * radius;\r\n\r\n            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\r\n        }\r\n\r\n        var polygon = { \r\n            label: 'Polygon Body',\r\n            position: { x: x, y: y },\r\n            vertices: Vertices.fromPath(path)\r\n        };\r\n\r\n        if (options.chamfer) {\r\n            var chamfer = options.chamfer;\r\n            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, \r\n                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\r\n            delete options.chamfer;\r\n        }\r\n\r\n        return Body.create(Common.extend({}, polygon, options));\r\n    };\r\n\r\n    /**\r\n     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).\r\n     * If the vertices are convex, they will pass through as supplied.\r\n     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.\r\n     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).\r\n     * By default the decomposition will discard collinear edges (to improve performance).\r\n     * It can also optionally discard any parts that have an area less than `minimumArea`.\r\n     * If the vertices can not be decomposed, the result will fall back to using the convex hull.\r\n     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method fromVertices\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param [[vector]] vertexSets\r\n     * @param {object} [options]\r\n     * @param {bool} [flagInternal=false]\r\n     * @param {number} [removeCollinear=0.01]\r\n     * @param {number} [minimumArea=10]\r\n     * @return {body}\r\n     */\r\n    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {\r\n        var body,\r\n            parts,\r\n            isConvex,\r\n            vertices,\r\n            i,\r\n            j,\r\n            k,\r\n            v,\r\n            z;\r\n\r\n        options = options || {};\r\n        parts = [];\r\n\r\n        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\r\n        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\r\n        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\r\n\r\n        if (!decomp) {\r\n            Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');\r\n        }\r\n\r\n        // ensure vertexSets is an array of arrays\r\n        if (!Common.isArray(vertexSets[0])) {\r\n            vertexSets = [vertexSets];\r\n        }\r\n\r\n        for (v = 0; v < vertexSets.length; v += 1) {\r\n            vertices = vertexSets[v];\r\n            isConvex = Vertices.isConvex(vertices);\r\n\r\n            if (isConvex || !decomp) {\r\n                if (isConvex) {\r\n                    vertices = Vertices.clockwiseSort(vertices);\r\n                } else {\r\n                    // fallback to convex hull when decomposition is not possible\r\n                    vertices = Vertices.hull(vertices);\r\n                }\r\n\r\n                parts.push({\r\n                    position: { x: x, y: y },\r\n                    vertices: vertices\r\n                });\r\n            } else {\r\n                // initialise a decomposition\r\n                var concave = vertices.map(function(vertex) {\r\n                    return [vertex.x, vertex.y];\r\n                });\r\n\r\n                // vertices are concave and simple, we can decompose into parts\r\n                decomp.makeCCW(concave);\r\n                if (removeCollinear !== false)\r\n                    decomp.removeCollinearPoints(concave, removeCollinear);\r\n\r\n                // use the quick decomposition algorithm (Bayazit)\r\n                var decomposed = decomp.quickDecomp(concave);\r\n\r\n                // for each decomposed chunk\r\n                for (i = 0; i < decomposed.length; i++) {\r\n                    var chunk = decomposed[i];\r\n\r\n                    // convert vertices into the correct structure\r\n                    var chunkVertices = chunk.map(function(vertices) {\r\n                        return {\r\n                            x: vertices[0],\r\n                            y: vertices[1]\r\n                        };\r\n                    });\r\n\r\n                    // skip small chunks\r\n                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)\r\n                        continue;\r\n\r\n                    // create a compound part\r\n                    parts.push({\r\n                        position: Vertices.centre(chunkVertices),\r\n                        vertices: chunkVertices\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // create body parts\r\n        for (i = 0; i < parts.length; i++) {\r\n            parts[i] = Body.create(Common.extend(parts[i], options));\r\n        }\r\n\r\n        // flag internal edges (coincident part edges)\r\n        if (flagInternal) {\r\n            var coincident_max_dist = 5;\r\n\r\n            for (i = 0; i < parts.length; i++) {\r\n                var partA = parts[i];\r\n\r\n                for (j = i + 1; j < parts.length; j++) {\r\n                    var partB = parts[j];\r\n\r\n                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {\r\n                        var pav = partA.vertices,\r\n                            pbv = partB.vertices;\r\n\r\n                        // iterate vertices of both parts\r\n                        for (k = 0; k < partA.vertices.length; k++) {\r\n                            for (z = 0; z < partB.vertices.length; z++) {\r\n                                // find distances between the vertices\r\n                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),\r\n                                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\r\n\r\n                                // if both vertices are very close, consider the edge concident (internal)\r\n                                if (da < coincident_max_dist && db < coincident_max_dist) {\r\n                                    pav[k].isInternal = true;\r\n                                    pbv[z].isInternal = true;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (parts.length > 1) {\r\n            // create the parent body to be returned, that contains generated compound parts\r\n            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));\r\n            Body.setPosition(body, { x: x, y: y });\r\n\r\n            return body;\r\n        } else {\r\n            return parts[0];\r\n        }\r\n    };\r\n\r\n})();\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Bodies","Vertices","Common","Body","Bounds","Vector","decomp","rectangle","Bodies.rectangle","x","y","width","height","options","label","position","vertices","fromPath","chamfer","radius","quality","qualityMin","qualityMax","create","extend","trapezoid","Bodies.trapezoid","slope","x1","x2","x3","verticesPath","circle","Bodies.circle","maxSides","circleRadius","sides","Math","ceil","max","min","polygon","Bodies.polygon","theta","PI","path","offset","i","angle","yy","sin","toFixed","cos","fromVertices","Bodies.fromVertices","vertexSets","flagInternal","removeCollinear","minimumArea","isConvex","v","parts","warn","isArray","length","clockwiseSort","hull","push","concave","map","vertex","makeCCW","removeCollinearPoints","decomposed","quickDecomp","chunkVertices","chunk","area","centre","partA","j","partB","overlaps","bounds","pav","pbv","k","z","da","magnitudeSquared","sub","db","coincident_max_dist","isInternal","body","slice","setPosition"]
}
