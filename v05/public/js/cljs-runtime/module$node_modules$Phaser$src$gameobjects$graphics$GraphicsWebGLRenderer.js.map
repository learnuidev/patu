{
"version":3,
"file":"module$node_modules$Phaser$src$gameobjects$graphics$GraphicsWebGLRenderer.js",
"lineCount":12,
"mappings":"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",
"sources":["node_modules/Phaser/src/gameobjects/graphics/GraphicsWebGLRenderer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$gameobjects$graphics$GraphicsWebGLRenderer\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Commands = require('./Commands');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n//  TODO: Remove the use of this\r\nvar Point = function (x, y, width)\r\n{\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n};\r\n\r\n//  TODO: Remove the use of this\r\nvar Path = function (x, y, width)\r\n{\r\n    this.points = [];\r\n    this.pointsLength = 1;\r\n    this.points[0] = new Point(x, y, width);\r\n};\r\n\r\nvar matrixStack = [];\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Graphics} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar GraphicsWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    if (src.commandBuffer.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var pipeline = this.pipeline;\r\n\r\n    var camMatrix = pipeline._tempMatrix1;\r\n    var graphicsMatrix = pipeline._tempMatrix2;\r\n    var currentMatrix = pipeline._tempMatrix4;\r\n   \r\n    renderer.setPipeline(pipeline);\r\n\r\n    currentMatrix.loadIdentity();\r\n\r\n    graphicsMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        graphicsMatrix.e = src.x;\r\n        graphicsMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(graphicsMatrix);\r\n    }\r\n    else\r\n    {\r\n        graphicsMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        graphicsMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(graphicsMatrix);\r\n    }\r\n\r\n    var commands = src.commandBuffer;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    var lineWidth = 1;\r\n    var fillTint = pipeline.fillTint;\r\n    var strokeTint = pipeline.strokeTint;\r\n\r\n    var tx = 0;\r\n    var ty = 0;\r\n    var ta = 0;\r\n    var iterStep = 0.01;\r\n    var PI2 = Math.PI * 2;\r\n\r\n    var cmd;\r\n\r\n    var path = [];\r\n    var pathIndex = 0;\r\n    var pathOpen = false;\r\n    var lastPath = null;\r\n\r\n    var getTint = Utils.getTintAppendFloatAlphaAndSwap;\r\n\r\n    for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++)\r\n    {\r\n        cmd = commands[cmdIndex];\r\n\r\n        switch (cmd)\r\n        {\r\n            case Commands.BEGIN_PATH:\r\n\r\n                path.length = 0;\r\n                lastPath = null;\r\n                pathOpen = true;\r\n                break;\r\n\r\n            case Commands.CLOSE_PATH:\r\n\r\n                pathOpen = false;\r\n\r\n                if (lastPath && lastPath.points.length)\r\n                {\r\n                    lastPath.points.push(lastPath.points[0]);\r\n                }\r\n                break;\r\n\r\n            case Commands.FILL_PATH:\r\n                for (pathIndex = 0; pathIndex < path.length; pathIndex++)\r\n                {\r\n                    pipeline.batchFillPath(\r\n                        path[pathIndex].points,\r\n                        currentMatrix,\r\n                        camMatrix\r\n                    );\r\n                }\r\n                break;\r\n\r\n            case Commands.STROKE_PATH:\r\n                for (pathIndex = 0; pathIndex < path.length; pathIndex++)\r\n                {\r\n                    pipeline.batchStrokePath(\r\n                        path[pathIndex].points,\r\n                        lineWidth,\r\n                        pathOpen,\r\n                        currentMatrix,\r\n                        camMatrix\r\n                    );\r\n                }\r\n                break;\r\n\r\n            case Commands.LINE_STYLE:\r\n                lineWidth = commands[++cmdIndex];\r\n                var strokeColor = commands[++cmdIndex];\r\n                var strokeAlpha = commands[++cmdIndex] * alpha;\r\n                var strokeTintColor = getTint(strokeColor, strokeAlpha);\r\n                strokeTint.TL = strokeTintColor;\r\n                strokeTint.TR = strokeTintColor;\r\n                strokeTint.BL = strokeTintColor;\r\n                strokeTint.BR = strokeTintColor;\r\n                break;\r\n\r\n            case Commands.FILL_STYLE:\r\n                var fillColor = commands[++cmdIndex];\r\n                var fillAlpha = commands[++cmdIndex] * alpha;\r\n                var fillTintColor = getTint(fillColor, fillAlpha);\r\n                fillTint.TL = fillTintColor;\r\n                fillTint.TR = fillTintColor;\r\n                fillTint.BL = fillTintColor;\r\n                fillTint.BR = fillTintColor;\r\n                break;\r\n\r\n            case Commands.GRADIENT_FILL_STYLE:\r\n                var gradientFillAlpha = commands[++cmdIndex] * alpha;\r\n                fillTint.TL = getTint(commands[++cmdIndex], gradientFillAlpha);\r\n                fillTint.TR = getTint(commands[++cmdIndex], gradientFillAlpha);\r\n                fillTint.BL = getTint(commands[++cmdIndex], gradientFillAlpha);\r\n                fillTint.BR = getTint(commands[++cmdIndex], gradientFillAlpha);\r\n                break;\r\n\r\n            case Commands.GRADIENT_LINE_STYLE:\r\n                lineWidth = commands[++cmdIndex];\r\n                var gradientLineAlpha = commands[++cmdIndex] * alpha;\r\n                strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                break;\r\n\r\n            case Commands.ARC:\r\n                var iteration = 0;\r\n                var x = commands[++cmdIndex];\r\n                var y = commands[++cmdIndex];\r\n                var radius = commands[++cmdIndex];\r\n                var startAngle = commands[++cmdIndex];\r\n                var endAngle = commands[++cmdIndex];\r\n                var anticlockwise = commands[++cmdIndex];\r\n                var overshoot = commands[++cmdIndex];\r\n\r\n                endAngle -= startAngle;\r\n\r\n                if (anticlockwise)\r\n                {\r\n                    if (endAngle < -PI2)\r\n                    {\r\n                        endAngle = -PI2;\r\n                    }\r\n                    else if (endAngle > 0)\r\n                    {\r\n                        endAngle = -PI2 + endAngle % PI2;\r\n                    }\r\n                }\r\n                else if (endAngle > PI2)\r\n                {\r\n                    endAngle = PI2;\r\n                }\r\n                else if (endAngle < 0)\r\n                {\r\n                    endAngle = PI2 + endAngle % PI2;\r\n                }\r\n\r\n                if (lastPath === null)\r\n                {\r\n                    lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);\r\n                    path.push(lastPath);\r\n                    iteration += iterStep;\r\n                }\r\n\r\n                while (iteration < 1 + overshoot)\r\n                {\r\n                    ta = endAngle * iteration + startAngle;\r\n                    tx = x + Math.cos(ta) * radius;\r\n                    ty = y + Math.sin(ta) * radius;\r\n\r\n                    lastPath.points.push(new Point(tx, ty, lineWidth));\r\n\r\n                    iteration += iterStep;\r\n                }\r\n\r\n                ta = endAngle + startAngle;\r\n                tx = x + Math.cos(ta) * radius;\r\n                ty = y + Math.sin(ta) * radius;\r\n\r\n                lastPath.points.push(new Point(tx, ty, lineWidth));\r\n\r\n                break;\r\n\r\n            case Commands.FILL_RECT:\r\n                pipeline.batchFillRect(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    currentMatrix,\r\n                    camMatrix\r\n                );\r\n                break;\r\n\r\n            case Commands.FILL_TRIANGLE:\r\n                pipeline.batchFillTriangle(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    currentMatrix,\r\n                    camMatrix\r\n                );\r\n                break;\r\n\r\n            case Commands.STROKE_TRIANGLE:\r\n                pipeline.batchStrokeTriangle(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    lineWidth,\r\n                    currentMatrix,\r\n                    camMatrix\r\n                );\r\n                break;\r\n\r\n            case Commands.LINE_TO:\r\n                if (lastPath !== null)\r\n                {\r\n                    lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));\r\n                }\r\n                else\r\n                {\r\n                    lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\r\n                    path.push(lastPath);\r\n                }\r\n                break;\r\n\r\n            case Commands.MOVE_TO:\r\n                lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\r\n                path.push(lastPath);\r\n                break;\r\n\r\n            case Commands.SAVE:\r\n                matrixStack.push(currentMatrix.copyToArray());\r\n                break;\r\n\r\n            case Commands.RESTORE:\r\n                currentMatrix.copyFromArray(matrixStack.pop());\r\n                break;\r\n\r\n            case Commands.TRANSLATE:\r\n                x = commands[++cmdIndex];\r\n                y = commands[++cmdIndex];\r\n                currentMatrix.translate(x, y);\r\n                break;\r\n\r\n            case Commands.SCALE:\r\n                x = commands[++cmdIndex];\r\n                y = commands[++cmdIndex];\r\n                currentMatrix.scale(x, y);\r\n                break;\r\n\r\n            case Commands.ROTATE:\r\n                currentMatrix.rotate(commands[++cmdIndex]);\r\n                break;\r\n\r\n            case Commands.SET_TEXTURE:\r\n                var frame = commands[++cmdIndex];\r\n                var mode = commands[++cmdIndex];\r\n\r\n                pipeline.currentFrame = frame;\r\n                renderer.setTexture2D(frame.glTexture, 0);\r\n                pipeline.tintEffect = mode;\r\n                break;\r\n\r\n            case Commands.CLEAR_TEXTURE:\r\n                pipeline.currentFrame = renderer.blankTexture;\r\n                renderer.setTexture2D(renderer.blankTexture.glTexture, 0);\r\n                pipeline.tintEffect = 2;\r\n                break;\r\n\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = GraphicsWebGLRenderer;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Commands","Utils","Point","x","y","width","Path","points","pointsLength","matrixStack","GraphicsWebGLRenderer","renderer","src","interpolationPercentage","camera","parentMatrix","commandBuffer","length","pipeline","camMatrix","_tempMatrix1","graphicsMatrix","_tempMatrix2","currentMatrix","_tempMatrix4","setPipeline","loadIdentity","applyITRS","rotation","scaleX","scaleY","copyFrom","matrix","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","commands","alpha","lineWidth","fillTint","strokeTint","tx","ty","PI2","Math","PI","cmd","path","pathOpen","lastPath","getTint","getTintAppendFloatAlphaAndSwap","cmdIndex","BEGIN_PATH","CLOSE_PATH","push","FILL_PATH","pathIndex","batchFillPath","STROKE_PATH","batchStrokePath","LINE_STYLE","strokeColor","strokeAlpha","strokeTintColor","TL","TR","BL","BR","FILL_STYLE","fillColor","fillAlpha","fillTintColor","GRADIENT_FILL_STYLE","gradientFillAlpha","GRADIENT_LINE_STYLE","gradientLineAlpha","ARC","iteration","radius","startAngle","endAngle","anticlockwise","overshoot","cos","sin","iterStep","ta","FILL_RECT","batchFillRect","FILL_TRIANGLE","batchFillTriangle","STROKE_TRIANGLE","batchStrokeTriangle","LINE_TO","MOVE_TO","SAVE","copyToArray","RESTORE","copyFromArray","pop","TRANSLATE","translate","SCALE","scale","ROTATE","rotate","SET_TEXTURE","frame","mode","currentFrame","setTexture2D","glTexture","tintEffect","CLEAR_TEXTURE","blankTexture"]
}
