shadow$provide.module$node_modules$Phaser$src$renderer$webgl$shaders$ForwardDiffuse_frag=function(global,require,module,exports){module.exports="#define SHADER_NAME PHASER_FORWARD_DIFFUSE_FS\n\nprecision mediump float;\n\nstruct Light\n{\n    vec2 position;\n    vec3 color;\n    float intensity;\n    float radius;\n};\n\nconst int kMaxLights \x3d %LIGHT_COUNT%;\n\nuniform vec4 uCamera; /* x, y, rotation, zoom */\nuniform vec2 uResolution;\nuniform sampler2D uMainSampler;\nuniform sampler2D uNormSampler;\nuniform vec3 uAmbientLightColor;\nuniform Light uLights[kMaxLights];\n\nvarying vec2 outTexCoord;\nvarying vec4 outTint;\n\nvoid main()\n{\n    vec3 finalColor \x3d vec3(0.0, 0.0, 0.0);\n    vec4 color \x3d texture2D(uMainSampler, outTexCoord) * vec4(outTint.rgb * outTint.a, outTint.a);\n    vec3 normalMap \x3d texture2D(uNormSampler, outTexCoord).rgb;\n    vec3 normal \x3d normalize(vec3(normalMap * 2.0 - 1.0));\n    vec2 res \x3d vec2(min(uResolution.x, uResolution.y)) * uCamera.w;\n\n    for (int index \x3d 0; index \x3c kMaxLights; ++index)\n    {\n        Light light \x3d uLights[index];\n        vec3 lightDir \x3d vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);\n        vec3 lightNormal \x3d normalize(lightDir);\n        float distToSurf \x3d length(lightDir) * uCamera.w;\n        float diffuseFactor \x3d max(dot(normal, lightNormal), 0.0);\n        float radius \x3d (light.radius / res.x * uCamera.w) * uCamera.w;\n        float attenuation \x3d clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);\n        vec3 diffuse \x3d light.color * diffuseFactor;\n        finalColor +\x3d (attenuation * diffuse) * light.intensity;\n    }\n\n    vec4 colorOutput \x3d vec4(uAmbientLightColor + finalColor, 1.0);\n    gl_FragColor \x3d color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);\n\n}\n"}
//# sourceMappingURL=module$node_modules$Phaser$src$renderer$webgl$shaders$ForwardDiffuse_frag.js.map
