{
"version":3,
"file":"module$node_modules$Phaser$src$scene$Systems.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/Phaser/src/scene/Systems.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$scene$Systems\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar DefaultPlugins = require('../plugins/DefaultPlugins');\r\nvar GetPhysicsPlugins = require('./GetPhysicsPlugins');\r\nvar GetScenePlugins = require('./GetScenePlugins');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Settings = require('./Settings');\r\n\r\n/**\r\n * @classdesc\r\n * The Scene Systems class.\r\n *\r\n * This class is available from within a Scene under the property `sys`.\r\n * It is responsible for managing all of the plugins a Scene has running, including the display list, and\r\n * handling the update step and renderer. It also contains references to global systems belonging to Game.\r\n *\r\n * @class Systems\r\n * @memberOf Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that owns this Systems instance.\r\n * @param {(string|Phaser.Scenes.Settings.Config)} config - Scene specific configuration settings.\r\n */\r\nvar Systems = new Class({\r\n\r\n    initialize:\r\n\r\n    function Systems (scene, config)\r\n    {\r\n        /**\r\n         * A reference to the Scene that these Systems belong to.\r\n         *\r\n         * @name Phaser.Scenes.Systems#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Phaser Game instance.\r\n         *\r\n         * @name Phaser.Scenes.Systems#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game;\r\n\r\n        if (typeof PLUGIN_FBINSTANT)\r\n        {\r\n            /**\r\n             * The Facebook Instant Games Plugin.\r\n             *\r\n             * @name Phaser.Scenes.Systems#facebook\r\n             * @type {any}\r\n             * @since 3.12.0\r\n             */\r\n            this.facebook;\r\n        }\r\n\r\n        /**\r\n         * The Scene Configuration object, as passed in when creating the Scene.\r\n         *\r\n         * @name Phaser.Scenes.Systems#config\r\n         * @type {(string|Phaser.Scenes.Settings.Config)}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = config;\r\n\r\n        /**\r\n         * The Scene Settings. This is the parsed output based on the Scene configuration.\r\n         *\r\n         * @name Phaser.Scenes.Systems#settings\r\n         * @type {Phaser.Scenes.Settings.Object}\r\n         * @since 3.0.0\r\n         */\r\n        this.settings = Settings.create(config);\r\n\r\n        /**\r\n         * A handy reference to the Scene canvas / context.\r\n         *\r\n         * @name Phaser.Scenes.Systems#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas;\r\n\r\n        /**\r\n         * A reference to the Canvas Rendering Context being used by the renderer.\r\n         *\r\n         * @name Phaser.Scenes.Systems#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.context;\r\n\r\n        //  Global Systems - these are single-instance global managers that belong to Game\r\n\r\n        /**\r\n         * A reference to the global Animations Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.anims` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#anims\r\n         * @type {Phaser.Animations.AnimationManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.anims;\r\n\r\n        /**\r\n         * A reference to the global Cache. The Cache stores all files bought in to Phaser via\r\n         * the Loader, with the exception of images. Images are stored in the Texture Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.cache` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#cache\r\n         * @type {Phaser.Cache.CacheManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.cache;\r\n\r\n        /**\r\n         * A reference to the global Plugins Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.plugins` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#plugins\r\n         * @type {Phaser.Plugins.PluginManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.plugins;\r\n\r\n        /**\r\n         * A reference to the global registry. This is a game-wide instance of the Data Manager, allowing\r\n         * you to exchange data between Scenes via a universal and shared point.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.registry` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#registry\r\n         * @type {Phaser.Data.DataManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.registry;\r\n\r\n        /**\r\n         * A reference to the global Sound Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.sound` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#sound\r\n         * @type {Phaser.Sound.BaseSoundManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.sound;\r\n\r\n        /**\r\n         * A reference to the global Texture Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.textures` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#textures\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.textures;\r\n\r\n        //  Core Plugins - these are non-optional Scene plugins, needed by lots of the other systems\r\n\r\n        /**\r\n         * A reference to the Scene's Game Object Factory.\r\n         * \r\n         * Use this to quickly and easily create new Game Object's.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.add` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#add\r\n         * @type {Phaser.GameObjects.GameObjectFactory}\r\n         * @since 3.0.0\r\n         */\r\n        this.add;\r\n\r\n        /**\r\n         * A reference to the Scene's Camera Manager.\r\n         * \r\n         * Use this to manipulate and create Cameras for this specific Scene.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.cameras` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#cameras\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.cameras;\r\n\r\n        /**\r\n         * A reference to the Scene's Display List.\r\n         * \r\n         * Use this to organize the children contained in the display list.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.children` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList;\r\n\r\n        /**\r\n         * A reference to the Scene's Event Manager.\r\n         * \r\n         * Use this to listen for Scene specific events, such as `pause` and `shutdown`.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.events` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events;\r\n\r\n        /**\r\n         * A reference to the Scene's Game Object Creator.\r\n         * \r\n         * Use this to quickly and easily create new Game Object's. The difference between this and the\r\n         * Game Object Factory, is that the Creator just creates and returns Game Object instances, it\r\n         * doesn't then add them to the Display List or Update List.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.make` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#make\r\n         * @type {Phaser.GameObjects.GameObjectCreator}\r\n         * @since 3.0.0\r\n         */\r\n        this.make;\r\n\r\n        /**\r\n         * A reference to the Scene Manager Plugin.\r\n         * \r\n         * Use this to manipulate both this and other Scene's in your game, for example to launch a parallel Scene,\r\n         * or pause or resume a Scene, or switch from this Scene to another.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.scene` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#scenePlugin\r\n         * @type {Phaser.Scenes.ScenePlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.scenePlugin;\r\n\r\n        /**\r\n         * A reference to the Scene's Update List.\r\n         * \r\n         * Use this to organize the children contained in the update list.\r\n         * \r\n         * The Update List is responsible for managing children that need their `preUpdate` methods called,\r\n         * in order to process so internal components, such as Sprites with Animations.\r\n         * \r\n         * In the default set-up there is no reference to this from within the Scene itself.\r\n         *\r\n         * @name Phaser.Scenes.Systems#updateList\r\n         * @type {Phaser.GameObjects.UpdateList}\r\n         * @since 3.0.0\r\n         */\r\n        this.updateList;\r\n\r\n        /**\r\n         * The Scene Update function.\r\n         *\r\n         * This starts out as NOOP during init, preload and create, and at the end of create\r\n         * it swaps to be whatever the Scene.update function is.\r\n         *\r\n         * @name Phaser.Scenes.Systems#sceneUpdate\r\n         * @type {function}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.sceneUpdate = NOOP;\r\n    },\r\n\r\n    /**\r\n     * This method is called only once by the Scene Manager when the Scene is instantiated.\r\n     * It is responsible for setting up all of the Scene plugins and references.\r\n     * It should never be called directly.\r\n     *\r\n     * @method Phaser.Scenes.Systems#init\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Game} game - A reference to the Phaser Game instance.\r\n     */\r\n    init: function (game)\r\n    {\r\n        this.settings.status = CONST.INIT;\r\n\r\n        //  This will get replaced by the SceneManager with the actual update function, if it exists, once create is over.\r\n        this.sceneUpdate = NOOP;\r\n\r\n        this.game = game;\r\n\r\n        this.canvas = game.canvas;\r\n        this.context = game.context;\r\n\r\n        var pluginManager = game.plugins;\r\n\r\n        this.plugins = pluginManager;\r\n\r\n        pluginManager.addToScene(this, DefaultPlugins.Global, [ DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this) ]);\r\n\r\n        this.events.emit('boot', this);\r\n\r\n        this.settings.isBooted = true;\r\n    },\r\n\r\n    /**\r\n     * Called by a plugin, it tells the System to install the plugin locally.\r\n     *\r\n     * @method Phaser.Scenes.Systems#install\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} plugin - An array of plugins to install into this Scene.\r\n     */\r\n    install: function (plugin)\r\n    {\r\n        if (!Array.isArray(plugin))\r\n        {\r\n            plugin = [ plugin ];\r\n        }\r\n\r\n        this.plugins.installLocal(this, plugin);\r\n    },\r\n\r\n    /**\r\n     * A single game step. Called automatically by the Scene Manager as a result of a Request Animation\r\n     * Frame or Set Timeout call to the main Game instance.\r\n     *\r\n     * @method Phaser.Scenes.Systems#step\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n     * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n     */\r\n    step: function (time, delta)\r\n    {\r\n        this.events.emit('preupdate', time, delta);\r\n\r\n        this.events.emit('update', time, delta);\r\n\r\n        this.sceneUpdate.call(this.scene, time, delta);\r\n\r\n        this.events.emit('postupdate', time, delta);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by the Scene Manager.\r\n     * Instructs the Scene to render itself via its Camera Manager to the renderer given.\r\n     *\r\n     * @method Phaser.Scenes.Systems#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that invoked the render call.\r\n     */\r\n    render: function (renderer)\r\n    {\r\n        var displayList = this.displayList;\r\n\r\n        displayList.depthSort();\r\n\r\n        this.cameras.render(renderer, displayList);\r\n\r\n        this.events.emit('render', renderer);\r\n    },\r\n\r\n    /**\r\n     * Force a sort of the display list on the next render.\r\n     *\r\n     * @method Phaser.Scenes.Systems#queueDepthSort\r\n     * @since 3.0.0\r\n     */\r\n    queueDepthSort: function ()\r\n    {\r\n        this.displayList.queueDepthSort();\r\n    },\r\n\r\n    /**\r\n     * Immediately sorts the display list if the flag is set.\r\n     *\r\n     * @method Phaser.Scenes.Systems#depthSort\r\n     * @since 3.0.0\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        this.displayList.depthSort();\r\n    },\r\n\r\n    /**\r\n     * Pause this Scene.\r\n     * A paused Scene still renders, it just doesn't run ANY of its update handlers or systems.\r\n     *\r\n     * @method Phaser.Scenes.Systems#pause\r\n     * @since 3.0.0\r\n     * \r\n     * @param {object} [data] - A data object that will be passed in the 'pause' event.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    pause: function (data)\r\n    {\r\n        if (this.settings.active)\r\n        {\r\n            this.settings.status = CONST.PAUSED;\r\n\r\n            this.settings.active = false;\r\n\r\n            this.events.emit('pause', this, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resume this Scene from a paused state.\r\n     *\r\n     * @method Phaser.Scenes.Systems#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [data] - A data object that will be passed in the 'resume' event.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    resume: function (data)\r\n    {\r\n        if (!this.settings.active)\r\n        {\r\n            this.settings.status = CONST.RUNNING;\r\n\r\n            this.settings.active = true;\r\n\r\n            this.events.emit('resume', this, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Send this Scene to sleep.\r\n     *\r\n     * A sleeping Scene doesn't run it's update step or render anything, but it also isn't shut down\r\n     * or have any of its systems or children removed, meaning it can be re-activated at any point and\r\n     * will carry on from where it left off. It also keeps everything in memory and events and callbacks\r\n     * from other Scenes may still invoke changes within it, so be careful what is left active.\r\n     *\r\n     * @method Phaser.Scenes.Systems#sleep\r\n     * @since 3.0.0\r\n     * \r\n     * @param {object} [data] - A data object that will be passed in the 'sleep' event.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    sleep: function (data)\r\n    {\r\n        this.settings.status = CONST.SLEEPING;\r\n\r\n        this.settings.active = false;\r\n        this.settings.visible = false;\r\n\r\n        this.events.emit('sleep', this, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Wake-up this Scene if it was previously asleep.\r\n     *\r\n     * @method Phaser.Scenes.Systems#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [data] - A data object that will be passed in the 'wake' event.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    wake: function (data)\r\n    {\r\n        var settings = this.settings;\r\n\r\n        settings.status = CONST.RUNNING;\r\n\r\n        settings.active = true;\r\n        settings.visible = true;\r\n\r\n        this.events.emit('wake', this, data);\r\n\r\n        if (settings.isTransition)\r\n        {\r\n            this.events.emit('transitionwake', settings.transitionFrom, settings.transitionDuration);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Is this Scene sleeping?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is asleep, otherwise `false`.\r\n     */\r\n    isSleeping: function ()\r\n    {\r\n        return (this.settings.status === CONST.SLEEPING);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene active?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is active, otherwise `false`.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.settings.status === CONST.RUNNING);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene paused?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isPaused\r\n     * @since 3.13.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is paused, otherwise `false`.\r\n     */\r\n    isPaused: function ()\r\n    {\r\n        return (this.settings.status === CONST.PAUSED);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene currently transitioning out to, or in from another Scene?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isTransitioning\r\n     * @since 3.5.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is currently transitioning, otherwise `false`.\r\n     */\r\n    isTransitioning: function ()\r\n    {\r\n        return (this.settings.isTransition || this.scenePlugin._target !== null);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene currently transitioning out from itself to another Scene?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isTransitionOut\r\n     * @since 3.5.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is in transition to another Scene, otherwise `false`.\r\n     */\r\n    isTransitionOut: function ()\r\n    {\r\n        return (this.scenePlugin._target !== null && this.scenePlugin._duration > 0);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene currently transitioning in from another Scene?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isTransitionIn\r\n     * @since 3.5.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is transitioning in from another Scene, otherwise `false`.\r\n     */\r\n    isTransitionIn: function ()\r\n    {\r\n        return (this.settings.isTransition);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene visible and rendering?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is visible, otherwise `false`.\r\n     */\r\n    isVisible: function ()\r\n    {\r\n        return this.settings.visible;\r\n    },\r\n\r\n    /**\r\n     * Sets the visible state of this Scene.\r\n     * An invisible Scene will not render, but will still process updates.\r\n     *\r\n     * @method Phaser.Scenes.Systems#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to render this Scene, otherwise `false`.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    setVisible: function (value)\r\n    {\r\n        this.settings.visible = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the active state of this Scene.\r\n     * \r\n     * An active Scene will run its core update loop.\r\n     *\r\n     * @method Phaser.Scenes.Systems#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - If `true` the Scene will be resumed, if previously paused. If `false` it will be paused.\r\n     * @param {object} [data] - A data object that will be passed in the 'resume' or 'pause' events.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    setActive: function (value, data)\r\n    {\r\n        if (value)\r\n        {\r\n            return this.resume(data);\r\n        }\r\n        else\r\n        {\r\n            return this.pause(data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Start this Scene running and rendering.\r\n     * Called automatically by the SceneManager.\r\n     *\r\n     * @method Phaser.Scenes.Systems#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} data - Optional data object that may have been passed to this Scene from another.\r\n     */\r\n    start: function (data)\r\n    {\r\n        if (data)\r\n        {\r\n            this.settings.data = data;\r\n        }\r\n\r\n        this.settings.status = CONST.START;\r\n\r\n        this.settings.active = true;\r\n        this.settings.visible = true;\r\n\r\n        //  For plugins to listen out for\r\n        this.events.emit('start', this);\r\n\r\n        //  For user-land code to listen out for\r\n        this.events.emit('ready', this, data);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by the SceneManager if the Game resizes.\r\n     * Dispatches an event you can respond to in your game code.\r\n     *\r\n     * @method Phaser.Scenes.Systems#resize\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        this.events.emit('resize', width, height);\r\n    },\r\n\r\n    /**\r\n     * Shutdown this Scene and send a shutdown event to all of its systems.\r\n     * A Scene that has been shutdown will not run its update loop or render, but it does\r\n     * not destroy any of its plugins or references. It is put into hibernation for later use.\r\n     * If you don't ever plan to use this Scene again, then it should be destroyed instead\r\n     * to free-up resources.\r\n     *\r\n     * @method Phaser.Scenes.Systems#shutdown\r\n     * @since 3.0.0\r\n     * \r\n     * @param {object} [data] - A data object that will be passed in the 'shutdown' event.\r\n     */\r\n    shutdown: function (data)\r\n    {\r\n        this.events.off('transitioninit');\r\n        this.events.off('transitionstart');\r\n        this.events.off('transitioncomplete');\r\n        this.events.off('transitionout');\r\n\r\n        this.settings.status = CONST.SHUTDOWN;\r\n\r\n        this.settings.active = false;\r\n        this.settings.visible = false;\r\n\r\n        this.events.emit('shutdown', this, data);\r\n    },\r\n\r\n    /**\r\n     * Destroy this Scene and send a destroy event all of its systems.\r\n     * A destroyed Scene cannot be restarted.\r\n     * You should not call this directly, instead use `SceneManager.remove`.\r\n     *\r\n     * @method Phaser.Scenes.Systems#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.settings.status = CONST.DESTROYED;\r\n\r\n        this.settings.active = false;\r\n        this.settings.visible = false;\r\n\r\n        this.events.emit('destroy', this);\r\n\r\n        this.events.removeAllListeners();\r\n\r\n        var props = [ 'scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList' ];\r\n\r\n        for (var i = 0; i < props.length; i++)\r\n        {\r\n            this[props[i]] = null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Systems;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Class","CONST","DefaultPlugins","GetPhysicsPlugins","GetScenePlugins","NOOP","Settings","Systems","initialize","scene","config","settings","create","sceneUpdate","init","game","status","INIT","canvas","context","plugins","pluginManager","addToScene","Global","CoreScene","events","emit","isBooted","install","plugin","Array","isArray","installLocal","step","time","delta","call","render","renderer","displayList","depthSort","cameras","queueDepthSort","pause","data","active","PAUSED","resume","RUNNING","sleep","SLEEPING","visible","wake","isTransition","transitionFrom","transitionDuration","isSleeping","isActive","isPaused","isTransitioning","scenePlugin","_target","isTransitionOut","_duration","isTransitionIn","isVisible","setVisible","value","setActive","start","START","resize","width","height","shutdown","off","SHUTDOWN","destroy","DESTROYED","removeAllListeners","props","i","length"]
}
