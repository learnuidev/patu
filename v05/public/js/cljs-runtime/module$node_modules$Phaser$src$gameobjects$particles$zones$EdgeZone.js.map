{
"version":3,
"file":"module$node_modules$Phaser$src$gameobjects$particles$zones$EdgeZone.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,oEAAA,CAAwF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAgD5HC,MAAAA,CAAW,KAzCHH,OAAAI,CAAQ,4CAARA,CAyCG,EAAU,CAErBC,WAEAF,QAAkB,CAACG,MAAD,CAASC,QAAT,CAAmBC,QAAnB,CAA6BC,IAA7B,CAAmCC,QAAnC,CAClB,CACiBC,IAAAA,EAAb,GAAIF,IAAJ,GAA0BA,IAA1B,CAAiC,CAAA,CAAjC,CACiBE,KAAAA,EAAjB,GAAID,QAAJ,GAA8BA,QAA9B,CAAyC,CAAA,CAAzC,CASA,KAAAJ,OAAA,CAAcA,MAUd,KAAAM,OAAA,CAAc,EASd,KAAAL,SAAA,CAAgBA,QAShB,KAAAC,SAAA,CAAgBA,QAShB,KAAAC,KAAA,CAAYA,IAUZ,KAAAI,QAAA,CAAe,EASf,KAAAH,SAAA,CAAgBA,QAwBhB,KAAAI,WAAA,CAbA,IAAAC,QAaA,CAbe,CAef,KAAAC,aAAA,EA7FJ,CALqB,CAgHrBA,aAAcA,QAAS,EACvB,CACI,IAAAJ,OAAA;AAAc,IAAAN,OAAAW,UAAA,CAAsB,IAAAV,SAAtB,CAAqC,IAAAC,SAArC,CAGd,IAAI,IAAAE,SAAJ,CACA,CACI,IAAIQ,EAAI,IAAAN,OAAA,CAAY,CAAZ,CAAR,CACIO,EAAI,IAAAP,OAAA,CAAY,IAAAA,OAAAQ,OAAZ,CAAiC,CAAjC,CAEJF,EAAAG,EAAJ,GAAYF,CAAAE,EAAZ,EAAmBH,CAAAI,EAAnB,GAA2BH,CAAAG,EAA3B,EAEI,IAAAV,OAAAW,IAAA,EANR,CAUIC,CAAAA,CAAY,IAAAT,QAEhB,KAAAA,QAAA,CAAe,IAAAH,OAAAQ,OAGX,KAAAL,QAAJ,CAAmBS,CAAnB,EAAgC,IAAAX,QAAhC,CAA+C,IAAAE,QAA/C,GAEI,IAAAF,QAFJ,CAEmB,IAAAE,QAFnB,CAEkC,CAFlC,CAKA,OAAO,KAzBX,CAjHqB,CAuJrBU,aAAcA,QAAS,CAACnB,MAAD,CACvB,CACI,IAAAA,OAAA,CAAcA,MAEd,OAAO,KAAAU,aAAA,EAHX,CAxJqB,CAsKrBU,SAAUA,QAAS,CAACC,QAAD,CACnB,CAC4B,CAAxB,GAAI,IAAAb,WAAJ,EAEI,IAAAD,QAAA,EAEA,CAAI,IAAAA,QAAJ,EAAoB,IAAAE,QAApB,GAEQ,IAAAN,KAAJ,EAEI,IAAAK,WACA,CADkB,CAClB,CAAA,IAAAD,QAAA;AAAe,IAAAE,QAAf,CAA8B,CAHlC,EAOI,IAAAF,QAPJ,CAOmB,CATvB,CAJJ,GAmBI,IAAAA,QAAA,EAEA,CAAqB,EAArB,GAAI,IAAAA,QAAJ,GAKQ,IAAAA,QALR,CAEQ,IAAAJ,KAAJ,CAEI,IAAAK,WAFJ,CAEsB,CAFtB,CAOmB,IAAAC,QAPnB,CAOkC,CATtC,CArBJ,CAmCA,KAAIa,MAAQ,IAAAhB,OAAA,CAAY,IAAAC,QAAZ,CAERe,MAAJ,GAEID,QAAAN,EACA,CADaO,KAAAP,EACb,CAAAM,QAAAL,EAAA,CAAaM,KAAAN,EAHjB,CAtCJ,CAvKqB,CAAV,CAsNfrB,OAAAC,QAAA,CAAiBC,MAtQ+G;",
"sources":["node_modules/Phaser/src/gameobjects/particles/zones/EdgeZone.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$gameobjects$particles$zones$EdgeZone\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\n\r\n/**\r\n * @callback EdgeZoneSourceCallback\r\n *\r\n * @param {integer} quantity - The number of particles to place on the source edge. If 0, `stepRate` should be used instead.\r\n * @param {number} [stepRate] - The distance between each particle. When set, `quantity` is implied and should be set to `0`.\r\n *\r\n * @return {Phaser.Geom.Point[]} - The points placed on the source edge.\r\n */\r\n\r\n/**\r\n * @typedef {object} EdgeZoneSource\r\n *\r\n * @property {EdgeZoneSourceCallback} getPoints - A function placing points on the source's edge or edges.\r\n *\r\n * @see Phaser.Curves.Curve\r\n * @see Phaser.Curves.Path\r\n * @see Phaser.Geom.Circle\r\n * @see Phaser.Geom.Ellipse\r\n * @see Phaser.Geom.Line\r\n * @see Phaser.Geom.Polygon\r\n * @see Phaser.Geom.Rectangle\r\n * @see Phaser.Geom.Triangle\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A zone that places particles on a shape's edges.\r\n *\r\n * @class EdgeZone\r\n * @memberOf Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n * @param {integer} quantity - The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n * @param {number} stepRate - The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n * @param {boolean} [yoyo=false] - Whether particles are placed from start to end and then end to start.\r\n * @param {boolean} [seamless=true] - Whether one endpoint will be removed if it's identical to the other.\r\n */\r\nvar EdgeZone = new Class({\r\n\r\n    initialize:\r\n\r\n    function EdgeZone (source, quantity, stepRate, yoyo, seamless)\r\n    {\r\n        if (yoyo === undefined) { yoyo = false; }\r\n        if (seamless === undefined) { seamless = true; }\r\n\r\n        /**\r\n         * An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#source\r\n         * @type {EdgeZoneSource|RandomZoneSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = source;\r\n\r\n        /**\r\n         * The points placed on the source edge.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#points\r\n         * @type {Phaser.Geom.Point[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.points = [];\r\n\r\n        /**\r\n         * The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#quantity\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.quantity = quantity;\r\n\r\n        /**\r\n         * The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#stepRate\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.stepRate = stepRate;\r\n\r\n        /**\r\n         * Whether particles are placed from start to end and then end to start.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#yoyo\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.yoyo = yoyo;\r\n\r\n        /**\r\n         * The counter used for iterating the EdgeZone's points.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#counter\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.counter = -1;\r\n\r\n        /**\r\n         * Whether one endpoint will be removed if it's identical to the other.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#seamless\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.seamless = seamless;\r\n\r\n        /**\r\n         * An internal count of the points belonging to this EdgeZone.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_length\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._length = 0;\r\n\r\n        /**\r\n         * An internal value used to keep track of the current iteration direction for the EdgeZone's points.\r\n         *\r\n         * 0 = forwards, 1 = backwards\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_direction\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._direction = 0;\r\n\r\n        this.updateSource();\r\n    },\r\n\r\n    /**\r\n     * Update the {@link Phaser.GameObjects.Particles.Zones.EdgeZone#points} from the EdgeZone's\r\n     * {@link Phaser.GameObjects.Particles.Zones.EdgeZone#source}.\r\n     *\r\n     * Also updates internal properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#updateSource\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Zones.EdgeZone} This Edge Zone.\r\n     */\r\n    updateSource: function ()\r\n    {\r\n        this.points = this.source.getPoints(this.quantity, this.stepRate);\r\n\r\n        //  Remove ends?\r\n        if (this.seamless)\r\n        {\r\n            var a = this.points[0];\r\n            var b = this.points[this.points.length - 1];\r\n\r\n            if (a.x === b.x && a.y === b.y)\r\n            {\r\n                this.points.pop();\r\n            }\r\n        }\r\n\r\n        var oldLength = this._length;\r\n\r\n        this._length = this.points.length;\r\n\r\n        //  Adjust counter if we now have less points than before\r\n        if (this._length < oldLength && this.counter > this._length)\r\n        {\r\n            this.counter = this._length - 1;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Change the EdgeZone's source.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#changeSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Zones.EdgeZone} This Edge Zone.\r\n     */\r\n    changeSource: function (source)\r\n    {\r\n        this.source = source;\r\n\r\n        return this.updateSource();\r\n    },\r\n\r\n    /**\r\n     * Get the next point in the Zone and set its coordinates on the given Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle.\r\n     */\r\n    getPoint: function (particle)\r\n    {\r\n        if (this._direction === 0)\r\n        {\r\n            this.counter++;\r\n\r\n            if (this.counter >= this._length)\r\n            {\r\n                if (this.yoyo)\r\n                {\r\n                    this._direction = 1;\r\n                    this.counter = this._length - 1;\r\n                }\r\n                else\r\n                {\r\n                    this.counter = 0;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.counter--;\r\n\r\n            if (this.counter === -1)\r\n            {\r\n                if (this.yoyo)\r\n                {\r\n                    this._direction = 0;\r\n                    this.counter = 0;\r\n                }\r\n                else\r\n                {\r\n                    this.counter = this._length - 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        var point = this.points[this.counter];\r\n\r\n        if (point)\r\n        {\r\n            particle.x = point.x;\r\n            particle.y = point.y;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = EdgeZone;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","EdgeZone","Class","initialize","source","quantity","stepRate","yoyo","seamless","undefined","points","counter","_direction","_length","updateSource","getPoints","a","b","length","x","y","pop","oldLength","changeSource","getPoint","particle","point"]
}
