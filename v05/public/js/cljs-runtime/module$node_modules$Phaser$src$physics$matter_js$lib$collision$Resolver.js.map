{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$lib$collision$Resolver.js",
"lineCount":15,
"mappings":"AAAAA,cAAA,wEAAA,CAA4F,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAOpI,IAAIC,SAAW,EAEfF,OAAAC,QAAA,CAAiBC,QAEjB,KAAIC,SAAWJ,OAAA,CAAQ,wEAAR,CAAf,CACIK,OAASL,OAAA,CAAQ,sEAAR,CADb,CAEIM,OAASN,OAAA,CAAQ,kEAAR,CAFb,CAGIO,OAASP,OAAA,CAAQ,sEAAR,CAEZ;SAAQ,EAAG,CAERG,QAAAK,eAAA,CAA0B,CAC1BL,SAAAM,sBAAA,CAAiC,CACjCN,SAAAO,gBAAA,CAA2B,EAC3BP,SAAAQ,iBAAA,CAA4B,EAC5BR,SAAAS,0BAAA,CAAqC,CAOrCT,SAAAU,iBAAA,CAA4BC,QAAQ,CAACC,KAAD,CAAQ,CAAA,IACpCC,CAKJ,KAAKA,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBD,KAAAE,OAAhB,CAA8BD,CAAA,EAA9B,CAAmC,CAC/B,IAAAE,KAAOH,KAAA,CAAMC,CAAN,CAEP,IAAKE,IAAAC,SAAL,CAAA,CAGA,IAAAC,YAAcF,IAAAG,eAAAJ,OACdC,KAAAI,UAAAC,QAAAC,cAAA,EAAwCJ,WACxCF,KAAAI,UAAAG,QAAAD,cAAA,EAAwCJ,WALxC,CAH+B,CANK,CAyB5CjB,SAAAuB,cAAA,CAAyBC,QAAQ,CAACZ,KAAD,CAAQa,MAAR,CAAgBC,SAAhB,CAA2B,CAAA,IAiBpDC;AAAqBD,SAArBC,CAAiC3B,QAAAO,gBAErC,KAAKM,SAAL,CAAS,CAAT,CAAYA,SAAZ,CAAgBY,MAAAX,OAAhB,CAA+BD,SAAA,EAA/B,CAAoC,CAC5Be,IAAAA,MAAOH,MAAA,CAAOZ,SAAP,CACXe,MAAAC,wBAAAC,EAAA,CAAiCF,KAAAG,gBAAAD,EACjCF,MAAAC,wBAAAG,EAAA,CAAiCJ,KAAAG,gBAAAC,EAHD,CAOpC,IAAKnB,SAAL,CAAS,CAAT,CAAYA,SAAZ,CAAgBD,KAAAE,OAAhB,CAA8BD,SAAA,EAA9B,CAAmC,CAC/B,IAAAE,KAAOH,KAAA,CAAMC,SAAN,CAEP,IAAKE,IAAAC,SAAL,EAAsBiB,CAAAlB,IAAAkB,SAAtB,CAAA,CAGA,IAAAd,UAAYJ,IAAAI,UACZe,OAAA,CAAQf,SAAAC,QACRe,MAAA,CAAQhB,SAAAG,QACR,KAAAc,QAASjB,SAAAiB,OAET,KAAAC,QAAmBH,MAAAL,wBACnB,KAAAS;AAAmBH,KAAAN,wBAEnB,KAAAU,YAAcpB,SAAAoB,YAEdC,UAAA,CAAYF,gBAAAR,EAAZ,CAAiCO,OAAAP,EAAjC,CAAsDS,WAAAT,EACtDW,iBAAA,CAAYH,gBAAAN,EAAZ,CAAiCK,OAAAL,EAAjC,CAAsDO,WAAAP,EAEtDU,QAAA,CAAUN,OAAAN,EACVa,QAAA,CAAUP,OAAAJ,EAEVY,UAAA,CAAaF,OAAb,CAAuBF,SAAvB,CAAmCG,OAAnC,CAA6CF,gBAC7C1B,KAAA6B,WAAA,CAAkBA,SAElBb,UAAA,EAAmBa,SAAnB,CAAgC7B,IAAA8B,KAAhC,EAA6ClB,kBAE7C,IAAIO,MAAAY,SAAJ,EAAsBX,KAAAW,SAAtB,CACIf,SAAA,EAAmB,CAEjBG,OAAAY,SAAN,EAAwBZ,MAAAa,WAAxB,GACIC,IAEA,CAFejB,SAEf,CAFiCG,MAAAb,cAEjC,CADAa,MAAAH,gBAAAD,EACA,EAD2BY,OAC3B;AADqCM,IACrC,CAAAd,MAAAH,gBAAAC,EAAA,EAA2BW,OAA3B,CAAqCK,IAHzC,CAMMb,MAAAW,SAAN,EAAwBX,KAAAY,WAAxB,GACIC,IAEA,CAFejB,SAEf,CAFiCI,KAAAd,cAEjC,CADAc,KAAAJ,gBAAAD,EACA,EAD2BY,OAC3B,CADqCM,IACrC,CAAAb,KAAAJ,gBAAAC,EAAA,EAA2BW,OAA3B,CAAqCK,IAHzC,CAjCA,CAH+B,CA1BqB,CA2E5DhD,SAAAiD,kBAAA,CAA6BC,QAAQ,CAACzB,MAAD,CAAS,CAC1C,IAAK,IAAIZ,EAAI,CAAb,CAAgBA,CAAhB,CAAoBY,MAAAX,OAApB,CAAmCD,CAAA,EAAnC,CAAwC,CACpC,IAAIe,KAAOH,MAAA,CAAOZ,CAAP,CAGXe,KAAAP,cAAA,CAAqB,CAErB,IAA+B,CAA/B,GAAIO,IAAAG,gBAAAD,EAAJ,EAA+D,CAA/D,GAAoCF,IAAAG,gBAAAC,EAApC,CAAkE,CAE9D,IAAK,IAAImB,EAAI,CAAb,CAAgBA,CAAhB,CAAoBvB,IAAAwB,MAAAtC,OAApB,CAAuCqC,CAAA,EAAvC,CAA4C,CACxC,IAAIE,KAAOzB,IAAAwB,MAAA,CAAWD,CAAX,CACXlD,SAAAqD,UAAA,CAAmBD,IAAAE,SAAnB,CAAkC3B,IAAAG,gBAAlC,CACA3B,OAAAoD,OAAA,CAAcH,IAAAI,OAAd;AAA2BJ,IAAAE,SAA3B,CAA0C3B,IAAA8B,SAA1C,CACAL,KAAAM,SAAA7B,EAAA,EAAmBF,IAAAG,gBAAAD,EACnBuB,KAAAM,SAAA3B,EAAA,EAAmBJ,IAAAG,gBAAAC,EALqB,CAS5CJ,IAAAgC,aAAA9B,EAAA,EAAuBF,IAAAG,gBAAAD,EACvBF,KAAAgC,aAAA5B,EAAA,EAAuBJ,IAAAG,gBAAAC,EAE+B,EAAtD,CAAI9B,MAAA2D,IAAA,CAAWjC,IAAAG,gBAAX,CAAiCH,IAAA8B,SAAjC,CAAJ,EAEI9B,IAAAG,gBAAAD,EACA,CADyB,CACzB,CAAAF,IAAAG,gBAAAC,EAAA,CAAyB,CAH7B,GAMIJ,IAAAG,gBAAAD,EACA,EAD0B9B,QAAAQ,iBAC1B,CAAAoB,IAAAG,gBAAAC,EAAA,EAA0BhC,QAAAQ,iBAP9B,CAd8D,CAN9B,CADE,CAuC9CR,SAAA8D,iBAAA,CAA4BC,QAAQ,CAACnD,KAAD,CAAQ,CAAA,IACpCC,CADoC,CAepCmD,QAAU9D,MAAA+D,MAAA,CAAa,CAAb,CAf0B,CAgBpCC,MAAQhE,MAAA+D,MAAA,CAAa,CAAb,CAEZ,KAAKpD,CAAL;AAAS,CAAT,CAAYA,CAAZ,CAAgBD,KAAAE,OAAhB,CAA8BD,CAAA,EAA9B,CAAmC,CAC/B,IAAAE,KAAOH,KAAA,CAAMC,CAAN,CAEP,IAAKE,IAAAC,SAAL,EAAsBiB,CAAAlB,IAAAkB,SAAtB,CAAA,CAGA,IAAAkC,SAAWpD,IAAAG,eACX,KAAAC,EAAYJ,IAAAI,UACZe,KAAA,CAAQf,CAAAC,QACR,KAAAe,MAAQhB,CAAAG,QACR,KAAAc,OAASjB,CAAAiB,OACT,KAAAgC,QAAUjD,CAAAiD,QAGV,KAAKjB,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBgB,QAAArD,OAAhB,CAAiCqC,CAAA,EAAjC,CAAsC,CAClC,IAAAkB,QAAUF,QAAA,CAAShB,CAAT,CACV,KAAAmB,cAAgBD,OAAAE,OAChB,KAAAC,cAAgBH,OAAAG,cAChBC,QAAA,CAAiBJ,OAAAI,eAEjB,IAAsB,CAAtB,GAAID,aAAJ,EAA8C,CAA9C,GAA2BC,OAA3B,CAEIT,OAAAlC,EAWA,CAXaM,MAAAN,EAWb,CAXwB0C,aAWxB,CAX0CJ,OAAAtC,EAW1C,CAXsD2C,OAWtD,CAVAT,OAAAhC,EAUA,CAVaI,MAAAJ,EAUb,CAVwBwC,aAUxB,CAV0CJ,OAAApC,EAU1C,CAVsDyC,OAUtD,CAPMvC,IAAAY,SAON;AAPwBZ,IAAAa,WAOxB,GANI2B,aAGA,CAHSxE,MAAAyE,IAAA,CAAWL,aAAX,CAA0BpC,IAAAyB,SAA1B,CAA0CO,KAA1C,CAGT,CAFAhC,IAAA0B,aAAA9B,EAEA,EAFwBkC,OAAAlC,EAExB,CAFoCI,IAAA0C,YAEpC,CADA1C,IAAA0B,aAAA5B,EACA,EADwBgC,OAAAhC,EACxB,CADoCE,IAAA0C,YACpC,CAAA1C,IAAA2C,UAAA,EAAmB3E,MAAA4E,MAAA,CAAaJ,aAAb,CAAqBV,OAArB,CAAnB,CAAmD9B,IAAA6C,eAGvD,EAAM5C,KAAAW,SAAN,EAAwBX,KAAAY,WAAxB,GACI2B,aAGA,CAHSxE,MAAAyE,IAAA,CAAWL,aAAX,CAA0BnC,KAAAwB,SAA1B,CAA0CO,KAA1C,CAGT,CAFA/B,KAAAyB,aAAA9B,EAEA,EAFwBkC,OAAAlC,EAExB,CAFoCK,KAAAyC,YAEpC,CADAzC,KAAAyB,aAAA5B,EACA,EADwBgC,OAAAhC,EACxB,CADoCG,KAAAyC,YACpC,CAAAzC,KAAA0C,UAAA,EAAmB3E,MAAA4E,MAAA,CAAaJ,aAAb,CAAqBV,OAArB,CAAnB,CAAmD7B,KAAA4C,eAJvD,CAnB8B,CAXtC,CAH+B,CAlBK,CAoE5C/E;QAAAgF,cAAA,CAAyBC,QAAQ,CAACrE,KAAD,CAAQc,SAAR,CAAmB,CACzBA,SAAnBwD,EAA+BxD,SAQnC,KATgD,IAE5CsC,QAAU9D,MAAA+D,MAAA,CAAa,CAAb,CAFkC,CAG5CC,MAAQhE,MAAA+D,MAAA,CAAa,CAAb,CAHoC,CAI5CkB,MAAQjF,MAAA+D,MAAA,CAAa,CAAb,CAJoC,CAK5CmB,MAAQlF,MAAA+D,MAAA,CAAa,CAAb,CALoC,CAM5CoB,MAAQnF,MAAA+D,MAAA,CAAa,CAAb,CANoC,CAO5CqB,MAAQpF,MAAA+D,MAAA,CAAa,CAAb,CAPoC,CASvCpD,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,KAAAE,OAApB,CAAkCD,CAAA,EAAlC,CAAuC,CACnC,IAAIE,KAAOH,KAAA,CAAMC,CAAN,CAEX,IAAKE,IAAAC,SAAL,EAAsBiB,CAAAlB,IAAAkB,SAAtB,CAAA,CAHmC,IAM/Bd,UAAYJ,IAAAI,UANmB,CAO/Be,MAAQf,SAAAC,QAPuB,CAQ/Be,MAAQhB,SAAAG,QARuB,CAS/Bc,OAASjB,SAAAiB,OACTgC,UAAAA,CAAUjD,SAAAiD,QAVqB,KAW/BD,SAAWpD,IAAAG,eAXoB,CAY/B8B,aAAe,CAAfA,CAAmBmB,QAAArD,OAGvBoB,MAAAwB,SAAA5B,EAAA,CAAmBI,KAAAyB,SAAA7B,EAAnB;AAAsCI,KAAA0B,aAAA9B,EACtCI,MAAAwB,SAAA1B,EAAA,CAAmBE,KAAAyB,SAAA3B,EAAnB,CAAsCE,KAAA0B,aAAA5B,EACtCG,MAAAuB,SAAA5B,EAAA,CAAmBK,KAAAwB,SAAA7B,EAAnB,CAAsCK,KAAAyB,aAAA9B,EACtCK,MAAAuB,SAAA1B,EAAA,CAAmBG,KAAAwB,SAAA3B,EAAnB,CAAsCG,KAAAyB,aAAA5B,EACtCE,MAAAqD,gBAAA,CAAwBrD,KAAAsD,MAAxB,CAAsCtD,KAAA2C,UACtC1C,MAAAoD,gBAAA,CAAwBpD,KAAAqD,MAAxB,CAAsCrD,KAAA0C,UAGtC,KAAK,IAAI1B,EAAI,CAAb,CAAgBA,CAAhB,CAAoBgB,QAAArD,OAApB,CAAqCqC,CAAA,EAArC,CAA0C,CAAA,IAClCkB,QAAUF,QAAA,CAAShB,CAAT,CADwB,CAElCmB,cAAgBD,OAAAE,OAFkB,CAGlCkB,QAAUvF,MAAAyE,IAAA,CAAWL,aAAX,CAA0BpC,KAAAyB,SAA1B,CAA0CO,KAA1C,CACVwB,cAAAA,CAAUxF,MAAAyE,IAAA,CAAWL,aAAX,CAA0BnC,KAAAwB,SAA1B,CAA0CwB,KAA1C,CAJwB,KAKlCQ;AAAiBzF,MAAA0F,IAAA,CAAW1D,KAAAwB,SAAX,CAA2BxD,MAAA2F,KAAA,CAAY3F,MAAA4F,KAAA,CAAYL,OAAZ,CAAZ,CAAkCvD,KAAAqD,gBAAlC,CAA3B,CAAqFH,KAArF,CALiB,CAMlCW,eAAiB7F,MAAA0F,IAAA,CAAWzD,KAAAuB,SAAX,CAA2BxD,MAAA2F,KAAA,CAAY3F,MAAA4F,KAAA,CAAYJ,aAAZ,CAAZ,CAAkCvD,KAAAoD,gBAAlC,CAA3B,CAAqFF,KAArF,CACjBW,eAAAA,CAAmB9F,MAAAyE,IAAA,CAAWgB,cAAX,CAA2BI,cAA3B,CAA2CT,KAA3C,CANvB,KAOIW,eAAiB/F,MAAA2D,IAAA,CAAWzB,MAAX,CAAmB4D,cAAnB,CAPrB,CASIE,gBAAkBhG,MAAA2D,IAAA,CAAWO,SAAX,CAAoB4B,cAApB,CATtB,CAUIG,aAAeC,IAAAC,IAAA,CAASH,eAAT,CAVnB,CAWII,yBAA2BnG,MAAAoG,KAAA,CAAYL,eAAZ,CAG3B1B,eAAAA,EAAiB,CAAjBA,CAAqBzD,IAAAyF,YAArBhC,EAAyCyB,cAA7C;IACIQ,YAActG,MAAAuG,MAAA,CAAa3F,IAAA6B,WAAb,CAA+BqD,cAA/B,CAA+C,CAA/C,CAAkD,CAAlD,CAAdQ,CAAqEzG,QAAAS,0BAGrEgE,eAAAA,CAAiByB,eAArB,KACIS,YAAcC,QAEdT,aAAJ,CAAmBpF,IAAA8F,SAAnB,CAAmC9F,IAAA+F,eAAnC,CAAyDL,WAAzD,CAAuEvB,SAAvE,GACIyB,WACA,CADcR,YACd,CAAA1B,cAAA,CAAiBtE,MAAAuG,MAAA,CACb3F,IAAA8F,SADa,CACGP,wBADH,CAC8BpB,SAD9B,CAEb,CAACyB,WAFY,CAECA,WAFD,CAFrB,CASII,aAAAA,CAAO7G,MAAA4E,MAAA,CAAaW,OAAb,CAAsBrD,MAAtB,CACP4E,yBAAAA,CAAO9G,MAAA4E,MAAA,CAAaY,aAAb,CAAsBtD,MAAtB,CACP6E,aAAAA,CAAQjE,YAARiE,EAAwB/E,KAAA0C,YAAxBqC;AAA4C9E,KAAAyC,YAA5CqC,CAAgE/E,KAAA6C,eAAhEkC,CAAuFF,YAAvFE,CAA8FF,YAA9FE,CAAsG9E,KAAA4C,eAAtGkC,CAA6HD,wBAA7HC,CAAoID,wBAApIC,CAEJzC,eAAA,EAAiByC,YACjBxC,eAAA,EAAkBwC,YAGG,EAArB,CAAIhB,cAAJ,EAA0BA,cAA1B,CAA2CA,cAA3C,CAA4DjG,QAAAK,eAA5D,CAAsF6E,SAAtF,CAEIb,OAAAG,cAFJ,CAE4B,CAF5B,EAMQ0C,cAEJ,CAF2B7C,OAAAG,cAE3B,CADAH,OAAAG,cACA,CADwB4B,IAAAe,IAAA,CAAS9C,OAAAG,cAAT,CAAiCA,cAAjC,CAAgD,CAAhD,CACxB,CAAAA,cAAA,CAAgBH,OAAAG,cAAhB,CAAwC0C,cAR5C,CAYIhB,gBAAJ,CAAsBA,eAAtB,CAAwClG,QAAAM,sBAAxC;AAAyE4E,SAAzE,CAEIb,OAAAI,eAFJ,CAE6B,CAF7B,EAMQ2C,cAEJ,CAF4B/C,OAAAI,eAE5B,CADAJ,OAAAI,eACA,CADyBtE,MAAAuG,MAAA,CAAarC,OAAAI,eAAb,CAAsCA,cAAtC,CAAsD,CAACkC,WAAvD,CAAoEA,WAApE,CACzB,CAAAlC,cAAA,CAAiBJ,OAAAI,eAAjB,CAA0C2C,cAR9C,CAYApD,QAAAlC,EAAA,CAAaM,MAAAN,EAAb,CAAwB0C,cAAxB,CAA0CJ,SAAAtC,EAA1C,CAAsD2C,cACtDT,QAAAhC,EAAA,CAAaI,MAAAJ,EAAb,CAAwBwC,cAAxB,CAA0CJ,SAAApC,EAA1C,CAAsDyC,cAGhDvC,MAAAY,SAAN,EAAwBZ,KAAAa,WAAxB,GACIb,KAAA0B,aAAA9B,EAEA,EAFwBkC,OAAAlC,EAExB,CAFoCI,KAAA0C,YAEpC,CADA1C,KAAA0B,aAAA5B,EACA,EADwBgC,OAAAhC,EACxB,CADoCE,KAAA0C,YACpC,CAAA1C,KAAA2C,UAAA;AAAmB3E,MAAA4E,MAAA,CAAaW,OAAb,CAAsBzB,OAAtB,CAAnB,CAAoD9B,KAAA6C,eAHxD,CAMM5C,MAAAW,SAAN,EAAwBX,KAAAY,WAAxB,GACIZ,KAAAyB,aAAA9B,EAEA,EAFwBkC,OAAAlC,EAExB,CAFoCK,KAAAyC,YAEpC,CADAzC,KAAAyB,aAAA5B,EACA,EADwBgC,OAAAhC,EACxB,CADoCG,KAAAyC,YACpC,CAAAzC,KAAA0C,UAAA,EAAmB3E,MAAA4E,MAAA,CAAaY,aAAb,CAAsB1B,OAAtB,CAAnB,CAAoD7B,KAAA4C,eAHxD,CAzEsC,CApB1C,CAHmC,CATS,CA5N5C,CAAX,CAAD,EAhBoI;",
"sources":["node_modules/Phaser/src/physics/matter-js/lib/collision/Resolver.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$lib$collision$Resolver\"] = function(global,require,module,exports) {\n/**\r\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\r\n*\r\n* @class Resolver\r\n*/\r\n\r\nvar Resolver = {};\r\n\r\nmodule.exports = Resolver;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Vector = require('../geometry/Vector');\r\nvar Common = require('../core/Common');\r\nvar Bounds = require('../geometry/Bounds');\r\n\r\n(function() {\r\n\r\n    Resolver._restingThresh = 4;\r\n    Resolver._restingThreshTangent = 6;\r\n    Resolver._positionDampen = 0.9;\r\n    Resolver._positionWarming = 0.8;\r\n    Resolver._frictionNormalMultiplier = 5;\r\n\r\n    /**\r\n     * Prepare pairs for position solving.\r\n     * @method preSolvePosition\r\n     * @param {pair[]} pairs\r\n     */\r\n    Resolver.preSolvePosition = function(pairs) {\r\n        var i,\r\n            pair,\r\n            activeCount;\r\n\r\n        // find total contacts on each body\r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            \r\n            if (!pair.isActive)\r\n                continue;\r\n            \r\n            activeCount = pair.activeContacts.length;\r\n            pair.collision.parentA.totalContacts += activeCount;\r\n            pair.collision.parentB.totalContacts += activeCount;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Find a solution for pair positions.\r\n     * @method solvePosition\r\n     * @param {pair[]} pairs\r\n     * @param {body[]} bodies\r\n     * @param {number} timeScale\r\n     */\r\n    Resolver.solvePosition = function(pairs, bodies, timeScale) {\r\n        var i,\r\n            normalX,\r\n            normalY,\r\n            pair,\r\n            collision,\r\n            bodyA,\r\n            bodyB,\r\n            normal,\r\n            separation,\r\n            penetration,\r\n            positionImpulseA,\r\n            positionImpulseB,\r\n            contactShare,\r\n            bodyBtoAX,\r\n            bodyBtoAY,\r\n            positionImpulse,\r\n            impulseCoefficient = timeScale * Resolver._positionDampen;\r\n\r\n        for (i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n            body.previousPositionImpulse.x = body.positionImpulse.x;\r\n            body.previousPositionImpulse.y = body.positionImpulse.y;\r\n        }\r\n\r\n        // find impulses required to resolve penetration\r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            \r\n            if (!pair.isActive || pair.isSensor)\r\n                continue;\r\n\r\n            collision = pair.collision;\r\n            bodyA = collision.parentA;\r\n            bodyB = collision.parentB;\r\n            normal = collision.normal;\r\n\r\n            positionImpulseA = bodyA.previousPositionImpulse;\r\n            positionImpulseB = bodyB.previousPositionImpulse;\r\n\r\n            penetration = collision.penetration;\r\n\r\n            bodyBtoAX = positionImpulseB.x - positionImpulseA.x + penetration.x;\r\n            bodyBtoAY = positionImpulseB.y - positionImpulseA.y + penetration.y;\r\n\r\n            normalX = normal.x;\r\n            normalY = normal.y;\r\n\r\n            separation = normalX * bodyBtoAX + normalY * bodyBtoAY;\r\n            pair.separation = separation;\r\n\r\n            positionImpulse = (separation - pair.slop) * impulseCoefficient;\r\n\r\n            if (bodyA.isStatic || bodyB.isStatic)\r\n                positionImpulse *= 2;\r\n            \r\n            if (!(bodyA.isStatic || bodyA.isSleeping)) {\r\n                contactShare = positionImpulse / bodyA.totalContacts;\r\n                bodyA.positionImpulse.x += normalX * contactShare;\r\n                bodyA.positionImpulse.y += normalY * contactShare;\r\n            }\r\n\r\n            if (!(bodyB.isStatic || bodyB.isSleeping)) {\r\n                contactShare = positionImpulse / bodyB.totalContacts;\r\n                bodyB.positionImpulse.x -= normalX * contactShare;\r\n                bodyB.positionImpulse.y -= normalY * contactShare;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Apply position resolution.\r\n     * @method postSolvePosition\r\n     * @param {body[]} bodies\r\n     */\r\n    Resolver.postSolvePosition = function(bodies) {\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            // reset contact count\r\n            body.totalContacts = 0;\r\n\r\n            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {\r\n                // update body geometry\r\n                for (var j = 0; j < body.parts.length; j++) {\r\n                    var part = body.parts[j];\r\n                    Vertices.translate(part.vertices, body.positionImpulse);\r\n                    Bounds.update(part.bounds, part.vertices, body.velocity);\r\n                    part.position.x += body.positionImpulse.x;\r\n                    part.position.y += body.positionImpulse.y;\r\n                }\r\n\r\n                // move the body without changing velocity\r\n                body.positionPrev.x += body.positionImpulse.x;\r\n                body.positionPrev.y += body.positionImpulse.y;\r\n\r\n                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {\r\n                    // reset cached impulse if the body has velocity along it\r\n                    body.positionImpulse.x = 0;\r\n                    body.positionImpulse.y = 0;\r\n                } else {\r\n                    // warm the next iteration\r\n                    body.positionImpulse.x *= Resolver._positionWarming;\r\n                    body.positionImpulse.y *= Resolver._positionWarming;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Prepare pairs for velocity solving.\r\n     * @method preSolveVelocity\r\n     * @param {pair[]} pairs\r\n     */\r\n    Resolver.preSolveVelocity = function(pairs) {\r\n        var i,\r\n            j,\r\n            pair,\r\n            contacts,\r\n            collision,\r\n            bodyA,\r\n            bodyB,\r\n            normal,\r\n            tangent,\r\n            contact,\r\n            contactVertex,\r\n            normalImpulse,\r\n            tangentImpulse,\r\n            offset,\r\n            impulse = Vector._temp[0],\r\n            tempA = Vector._temp[1];\r\n        \r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            \r\n            if (!pair.isActive || pair.isSensor)\r\n                continue;\r\n            \r\n            contacts = pair.activeContacts;\r\n            collision = pair.collision;\r\n            bodyA = collision.parentA;\r\n            bodyB = collision.parentB;\r\n            normal = collision.normal;\r\n            tangent = collision.tangent;\r\n\r\n            // resolve each contact\r\n            for (j = 0; j < contacts.length; j++) {\r\n                contact = contacts[j];\r\n                contactVertex = contact.vertex;\r\n                normalImpulse = contact.normalImpulse;\r\n                tangentImpulse = contact.tangentImpulse;\r\n\r\n                if (normalImpulse !== 0 || tangentImpulse !== 0) {\r\n                    // total impulse from contact\r\n                    impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\r\n                    impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\r\n                    \r\n                    // apply impulse from contact\r\n                    if (!(bodyA.isStatic || bodyA.isSleeping)) {\r\n                        offset = Vector.sub(contactVertex, bodyA.position, tempA);\r\n                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\r\n                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\r\n                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;\r\n                    }\r\n\r\n                    if (!(bodyB.isStatic || bodyB.isSleeping)) {\r\n                        offset = Vector.sub(contactVertex, bodyB.position, tempA);\r\n                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\r\n                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\r\n                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Find a solution for pair velocities.\r\n     * @method solveVelocity\r\n     * @param {pair[]} pairs\r\n     * @param {number} timeScale\r\n     */\r\n    Resolver.solveVelocity = function(pairs, timeScale) {\r\n        var timeScaleSquared = timeScale * timeScale,\r\n            impulse = Vector._temp[0],\r\n            tempA = Vector._temp[1],\r\n            tempB = Vector._temp[2],\r\n            tempC = Vector._temp[3],\r\n            tempD = Vector._temp[4],\r\n            tempE = Vector._temp[5];\r\n        \r\n        for (var i = 0; i < pairs.length; i++) {\r\n            var pair = pairs[i];\r\n            \r\n            if (!pair.isActive || pair.isSensor)\r\n                continue;\r\n            \r\n            var collision = pair.collision,\r\n                bodyA = collision.parentA,\r\n                bodyB = collision.parentB,\r\n                normal = collision.normal,\r\n                tangent = collision.tangent,\r\n                contacts = pair.activeContacts,\r\n                contactShare = 1 / contacts.length;\r\n\r\n            // update body velocities\r\n            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;\r\n            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;\r\n            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;\r\n            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;\r\n            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\r\n            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\r\n\r\n            // resolve each contact\r\n            for (var j = 0; j < contacts.length; j++) {\r\n                var contact = contacts[j],\r\n                    contactVertex = contact.vertex,\r\n                    offsetA = Vector.sub(contactVertex, bodyA.position, tempA),\r\n                    offsetB = Vector.sub(contactVertex, bodyB.position, tempB),\r\n                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),\r\n                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), \r\n                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),\r\n                    normalVelocity = Vector.dot(normal, relativeVelocity);\r\n\r\n                var tangentVelocity = Vector.dot(tangent, relativeVelocity),\r\n                    tangentSpeed = Math.abs(tangentVelocity),\r\n                    tangentVelocityDirection = Common.sign(tangentVelocity);\r\n\r\n                // raw impulses\r\n                var normalImpulse = (1 + pair.restitution) * normalVelocity,\r\n                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;\r\n\r\n                // coulomb friction\r\n                var tangentImpulse = tangentVelocity,\r\n                    maxFriction = Infinity;\r\n\r\n                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {\r\n                    maxFriction = tangentSpeed;\r\n                    tangentImpulse = Common.clamp(\r\n                        pair.friction * tangentVelocityDirection * timeScaleSquared,\r\n                        -maxFriction, maxFriction\r\n                    );\r\n                }\r\n\r\n                // modify impulses accounting for mass, inertia and offset\r\n                var oAcN = Vector.cross(offsetA, normal),\r\n                    oBcN = Vector.cross(offsetB, normal),\r\n                    share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);\r\n\r\n                normalImpulse *= share;\r\n                tangentImpulse *= share;\r\n\r\n                // handle high velocity and resting collisions separately\r\n                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {\r\n                    // high normal velocity so clear cached contact normal impulse\r\n                    contact.normalImpulse = 0;\r\n                } else {\r\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\r\n                    // impulse constraint tends to 0\r\n                    var contactNormalImpulse = contact.normalImpulse;\r\n                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);\r\n                    normalImpulse = contact.normalImpulse - contactNormalImpulse;\r\n                }\r\n\r\n                // handle high velocity and resting collisions separately\r\n                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {\r\n                    // high tangent velocity so clear cached contact tangent impulse\r\n                    contact.tangentImpulse = 0;\r\n                } else {\r\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\r\n                    // tangent impulse tends to -tangentSpeed or +tangentSpeed\r\n                    var contactTangentImpulse = contact.tangentImpulse;\r\n                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);\r\n                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\r\n                }\r\n\r\n                // total impulse from contact\r\n                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\r\n                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\r\n                \r\n                // apply impulse from contact\r\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\r\n                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\r\n                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\r\n                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;\r\n                }\r\n\r\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\r\n                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\r\n                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\r\n                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n})();\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Resolver","Vertices","Vector","Common","Bounds","_restingThresh","_restingThreshTangent","_positionDampen","_positionWarming","_frictionNormalMultiplier","preSolvePosition","Resolver.preSolvePosition","pairs","i","length","pair","isActive","activeCount","activeContacts","collision","parentA","totalContacts","parentB","solvePosition","Resolver.solvePosition","bodies","timeScale","impulseCoefficient","body","previousPositionImpulse","x","positionImpulse","y","isSensor","bodyA","bodyB","normal","positionImpulseA","positionImpulseB","penetration","bodyBtoAX","bodyBtoAY","normalX","normalY","separation","slop","isStatic","isSleeping","contactShare","postSolvePosition","Resolver.postSolvePosition","j","parts","part","translate","vertices","update","bounds","velocity","position","positionPrev","dot","preSolveVelocity","Resolver.preSolveVelocity","impulse","_temp","tempA","contacts","tangent","contact","contactVertex","vertex","normalImpulse","tangentImpulse","offset","sub","inverseMass","anglePrev","cross","inverseInertia","solveVelocity","Resolver.solveVelocity","timeScaleSquared","tempB","tempC","tempD","tempE","angularVelocity","angle","offsetA","offsetB","velocityPointA","add","mult","perp","velocityPointB","relativeVelocity","normalVelocity","tangentVelocity","tangentSpeed","Math","abs","tangentVelocityDirection","sign","restitution","normalForce","clamp","maxFriction","Infinity","friction","frictionStatic","oAcN","oBcN","share","contactNormalImpulse","min","contactTangentImpulse"]
}
