{
"version":3,
"file":"module$node_modules$$formatjs$ecma402_abstract$NumberFormat$ToRawPrecision.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/@formatjs/ecma402-abstract/NumberFormat/ToRawPrecision.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$formatjs$ecma402_abstract$NumberFormat$ToRawPrecision\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ToRawPrecision = void 0;\nvar utils_1 = require(\"../utils\");\nfunction ToRawPrecision(x, minPrecision, maxPrecision) {\n    var p = maxPrecision;\n    var m;\n    var e;\n    var xFinal;\n    if (x === 0) {\n        m = utils_1.repeat('0', p);\n        e = 0;\n        xFinal = 0;\n    }\n    else {\n        var xToString = x.toString();\n        // If xToString is formatted as scientific notation, the number is either very small or very\n        // large. If the precision of the formatted string is lower that requested max precision, we\n        // should still infer them from the formatted string, otherwise the formatted result might have\n        // precision loss (e.g. 1e41 will not have 0 in every trailing digits).\n        var xToStringExponentIndex = xToString.indexOf('e');\n        var _a = xToString.split('e'), xToStringMantissa = _a[0], xToStringExponent = _a[1];\n        var xToStringMantissaWithoutDecimalPoint = xToStringMantissa.replace('.', '');\n        if (xToStringExponentIndex >= 0 &&\n            xToStringMantissaWithoutDecimalPoint.length <= p) {\n            e = +xToStringExponent;\n            m =\n                xToStringMantissaWithoutDecimalPoint +\n                    utils_1.repeat('0', p - xToStringMantissaWithoutDecimalPoint.length);\n            xFinal = x;\n        }\n        else {\n            e = utils_1.getMagnitude(x);\n            var decimalPlaceOffset = e - p + 1;\n            // n is the integer containing the required precision digits. To derive the formatted string,\n            // we will adjust its decimal place in the logic below.\n            var n = Math.round(adjustDecimalPlace(x, decimalPlaceOffset));\n            // The rounding caused the change of magnitude, so we should increment `e` by 1.\n            if (adjustDecimalPlace(n, p - 1) >= 10) {\n                e = e + 1;\n                // Divide n by 10 to swallow one precision.\n                n = Math.floor(n / 10);\n            }\n            m = n.toString();\n            // Equivalent of n * 10 ** (e - p + 1)\n            xFinal = adjustDecimalPlace(n, p - 1 - e);\n        }\n    }\n    var int;\n    if (e >= p - 1) {\n        m = m + utils_1.repeat('0', e - p + 1);\n        int = e + 1;\n    }\n    else if (e >= 0) {\n        m = m.slice(0, e + 1) + \".\" + m.slice(e + 1);\n        int = e + 1;\n    }\n    else {\n        m = \"0.\" + utils_1.repeat('0', -e - 1) + m;\n        int = 1;\n    }\n    if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {\n        var cut = maxPrecision - minPrecision;\n        while (cut > 0 && m[m.length - 1] === '0') {\n            m = m.slice(0, -1);\n            cut--;\n        }\n        if (m[m.length - 1] === '.') {\n            m = m.slice(0, -1);\n        }\n    }\n    return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };\n    // x / (10 ** magnitude), but try to preserve as much floating point precision as possible.\n    function adjustDecimalPlace(x, magnitude) {\n        return magnitude < 0 ? x * Math.pow(10, -magnitude) : x / Math.pow(10, magnitude);\n    }\n}\nexports.ToRawPrecision = ToRawPrecision;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","ToRawPrecision","utils_1","x","minPrecision","maxPrecision","adjustDecimalPlace","magnitude","Math","pow","e","m","repeat","xFinal","xToString","toString","xToStringExponentIndex","indexOf","_a","split","xToStringExponent","xToStringMantissaWithoutDecimalPoint","xToStringMantissa","replace","length","getMagnitude","n","round","floor","slice","int","cut","formattedString","roundedNumber","integerDigitsCount"]
}
