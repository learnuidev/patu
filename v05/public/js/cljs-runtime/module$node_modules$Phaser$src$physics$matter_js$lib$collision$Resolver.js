shadow$provide.module$node_modules$Phaser$src$physics$matter_js$lib$collision$Resolver=function(global,require,module,exports){var Resolver={};module.exports=Resolver;var Vertices=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vertices"),Vector=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Vector"),Common=require("module$node_modules$Phaser$src$physics$matter_js$lib$core$Common"),Bounds=require("module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Bounds");
(function(){Resolver._restingThresh=4;Resolver._restingThreshTangent=6;Resolver._positionDampen=.9;Resolver._positionWarming=.8;Resolver._frictionNormalMultiplier=5;Resolver.preSolvePosition=function(pairs){var i;for(i=0;i<pairs.length;i++){var pair=pairs[i];if(pair.isActive){var activeCount=pair.activeContacts.length;pair.collision.parentA.totalContacts+=activeCount;pair.collision.parentB.totalContacts+=activeCount}}};Resolver.solvePosition=function(pairs,bodies,timeScale){var impulseCoefficient=
timeScale*Resolver._positionDampen;for(timeScale=0;timeScale<bodies.length;timeScale++){var bodyB=bodies[timeScale];bodyB.previousPositionImpulse.x=bodyB.positionImpulse.x;bodyB.previousPositionImpulse.y=bodyB.positionImpulse.y}for(timeScale=0;timeScale<pairs.length;timeScale++){var pair=pairs[timeScale];if(pair.isActive&&!pair.isSensor){var collision=pair.collision;bodies=collision.parentA;bodyB=collision.parentB;var normalY=collision.normal;var normalX=bodies.previousPositionImpulse;var positionImpulseB=
bodyB.previousPositionImpulse;var penetration=collision.penetration;collision=positionImpulseB.x-normalX.x+penetration.x;positionImpulseB=positionImpulseB.y-normalX.y+penetration.y;normalX=normalY.x;normalY=normalY.y;collision=normalX*collision+normalY*positionImpulseB;pair.separation=collision;collision=(collision-pair.slop)*impulseCoefficient;if(bodies.isStatic||bodyB.isStatic)collision*=2;bodies.isStatic||bodies.isSleeping||(pair=collision/bodies.totalContacts,bodies.positionImpulse.x+=normalX*
pair,bodies.positionImpulse.y+=normalY*pair);bodyB.isStatic||bodyB.isSleeping||(pair=collision/bodyB.totalContacts,bodyB.positionImpulse.x-=normalX*pair,bodyB.positionImpulse.y-=normalY*pair)}}};Resolver.postSolvePosition=function(bodies){for(var i=0;i<bodies.length;i++){var body=bodies[i];body.totalContacts=0;if(0!==body.positionImpulse.x||0!==body.positionImpulse.y){for(var j=0;j<body.parts.length;j++){var part=body.parts[j];Vertices.translate(part.vertices,body.positionImpulse);Bounds.update(part.bounds,
part.vertices,body.velocity);part.position.x+=body.positionImpulse.x;part.position.y+=body.positionImpulse.y}body.positionPrev.x+=body.positionImpulse.x;body.positionPrev.y+=body.positionImpulse.y;0>Vector.dot(body.positionImpulse,body.velocity)?(body.positionImpulse.x=0,body.positionImpulse.y=0):(body.positionImpulse.x*=Resolver._positionWarming,body.positionImpulse.y*=Resolver._positionWarming)}}};Resolver.preSolveVelocity=function(pairs){var i,impulse=Vector._temp[0],tempA=Vector._temp[1];for(i=
0;i<pairs.length;i++){var pair=pairs[i];if(pair.isActive&&!pair.isSensor){var contacts=pair.activeContacts;var j=pair.collision;pair=j.parentA;var bodyB=j.parentB;var normal=j.normal;var tangent=j.tangent;for(j=0;j<contacts.length;j++){var contact=contacts[j];var contactVertex=contact.vertex;var normalImpulse=contact.normalImpulse;contact=contact.tangentImpulse;if(0!==normalImpulse||0!==contact)impulse.x=normal.x*normalImpulse+tangent.x*contact,impulse.y=normal.y*normalImpulse+tangent.y*contact,pair.isStatic||
pair.isSleeping||(normalImpulse=Vector.sub(contactVertex,pair.position,tempA),pair.positionPrev.x+=impulse.x*pair.inverseMass,pair.positionPrev.y+=impulse.y*pair.inverseMass,pair.anglePrev+=Vector.cross(normalImpulse,impulse)*pair.inverseInertia),bodyB.isStatic||bodyB.isSleeping||(normalImpulse=Vector.sub(contactVertex,bodyB.position,tempA),bodyB.positionPrev.x-=impulse.x*bodyB.inverseMass,bodyB.positionPrev.y-=impulse.y*bodyB.inverseMass,bodyB.anglePrev-=Vector.cross(normalImpulse,impulse)*bodyB.inverseInertia)}}}};
Resolver.solveVelocity=function(pairs,timeScale){timeScale*=timeScale;for(var impulse=Vector._temp[0],tempA=Vector._temp[1],tempB=Vector._temp[2],tempC=Vector._temp[3],tempD=Vector._temp[4],tempE=Vector._temp[5],i=0;i<pairs.length;i++){var pair=pairs[i];if(pair.isActive&&!pair.isSensor){var collision=pair.collision,bodyA=collision.parentA,bodyB=collision.parentB,normal=collision.normal;collision=collision.tangent;var contacts=pair.activeContacts,contactShare=1/contacts.length;bodyA.velocity.x=bodyA.position.x-
bodyA.positionPrev.x;bodyA.velocity.y=bodyA.position.y-bodyA.positionPrev.y;bodyB.velocity.x=bodyB.position.x-bodyB.positionPrev.x;bodyB.velocity.y=bodyB.position.y-bodyB.positionPrev.y;bodyA.angularVelocity=bodyA.angle-bodyA.anglePrev;bodyB.angularVelocity=bodyB.angle-bodyB.anglePrev;for(var j=0;j<contacts.length;j++){var contact=contacts[j],contactVertex=contact.vertex,offsetA=Vector.sub(contactVertex,bodyA.position,tempA);contactVertex=Vector.sub(contactVertex,bodyB.position,tempB);var velocityPointA=
Vector.add(bodyA.velocity,Vector.mult(Vector.perp(offsetA),bodyA.angularVelocity),tempC),velocityPointB=Vector.add(bodyB.velocity,Vector.mult(Vector.perp(contactVertex),bodyB.angularVelocity),tempD);velocityPointA=Vector.sub(velocityPointA,velocityPointB,tempE);var normalVelocity=Vector.dot(normal,velocityPointA),tangentVelocity=Vector.dot(collision,velocityPointA),tangentSpeed=Math.abs(tangentVelocity),tangentVelocityDirection=Common.sign(tangentVelocity);velocityPointA=(1+pair.restitution)*normalVelocity;
var normalForce=Common.clamp(pair.separation+normalVelocity,0,1)*Resolver._frictionNormalMultiplier;velocityPointB=tangentVelocity;var maxFriction=Infinity;tangentSpeed>pair.friction*pair.frictionStatic*normalForce*timeScale&&(maxFriction=tangentSpeed,velocityPointB=Common.clamp(pair.friction*tangentVelocityDirection*timeScale,-maxFriction,maxFriction));tangentSpeed=Vector.cross(offsetA,normal);tangentVelocityDirection=Vector.cross(contactVertex,normal);tangentSpeed=contactShare/(bodyA.inverseMass+
bodyB.inverseMass+bodyA.inverseInertia*tangentSpeed*tangentSpeed+bodyB.inverseInertia*tangentVelocityDirection*tangentVelocityDirection);velocityPointA*=tangentSpeed;velocityPointB*=tangentSpeed;0>normalVelocity&&normalVelocity*normalVelocity>Resolver._restingThresh*timeScale?contact.normalImpulse=0:(normalVelocity=contact.normalImpulse,contact.normalImpulse=Math.min(contact.normalImpulse+velocityPointA,0),velocityPointA=contact.normalImpulse-normalVelocity);tangentVelocity*tangentVelocity>Resolver._restingThreshTangent*
timeScale?contact.tangentImpulse=0:(normalVelocity=contact.tangentImpulse,contact.tangentImpulse=Common.clamp(contact.tangentImpulse+velocityPointB,-maxFriction,maxFriction),velocityPointB=contact.tangentImpulse-normalVelocity);impulse.x=normal.x*velocityPointA+collision.x*velocityPointB;impulse.y=normal.y*velocityPointA+collision.y*velocityPointB;bodyA.isStatic||bodyA.isSleeping||(bodyA.positionPrev.x+=impulse.x*bodyA.inverseMass,bodyA.positionPrev.y+=impulse.y*bodyA.inverseMass,bodyA.anglePrev+=
Vector.cross(offsetA,impulse)*bodyA.inverseInertia);bodyB.isStatic||bodyB.isSleeping||(bodyB.positionPrev.x-=impulse.x*bodyB.inverseMass,bodyB.positionPrev.y-=impulse.y*bodyB.inverseMass,bodyB.anglePrev-=Vector.cross(contactVertex,impulse)*bodyB.inverseInertia)}}}}})()}
//# sourceMappingURL=module$node_modules$Phaser$src$physics$matter_js$lib$collision$Resolver.js.map
