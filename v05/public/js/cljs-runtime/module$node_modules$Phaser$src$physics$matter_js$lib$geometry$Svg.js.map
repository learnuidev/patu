{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Svg.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/matter-js/lib/geometry/Svg.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$lib$geometry$Svg\"] = function(global,require,module,exports) {\n/**\r\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\r\n*\r\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Svg\r\n*/\r\n\r\nvar Svg = {};\r\n\r\nmodule.exports = Svg;\r\n\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Converts an SVG path into an array of vector points.\r\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\r\n     * See `Bodies.fromVertices` which provides support for this.\r\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\r\n     * You must load the `pathseg.js` polyfill on newer browsers.\r\n     * @method pathToVertices\r\n     * @param {SVGPathElement} path\r\n     * @param {Number} [sampleLength=15]\r\n     * @return {Vector[]} points\r\n     */\r\n    Svg.pathToVertices = function(path, sampleLength) {\r\n        if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\r\n            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\r\n        }\r\n\r\n        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\r\n        var i, il, total, point, segment, segments, \r\n            segmentsQueue, lastSegment, \r\n            lastPoint, segmentIndex, points = [],\r\n            lx, ly, length = 0, x = 0, y = 0;\r\n\r\n        sampleLength = sampleLength || 15;\r\n\r\n        var addPoint = function(px, py, pathSegType) {\r\n            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\r\n            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\r\n\r\n            // when the last point doesn't equal the current point add the current point\r\n            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\r\n                if (lastPoint && isRelative) {\r\n                    lx = lastPoint.x;\r\n                    ly = lastPoint.y;\r\n                } else {\r\n                    lx = 0;\r\n                    ly = 0;\r\n                }\r\n\r\n                var point = {\r\n                    x: lx + px,\r\n                    y: ly + py\r\n                };\r\n\r\n                // set last point\r\n                if (isRelative || !lastPoint) {\r\n                    lastPoint = point;\r\n                }\r\n\r\n                points.push(point);\r\n\r\n                x = lx + px;\r\n                y = ly + py;\r\n            }\r\n        };\r\n\r\n        var addSegmentPoint = function(segment) {\r\n            var segType = segment.pathSegTypeAsLetter.toUpperCase();\r\n\r\n            // skip path ends\r\n            if (segType === 'Z') \r\n                return;\r\n\r\n            // map segment to x and y\r\n            switch (segType) {\r\n\r\n            case 'M':\r\n            case 'L':\r\n            case 'T':\r\n            case 'C':\r\n            case 'S':\r\n            case 'Q':\r\n                x = segment.x;\r\n                y = segment.y;\r\n                break;\r\n            case 'H':\r\n                x = segment.x;\r\n                break;\r\n            case 'V':\r\n                y = segment.y;\r\n                break;\r\n            }\r\n\r\n            addPoint(x, y, segment.pathSegType);\r\n        };\r\n\r\n        // ensure path is absolute\r\n        Svg._svgPathToAbsolute(path);\r\n\r\n        // get total length\r\n        total = path.getTotalLength();\r\n\r\n        // queue segments\r\n        segments = [];\r\n        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)\r\n            segments.push(path.pathSegList.getItem(i));\r\n\r\n        segmentsQueue = segments.concat();\r\n\r\n        // sample through path\r\n        while (length < total) {\r\n            // get segment at position\r\n            segmentIndex = path.getPathSegAtLength(length);\r\n            segment = segments[segmentIndex];\r\n\r\n            // new segment\r\n            if (segment != lastSegment) {\r\n                while (segmentsQueue.length && segmentsQueue[0] != segment)\r\n                    addSegmentPoint(segmentsQueue.shift());\r\n\r\n                lastSegment = segment;\r\n            }\r\n\r\n            // add points in between when curving\r\n            // TODO: adaptive sampling\r\n            switch (segment.pathSegTypeAsLetter.toUpperCase()) {\r\n\r\n            case 'C':\r\n            case 'T':\r\n            case 'S':\r\n            case 'Q':\r\n            case 'A':\r\n                point = path.getPointAtLength(length);\r\n                addPoint(point.x, point.y, 0);\r\n                break;\r\n\r\n            }\r\n\r\n            // increment by sample value\r\n            length += sampleLength;\r\n        }\r\n\r\n        // add remaining segments not passed by sampling\r\n        for (i = 0, il = segmentsQueue.length; i < il; ++i)\r\n            addSegmentPoint(segmentsQueue[i]);\r\n\r\n        return points;\r\n    };\r\n\r\n    Svg._svgPathToAbsolute = function(path) {\r\n        // http://phrogz.net/convert-svg-path-to-all-absolute-commands\r\n        // Copyright (c) Gavin Kistner\r\n        // http://phrogz.net/js/_ReuseLicense.txt\r\n        // Modifications: tidy formatting and naming\r\n        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,\r\n            x = 0, y = 0, len = segs.numberOfItems;\r\n\r\n        for (var i = 0; i < len; ++i) {\r\n            var seg = segs.getItem(i),\r\n                segType = seg.pathSegTypeAsLetter;\r\n\r\n            if (/[MLHVCSQTA]/.test(segType)) {\r\n                if ('x' in seg) x = seg.x;\r\n                if ('y' in seg) y = seg.y;\r\n            } else {\r\n                if ('x1' in seg) x1 = x + seg.x1;\r\n                if ('x2' in seg) x2 = x + seg.x2;\r\n                if ('y1' in seg) y1 = y + seg.y1;\r\n                if ('y2' in seg) y2 = y + seg.y2;\r\n                if ('x' in seg) x += seg.x;\r\n                if ('y' in seg) y += seg.y;\r\n\r\n                switch (segType) {\r\n\r\n                case 'm':\r\n                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\r\n                    break;\r\n                case 'l':\r\n                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\r\n                    break;\r\n                case 'h':\r\n                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\r\n                    break;\r\n                case 'v':\r\n                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\r\n                    break;\r\n                case 'c':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\r\n                    break;\r\n                case 's':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\r\n                    break;\r\n                case 'q':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\r\n                    break;\r\n                case 't':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\r\n                    break;\r\n                case 'a':\r\n                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\r\n                    break;\r\n                case 'z':\r\n                case 'Z':\r\n                    x = x0;\r\n                    y = y0;\r\n                    break;\r\n\r\n                }\r\n            }\r\n\r\n            if (segType == 'M' || segType == 'm') {\r\n                x0 = x;\r\n                y0 = y;\r\n            }\r\n        }\r\n    };\r\n\r\n})();\n};"],
"names":["shadow$provide","global","require","module","exports","Svg","Common","pathToVertices","Svg.pathToVertices","path","sampleLength","window","warn","i","segmentsQueue","lastPoint","points","lx","ly","length","x","y","addPoint","px","py","pathSegType","isRelative","point","push","addSegmentPoint","segment","segType","pathSegTypeAsLetter","toUpperCase","_svgPathToAbsolute","total","getTotalLength","segments","pathSegList","numberOfItems","getItem","concat","segmentIndex","getPathSegAtLength","lastSegment","shift","getPointAtLength","il","Svg._svgPathToAbsolute","x0","y0","x1","y1","x2","y2","segs","len","seg","test","replaceItem","createSVGPathSegMovetoAbs","createSVGPathSegLinetoAbs","createSVGPathSegLinetoHorizontalAbs","createSVGPathSegLinetoVerticalAbs","createSVGPathSegCurvetoCubicAbs","createSVGPathSegCurvetoCubicSmoothAbs","createSVGPathSegCurvetoQuadraticAbs","createSVGPathSegCurvetoQuadraticSmoothAbs","createSVGPathSegArcAbs","r1","r2","angle","largeArcFlag","sweepFlag"]
}
