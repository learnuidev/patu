{
"version":3,
"file":"module$node_modules$Phaser$src$physics$matter_js$MatterTileBody.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/Phaser/src/physics/matter-js/MatterTileBody.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$physics$matter_js$MatterTileBody\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Bodies = require('./lib/factory/Bodies');\r\nvar Body = require('./lib/body/Body');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('./components');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar HasValue = require('../../utils/object/HasValue');\r\nvar Vertices = require('./lib/geometry/Vertices');\r\n\r\n/**\r\n * @classdesc\r\n * A wrapper around a Tile that provides access to a corresponding Matter body. A tile can only\r\n * have one Matter body associated with it. You can either pass in an existing Matter body for\r\n * the tile or allow the constructor to create the corresponding body for you. If the Tile has a\r\n * collision group (defined in Tiled), those shapes will be used to create the body. If not, the\r\n * tile's rectangle bounding box will be used.\r\n *\r\n * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.\r\n *\r\n * Note: not all Tiled collision shapes are supported. See\r\n * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.\r\n *\r\n * @class TileBody\r\n * @memberOf Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - [description]\r\n * @param {Phaser.Tilemaps.Tile} tile - The target tile that should have a Matter body.\r\n * @param {object} [options] - Options to be used when creating the Matter body. See\r\n * Phaser.Physics.Matter.Matter.Body for a list of what Matter accepts.\r\n * @param {Phaser.Physics.Matter.Matter.Body} [options.body=null] - An existing Matter body to\r\n * be used instead of creating a new one.\r\n * @param {boolean} [options.isStatic=true] - Whether or not the newly created body should be\r\n * made static. This defaults to true since typically tiles should not be moved.\r\n * @param {boolean} [options.addToWorld=true] - Whether or not to add the newly created body (or\r\n * existing body if options.body is used) to the Matter world.\r\n */\r\nvar MatterTileBody = new Class({\r\n\r\n    Mixins: [\r\n        Components.Bounce,\r\n        Components.Collision,\r\n        Components.Friction,\r\n        Components.Gravity,\r\n        Components.Mass,\r\n        Components.Sensor,\r\n        Components.Sleep,\r\n        Components.Static\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function MatterTileBody (world, tile, options)\r\n    {\r\n        /**\r\n         * The tile object the body is associated with.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#tile\r\n         * @type {Phaser.Tilemaps.Tile}\r\n         * @since 3.0.0\r\n         */\r\n        this.tile = tile;\r\n\r\n        /**\r\n         * The Matter world the body exists within.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        // Install a reference to 'this' on the tile and ensure there can only be one matter body\r\n        // associated with the tile\r\n        if (tile.physics.matterBody)\r\n        {\r\n            tile.physics.matterBody.destroy();\r\n        }\r\n\r\n        tile.physics.matterBody = this;\r\n\r\n        // Set the body either from an existing body (if provided), the shapes in the tileset\r\n        // collision layer (if it exists) or a rectangle matching the tile.\r\n        var body = GetFastValue(options, 'body', null);\r\n\r\n        var addToWorld = GetFastValue(options, 'addToWorld', true);\r\n\r\n        if (!body)\r\n        {\r\n            var collisionGroup = tile.getCollisionGroup();\r\n            var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\r\n\r\n            if (collisionObjects.length > 0)\r\n            {\r\n                this.setFromTileCollision(options);\r\n            }\r\n            else\r\n            {\r\n                this.setFromTileRectangle(options);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.setBody(body, addToWorld);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the current body to a rectangle that matches the bounds of the tile.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * @param {boolean} [options.isStatic=true] - Whether or not the newly created body should be\r\n     * made static. This defaults to true since typically tiles should not be moved.\r\n     * @param {boolean} [options.addToWorld=true] - Whether or not to add the newly created body (or\r\n     * existing body if options.body is used) to the Matter world.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setFromTileRectangle: function (options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        if (!HasValue(options, 'isStatic')) { options.isStatic = true; }\r\n        if (!HasValue(options, 'addToWorld')) { options.addToWorld = true; }\r\n\r\n        var bounds = this.tile.getBounds();\r\n        var cx = bounds.x + (bounds.width / 2);\r\n        var cy = bounds.y + (bounds.height / 2);\r\n        var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);\r\n\r\n        this.setBody(body, options.addToWorld);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current body from the collision group associated with the Tile. This is typically\r\n     * set up in Tiled's collision editor.\r\n     *\r\n     * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly\r\n     * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are\r\n     * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave\r\n     * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to\r\n     * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave\r\n     * polygon into multiple convex polygons yourself.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * @param {boolean} [options.isStatic=true] - Whether or not the newly created body should be\r\n     * made static. This defaults to true since typically tiles should not be moved.\r\n     * @param {boolean} [options.addToWorld=true] - Whether or not to add the newly created body (or\r\n     * existing body if options.body is used) to the Matter world.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setFromTileCollision: function (options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        if (!HasValue(options, 'isStatic')) { options.isStatic = true; }\r\n        if (!HasValue(options, 'addToWorld')) { options.addToWorld = true; }\r\n\r\n        var sx = this.tile.tilemapLayer.scaleX;\r\n        var sy = this.tile.tilemapLayer.scaleY;\r\n        var tileX = this.tile.getLeft();\r\n        var tileY = this.tile.getTop();\r\n        var collisionGroup = this.tile.getCollisionGroup();\r\n        var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\r\n\r\n        var parts = [];\r\n\r\n        for (var i = 0; i < collisionObjects.length; i++)\r\n        {\r\n            var object = collisionObjects[i];\r\n            var ox = tileX + (object.x * sx);\r\n            var oy = tileY + (object.y * sy);\r\n            var ow = object.width * sx;\r\n            var oh = object.height * sy;\r\n            var body = null;\r\n\r\n            if (object.rectangle)\r\n            {\r\n                body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);\r\n            }\r\n            else if (object.ellipse)\r\n            {\r\n                body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);\r\n            }\r\n            else if (object.polygon || object.polyline)\r\n            {\r\n                // Polygons and polylines are both treated as closed polygons\r\n                var originalPoints = object.polygon ? object.polygon : object.polyline;\r\n\r\n                var points = originalPoints.map(function (p)\r\n                {\r\n                    return { x: p.x * sx, y: p.y * sy };\r\n                });\r\n\r\n                var vertices = Vertices.create(points);\r\n\r\n                // Points are relative to the object's origin (first point placed in Tiled), but\r\n                // matter expects points to be relative to the center of mass. This only applies to\r\n                // convex shapes. When a concave shape is decomposed, multiple parts are created and\r\n                // the individual parts are positioned relative to (ox, oy).\r\n                if (Vertices.isConvex(points))\r\n                {\r\n                    var center = Vertices.centre(vertices);\r\n                    ox += center.x;\r\n                    oy += center.y;\r\n                }\r\n\r\n                body = Bodies.fromVertices(ox, oy, vertices, options);\r\n            }\r\n\r\n            if (body)\r\n            {\r\n                parts.push(body);\r\n            }\r\n        }\r\n\r\n        if (parts.length === 1)\r\n        {\r\n            this.setBody(parts[0], options.addToWorld);\r\n        }\r\n        else if (parts.length > 1)\r\n        {\r\n            options.parts = parts;\r\n            this.setBody(Body.create(options), options.addToWorld);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current body to the given body. This will remove the previous body, if one already\r\n     * exists.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Body} body - The new Matter body to use.\r\n     * @param {boolean} [addToWorld=true] - Whether or not to add the body to the Matter world.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setBody: function (body, addToWorld)\r\n    {\r\n        if (addToWorld === undefined) { addToWorld = true; }\r\n\r\n        if (this.body)\r\n        {\r\n            this.removeBody();\r\n        }\r\n\r\n        this.body = body;\r\n        this.body.gameObject = this;\r\n\r\n        if (addToWorld)\r\n        {\r\n            this.world.add(this.body);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the current body from the TileBody and from the Matter world\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#removeBody\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    removeBody: function ()\r\n    {\r\n        if (this.body)\r\n        {\r\n            this.world.remove(this.body);\r\n            this.body.gameObject = undefined;\r\n            this.body = undefined;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the current body from the tile and the world.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeBody();\r\n        this.tile.physics.matterBody = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MatterTileBody;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","Bodies","Body","Class","Components","GetFastValue","HasValue","Vertices","MatterTileBody","Mixins","Bounce","Collision","Friction","Gravity","Mass","Sensor","Sleep","Static","initialize","world","tile","options","physics","matterBody","destroy","body","addToWorld","setBody","collisionGroup","getCollisionGroup","collisionObjects","length","setFromTileCollision","setFromTileRectangle","undefined","isStatic","bounds","getBounds","rectangle","x","width","y","height","sx","tilemapLayer","scaleX","sy","scaleY","tileX","getLeft","tileY","getTop","parts","i","object","ox","oy","ow","oh","ellipse","circle","polygon","polyline","points","map","originalPoints","p","vertices","create","isConvex","center","centre","fromVertices","push","removeBody","gameObject","add","remove"]
}
