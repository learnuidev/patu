{
"version":3,
"file":"module$node_modules$Phaser$src$gameobjects$container$Container.js",
"lineCount":14,
"mappings":"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",
"sources":["node_modules/Phaser/src/gameobjects/container/Container.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$Phaser$src$gameobjects$container$Container\"] = function(global,require,module,exports) {\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar ArrayUtils = require('../../utils/array');\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar Render = require('./ContainerRender');\r\nvar Union = require('../../geom/rectangle/Union');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Container Game Object.\r\n *\r\n * A Container, as the name implies, can 'contain' other types of Game Object.\r\n * When a Game Object is added to a Container, the Container becomes responsible for the rendering of it.\r\n * By default it will be removed from the Display List and instead added to the Containers own internal list.\r\n *\r\n * The position of the Game Object automatically becomes relative to the position of the Container.\r\n *\r\n * When the Container is rendered, all of its children are rendered as well, in the order in which they exist\r\n * within the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.\r\n *\r\n * If you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will\r\n * automatically influence all children as well.\r\n *\r\n * Containers can include other Containers for deeply nested transforms.\r\n *\r\n * Containers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.\r\n * The masks do not 'stack up'. Only a Container on the root of the display list will use its mask.\r\n *\r\n * Containers can be enabled for input. Because they do not have a texture you need to provide a shape for them\r\n * to use as their hit area. Container children can also be enabled for input, independent of the Container.\r\n *\r\n * Containers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,\r\n * if Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,\r\n * if the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children\r\n * with physics do not factor in the Container due to the excessive extra calculations needed. Please structure\r\n * your game to work around this.\r\n *\r\n * It's important to understand the impact of using Containers. They add additional processing overhead into\r\n * every one of their children. The deeper you nest them, the more the cost escalates. This is especially true\r\n * for input events. You also loose the ability to set the display depth of Container children in the same\r\n * flexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost\r\n * every time you create one, try to structure your game around avoiding that where possible.\r\n *\r\n * @class Container\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.4.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Container.\r\n */\r\nvar Container = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Container (scene, x, y, children)\r\n    {\r\n        GameObject.call(this, scene, 'Container');\r\n\r\n        /**\r\n         * An array holding the children of this Container.\r\n         *\r\n         * @name Phaser.GameObjects.Container#list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @since 3.4.0\r\n         */\r\n        this.list = [];\r\n\r\n        /**\r\n         * Does this Container exclusively manage its children?\r\n         *\r\n         * The default is `true` which means a child added to this Container cannot\r\n         * belong in another Container, which includes the Scene display list.\r\n         *\r\n         * If you disable this then this Container will no longer exclusively manage its children.\r\n         * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n         * Game Objects without reparenting them all over the Scene.\r\n         * However, doing so will prevent children from receiving any kind of input event or have\r\n         * their physics bodies work by default, as they're no longer a single entity on the\r\n         * display list, but are being replicated where-ever this Container is.\r\n         *\r\n         * @name Phaser.GameObjects.Container#exclusive\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.4.0\r\n         */\r\n        this.exclusive = true;\r\n\r\n        /**\r\n         * Containers can have an optional maximum size. If set to anything above 0 it\r\n         * will constrict the addition of new Game Objects into the Container, capping off\r\n         * the maximum limit the Container can grow in size to.\r\n         *\r\n         * @name Phaser.GameObjects.Container#maxSize\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.4.0\r\n         */\r\n        this.maxSize = -1;\r\n\r\n        /**\r\n         * The cursor position.\r\n         *\r\n         * @name Phaser.GameObjects.Container#position\r\n         * @type {integer}\r\n         * @since 3.4.0\r\n         */\r\n        this.position = 0;\r\n\r\n        /**\r\n         * Internal Transform Matrix used for local space conversion.\r\n         *\r\n         * @name Phaser.GameObjects.Container#localTransform\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.4.0\r\n         */\r\n        this.localTransform = new Components.TransformMatrix();\r\n\r\n        /**\r\n         * Internal temporary Transform Matrix used to avoid object creation.\r\n         *\r\n         * @name Phaser.GameObjects.Container#tempTransformMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this.tempTransformMatrix = new Components.TransformMatrix();\r\n\r\n        /**\r\n         * A reference to the Scene Display List.\r\n         *\r\n         * @name Phaser.GameObjects.Container#_displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._displayList = scene.sys.displayList;\r\n\r\n        /**\r\n         * The property key to sort by.\r\n         *\r\n         * @name Phaser.GameObjects.Container#_sortKey\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._sortKey = '';\r\n\r\n        /**\r\n         * A reference to the Scene Systems Event Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Container#_sysEvents\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @private\r\n         * @since 3.9.0\r\n         */\r\n        this._sysEvents = scene.sys.events;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        this.clearAlpha();\r\n\r\n        this.setBlendMode(BlendModes.SKIP_CHECK);\r\n\r\n        if (children)\r\n        {\r\n            this.add(children);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#originX\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */\r\n    originX: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#originY\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */\r\n    originY: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#displayOriginX\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */\r\n    displayOriginX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.width * 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#displayOriginY\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */\r\n    displayOriginY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.height * 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Does this Container exclusively manage its children?\r\n     *\r\n     * The default is `true` which means a child added to this Container cannot\r\n     * belong in another Container, which includes the Scene display list.\r\n     *\r\n     * If you disable this then this Container will no longer exclusively manage its children.\r\n     * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n     * Game Objects without reparenting them all over the Scene.\r\n     * However, doing so will prevent children from receiving any kind of input event or have\r\n     * their physics bodies work by default, as they're no longer a single entity on the\r\n     * display list, but are being replicated where-ever this Container is.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setExclusive\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} [value=true] - The exclusive state of this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container.\r\n     */\r\n    setExclusive: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.exclusive = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the bounds of this Container. It works by iterating all children of the Container,\r\n     * getting their respective bounds, and then working out a min-max rectangle from that.\r\n     * It does not factor in if the children render or not, all are included.\r\n     *\r\n     * Some children are unable to return their bounds, such as Graphics objects, in which case\r\n     * they are skipped.\r\n     *\r\n     * Depending on the quantity of children in this Container it could be a really expensive call,\r\n     * so cache it and only poll it as needed.\r\n     *\r\n     * The values are stored and returned in a Rectangle object.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getBounds\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [output] - A Geom.Rectangle object to store the values in. If not provided a new Rectangle will be created.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} The values stored in the output object.\r\n     */\r\n    getBounds: function (output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        output.setTo(this.x, this.y, 0, 0);\r\n\r\n        if (this.list.length > 0)\r\n        {\r\n            var children = this.list;\r\n            var tempRect = new Rectangle();\r\n\r\n            for (var i = 0; i < children.length; i++)\r\n            {\r\n                var entry = children[i];\r\n\r\n                if (entry.getBounds)\r\n                {\r\n                    entry.getBounds(tempRect);\r\n\r\n                    Union(tempRect, output, output);\r\n                }\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Internal add handler.\r\n     *\r\n     * @method Phaser.GameObjects.Container#addHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just added to this Container.\r\n     */\r\n    addHandler: function (gameObject)\r\n    {\r\n        gameObject.once('destroy', this.remove, this);\r\n\r\n        if (this.exclusive)\r\n        {\r\n            this._displayList.remove(gameObject);\r\n\r\n            if (gameObject.parentContainer)\r\n            {\r\n                gameObject.parentContainer.remove(gameObject);\r\n            }\r\n\r\n            gameObject.parentContainer = this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal remove handler.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just removed from this Container.\r\n     */\r\n    removeHandler: function (gameObject)\r\n    {\r\n        gameObject.off('destroy', this.remove);\r\n\r\n        if (this.exclusive)\r\n        {\r\n            gameObject.parentContainer = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a Point-like object, such as a Vector2, Geom.Point or object with public x and y properties,\r\n     * and transforms it into the space of this Container, then returns it in the output object.\r\n     *\r\n     * @method Phaser.GameObjects.Container#pointToContainer\r\n     * @since 3.4.0\r\n     *\r\n     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} source - The Source Point to be transformed.\r\n     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} [output] - A destination object to store the transformed point in. If none given a Vector2 will be created and returned.\r\n     *\r\n     * @return {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} The transformed point.\r\n     */\r\n    pointToContainer: function (source, output)\r\n    {\r\n        if (output === undefined) { output = new Vector2(); }\r\n\r\n        if (this.parentContainer)\r\n        {\r\n            return this.parentContainer.pointToContainer(source, output);\r\n        }\r\n\r\n        var tempMatrix = this.tempTransformMatrix;\r\n\r\n        //  No need to loadIdentity because applyITRS overwrites every value anyway\r\n        tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);\r\n\r\n        tempMatrix.invert();\r\n\r\n        tempMatrix.transformPoint(source.x, source.y, output);\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns the world transform matrix as used for Bounds checks.\r\n     * \r\n     * The returned matrix is temporal and shouldn't be stored.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getBoundsTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The world transform matrix.\r\n     */\r\n    getBoundsTransformMatrix: function ()\r\n    {\r\n        return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);\r\n    },\r\n\r\n    /**\r\n     * Adds the given Game Object, or array of Game Objects, to this Container.\r\n     *\r\n     * Each Game Object must be unique within the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#add\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    add: function (child)\r\n    {\r\n        ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given Game Object, or array of Game Objects, to this Container at the specified position.\r\n     *\r\n     * Existing Game Objects in the Container are shifted up.\r\n     *\r\n     * Each Game Object must be unique within the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#addAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n     * @param {integer} [index=0] - The position to insert the Game Object/s at.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    addAt: function (child, index)\r\n    {\r\n        ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the Game Object at the given position in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} index - The position to get the Game Object from.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The Game Object at the specified index, or `null` if none found.\r\n     */\r\n    getAt: function (index)\r\n    {\r\n        return this.list[index];\r\n    },\r\n\r\n    /**\r\n     * Returns the index of the given Game Object in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getIndex\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to search for in this Container.\r\n     *\r\n     * @return {integer} The index of the Game Object in this Container, or -1 if not found.\r\n     */\r\n    getIndex: function (child)\r\n    {\r\n        return this.list.indexOf(child);\r\n    },\r\n\r\n    /**\r\n     * Sort the contents of this Container so the items are in order based on the given property.\r\n     * For example: `sort('alpha')` would sort the elements based on the value of their `alpha` property.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sort\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property to lexically sort by.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    sort: function (property)\r\n    {\r\n        if (property)\r\n        {\r\n            this._sortKey = property;\r\n\r\n            ArrayUtils.StableSort.inplace(this.list, this.sortHandler);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal sort handler method.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sortHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first child to sort.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second child to sort.\r\n     *\r\n     * @return {integer} The sort results.\r\n     */\r\n    sortHandler: function (childA, childB)\r\n    {\r\n        return childA[this._sortKey] - childB[this._sortKey];\r\n    },\r\n\r\n    /**\r\n     * Searches for the first instance of a child with its `name` property matching the given argument.\r\n     * Should more than one child have the same name only the first is returned.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getByName\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} name - The name to search for.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The first child with a matching name, or `null` if none were found.\r\n     */\r\n    getByName: function (name)\r\n    {\r\n        return ArrayUtils.GetFirst(this.list, 'name', name);\r\n    },\r\n\r\n    /**\r\n     * Returns a random Game Object from this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getRandom\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} [startIndex=0] - An optional start index.\r\n     * @param {integer} [length] - An optional length, the total number of elements (from the startIndex) to choose from.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} A random child from the Container, or `null` if the Container is empty.\r\n     */\r\n    getRandom: function (startIndex, length)\r\n    {\r\n        return ArrayUtils.GetRandom(this.list, startIndex, length);\r\n    },\r\n\r\n    /**\r\n     * Gets the first Game Object in this Container.\r\n     *\r\n     * You can also specify a property and value to search for, in which case it will return the first\r\n     * Game Object in this Container with a matching property and / or value.\r\n     *\r\n     * For example: `getFirst('visible', true)` would return the first Game Object that had its `visible` property set.\r\n     *\r\n     * You can limit the search to the `startIndex` - `endIndex` range.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getFirst\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} [property] - The property to test on each Game Object in the Container.\r\n     * @param {*} [value] - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The first matching Game Object, or `null` if none was found.\r\n     */\r\n    getFirst: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.GetFirstElement(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Returns all Game Objects in this Container.\r\n     *\r\n     * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n     *\r\n     * For example: `getAll('body')` would return only Game Objects that have a body property.\r\n     *\r\n     * You can also specify a value to compare the property to:\r\n     *\r\n     * `getAll('visible', true)` would return only Game Objects that have their visible property set to `true`.\r\n     *\r\n     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} [property] - The property to test on each Game Object in the Container.\r\n     * @param {any} [value] - If property is set then the `property` must strictly equal this value to be included in the results.\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of matching Game Objects from this Container.\r\n     */\r\n    getAll: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Returns the total number of Game Objects in this Container that have a property\r\n     * matching the given value.\r\n     *\r\n     * For example: `count('visible', true)` would count all the elements that have their visible property set.\r\n     *\r\n     * You can optionally limit the operation to the `startIndex` - `endIndex` range.\r\n     *\r\n     * @method Phaser.GameObjects.Container#count\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property to check.\r\n     * @param {any} value - The value to check.\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {integer} The total number of Game Objects in this Container with a property matching the given value.\r\n     */\r\n    count: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two Game Objects in this Container.\r\n     * Both Game Objects must belong to this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#swap\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child1 - The first Game Object to swap.\r\n     * @param {Phaser.GameObjects.GameObject} child2 - The second Game Object to swap.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    swap: function (child1, child2)\r\n    {\r\n        ArrayUtils.Swap(this.list, child1, child2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Game Object to a new position within this Container.\r\n     *\r\n     * The Game Object must already be a child of this Container.\r\n     *\r\n     * The Game Object is removed from its old position and inserted into the new one.\r\n     * Therefore the Container size does not change. Other children will change position accordingly.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to move.\r\n     * @param {integer} index - The new position of the Game Object in this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    moveTo: function (child, index)\r\n    {\r\n        ArrayUtils.MoveTo(this.list, child, index);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Game Object, or array of Game Objects, from this Container.\r\n     *\r\n     * The Game Objects must already be children of this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#remove\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to be removed from the Container.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each child successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    remove: function (child, destroyChild)\r\n    {\r\n        var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);\r\n\r\n        if (destroyChild && removed)\r\n        {\r\n            if (!Array.isArray(removed))\r\n            {\r\n                removed = [ removed ];\r\n            }\r\n\r\n            for (var i = 0; i < removed.length; i++)\r\n            {\r\n                removed[i].destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the Game Object at the given position in this Container.\r\n     *\r\n     * You can also optionally call `destroy` on the Game Object, if one is found.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} index - The index of the Game Object to be removed.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    removeAt: function (index, destroyChild)\r\n    {\r\n        var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);\r\n\r\n        if (destroyChild && removed)\r\n        {\r\n            removed.destroy();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the Game Objects between the given positions in this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeBetween\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    removeBetween: function (startIndex, endIndex, destroyChild)\r\n    {\r\n        var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);\r\n\r\n        if (destroyChild)\r\n        {\r\n            for (var i = 0; i < removed.length; i++)\r\n            {\r\n                removed[i].destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all Game Objects from this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    removeAll: function (destroyChild)\r\n    {\r\n        var removed = ArrayUtils.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);\r\n\r\n        if (destroyChild)\r\n        {\r\n            for (var i = 0; i < removed.length; i++)\r\n            {\r\n                removed[i].destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Brings the given Game Object to the top of this Container.\r\n     * This will cause it to render on-top of any other objects in the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#bringToTop\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to bring to the top of the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    bringToTop: function (child)\r\n    {\r\n        ArrayUtils.BringToTop(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends the given Game Object to the bottom of this Container.\r\n     * This will cause it to render below any other objects in the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sendToBack\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to send to the bottom of the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    sendToBack: function (child)\r\n    {\r\n        ArrayUtils.SendToBack(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the given Game Object up one place in this Container, unless it's already at the top.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveUp\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    moveUp: function (child)\r\n    {\r\n        ArrayUtils.MoveUp(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the given Game Object down one place in this Container, unless it's already at the bottom.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveDown\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    moveDown: function (child)\r\n    {\r\n        ArrayUtils.MoveDown(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reverses the order of all Game Objects in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#reverse\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    reverse: function ()\r\n    {\r\n        this.list.reverse();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the all Game Objects in this Container using the Fisher-Yates implementation.\r\n     *\r\n     * @method Phaser.GameObjects.Container#shuffle\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    shuffle: function ()\r\n    {\r\n        ArrayUtils.Shuffle(this.list);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Replaces a Game Object in this Container with the new Game Object.\r\n     * The new Game Object cannot already be a child of this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#replace\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} oldChild - The Game Object in this Container that will be replaced.\r\n     * @param {Phaser.GameObjects.GameObject} newChild - The Game Object to be added to this Container.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    replace: function (oldChild, newChild, destroyChild)\r\n    {\r\n        var moved = ArrayUtils.Replace(this.list, oldChild, newChild);\r\n\r\n        if (moved)\r\n        {\r\n            this.addHandler(newChild);\r\n            this.removeHandler(oldChild);\r\n\r\n            if (destroyChild)\r\n            {\r\n                oldChild.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the given Game Object is a direct child of this Container.\r\n     *\r\n     * This check does not scan nested Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Container#exists\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to check for within this Container.\r\n     *\r\n     * @return {boolean} True if the Game Object is an immediate child of this Container, otherwise false.\r\n     */\r\n    exists: function (child)\r\n    {\r\n        return (this.list.indexOf(child) > -1);\r\n    },\r\n\r\n    /**\r\n     * Sets the property to the given value on all Game Objects in this Container.\r\n     *\r\n     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property that must exist on the Game Object.\r\n     * @param {any} value - The value to get the property to.\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    setAll: function (property, value, startIndex, endIndex)\r\n    {\r\n        ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * @callback EachContainerCallback\r\n     * @generic I - [item]\r\n     *\r\n     * @param {*} item - The child Game Object of the Container.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     */\r\n\r\n    /**\r\n     * Passes all Game Objects in this Container to the given callback.\r\n     *\r\n     * A copy of the Container is made before passing each entry to your callback.\r\n     * This protects against the callback itself modifying the Container.\r\n     *\r\n     * If you know for sure that the callback will not change the size of this Container\r\n     * then you can use the more performant `Container.iterate` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.Container#each\r\n     * @since 3.4.0\r\n     *\r\n     * @param {function} callback - The function to call.\r\n     * @param {object} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    each: function (callback, context)\r\n    {\r\n        var args = [ null ];\r\n        var i;\r\n        var temp = this.list.slice();\r\n        var len = temp.length;\r\n\r\n        for (i = 2; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            args[0] = temp[i];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all Game Objects in this Container to the given callback.\r\n     *\r\n     * Only use this method when you absolutely know that the Container will not be modified during\r\n     * the iteration, i.e. by removing or adding to its contents.\r\n     *\r\n     * @method Phaser.GameObjects.Container#iterate\r\n     * @since 3.4.0\r\n     *\r\n     * @param {function} callback - The function to call.\r\n     * @param {object} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */\r\n    iterate: function (callback, context)\r\n    {\r\n        var args = [ null ];\r\n        var i;\r\n\r\n        for (i = 2; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (i = 0; i < this.list.length; i++)\r\n        {\r\n            args[0] = this.list[i];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The number of Game Objects inside this Container.\r\n     *\r\n     * @name Phaser.GameObjects.Container#length\r\n     * @type {integer}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */\r\n    length: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.list.length;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the first Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#first\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */\r\n    first: {\r\n\r\n        get: function ()\r\n        {\r\n            this.position = 0;\r\n\r\n            if (this.list.length > 0)\r\n            {\r\n                return this.list[0];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the last Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#last\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */\r\n    last: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.list.length > 0)\r\n            {\r\n                this.position = this.list.length - 1;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the next Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#next\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */\r\n    next: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.position < this.list.length)\r\n            {\r\n                this.position++;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the previous Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#previous\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */\r\n    previous: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.position > 0)\r\n            {\r\n                this.position--;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Container#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.removeAll(!!this.exclusive);\r\n\r\n        this.localTransform.destroy();\r\n        this.tempTransformMatrix.destroy();\r\n\r\n        this.list = [];\r\n        this._displayList = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Container;\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","ArrayUtils","BlendModes","Class","Components","GameObject","Rectangle","Render","Union","Vector2","Container","Extends","Mixins","Alpha","BlendMode","ComputedSize","Depth","Mask","ScrollFactor","Transform","Visible","initialize","scene","x","y","children","call","list","exclusive","maxSize","position","localTransform","TransformMatrix","tempTransformMatrix","_displayList","sys","displayList","_sortKey","_sysEvents","events","setPosition","clearAlpha","setBlendMode","SKIP_CHECK","add","originX","get","originY","displayOriginX","width","displayOriginY","height","setExclusive","value","undefined","getBounds","output","setTo","length","tempRect","i","entry","addHandler","gameObject","once","remove","parentContainer","removeHandler","off","pointToContainer","source","tempMatrix","applyITRS","rotation","scaleX","scaleY","invert","transformPoint","getBoundsTransformMatrix","getWorldTransformMatrix","child","Add","addAt","index","AddAt","getAt","getIndex","indexOf","sort","property","StableSort","inplace","sortHandler","childA","childB","getByName","name","GetFirst","getRandom","startIndex","GetRandom","getFirst","endIndex","GetFirstElement","getAll","GetAll","count","CountAllMatching","swap","child1","child2","Swap","moveTo","MoveTo","destroyChild","removed","Remove","Array","isArray","destroy","removeAt","RemoveAt","removeBetween","RemoveBetween","removeAll","bringToTop","BringToTop","sendToBack","SendToBack","moveUp","MoveUp","moveDown","MoveDown","reverse","shuffle","Shuffle","replace","oldChild","newChild","Replace","moved","exists","setAll","SetAll","each","callback","context","args","temp","slice","len","arguments","push","apply","iterate","first","last","next","previous","preDestroy"]
}
